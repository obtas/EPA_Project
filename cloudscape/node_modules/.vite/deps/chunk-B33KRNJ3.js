import {
  useMergeRefs
} from "./chunk-4FOLHITS.js";
import {
  __toESM,
  require_react
} from "./chunk-C3URVCCN.js";

// node_modules/@cloudscape-design/components/internal/components/focus-lock/index.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/tab-trap/index.js
var import_react = __toESM(require_react());
function TabTrap({ focusNextCallback, disabled = false }) {
  return import_react.default.createElement("div", { tabIndex: disabled ? -1 : 0, onFocus: focusNextCallback });
}

// node_modules/@cloudscape-design/components/internal/components/focus-lock/utils.js
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
].join(",");
function getFocusables(container) {
  return Array.prototype.slice.call(container.querySelectorAll(tabbables)).filter((element) => element.tabIndex !== -1);
}
function getFirstFocusable(container) {
  var _a;
  const focusables = getFocusables(container);
  return (_a = focusables[0]) !== null && _a !== void 0 ? _a : null;
}
function getLastFocusable(container) {
  var _a;
  const focusables = getFocusables(container);
  return (_a = focusables[focusables.length - 1]) !== null && _a !== void 0 ? _a : null;
}

// node_modules/@cloudscape-design/components/internal/components/focus-lock/index.js
function FocusLock({ className, disabled, autoFocus, restoreFocus, children }, ref) {
  const returnFocusToRef = (0, import_react2.useRef)(null);
  const containerRef = (0, import_react2.useRef)(null);
  const focusFirst = () => {
    var _a;
    if (containerRef.current) {
      (_a = getFirstFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  };
  const focusLast = () => {
    var _a;
    if (containerRef.current) {
      (_a = getLastFocusable(containerRef.current)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  };
  (0, import_react2.useEffect)(() => {
    if (autoFocus && !disabled) {
      returnFocusToRef.current = document.activeElement;
      focusFirst();
    }
  }, [autoFocus, disabled]);
  const [previouslyDisabled, setPreviouslyDisabled] = (0, import_react2.useState)(!!disabled);
  (0, import_react2.useEffect)(() => {
    var _a;
    if (previouslyDisabled !== !!disabled) {
      setPreviouslyDisabled(!!disabled);
      if (restoreFocus && disabled) {
        (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        returnFocusToRef.current = null;
      }
    }
  }, [previouslyDisabled, disabled, restoreFocus]);
  const restoreFocusHandler = (0, import_react2.useCallback)((elem) => {
    var _a;
    if (elem === null && restoreFocus) {
      (_a = returnFocusToRef.current) === null || _a === void 0 ? void 0 : _a.focus();
      returnFocusToRef.current = null;
    }
  }, [restoreFocus]);
  (0, import_react2.useImperativeHandle)(ref, () => ({ focusFirst }));
  const mergedRef = useMergeRefs(containerRef, restoreFocusHandler);
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement(TabTrap, { disabled, focusNextCallback: focusLast }),
    import_react2.default.createElement("div", { className, ref: mergedRef }, children),
    import_react2.default.createElement(TabTrap, { disabled, focusNextCallback: focusFirst })
  );
}
var focus_lock_default = import_react2.default.forwardRef(FocusLock);

export {
  TabTrap,
  getFirstFocusable,
  getLastFocusable,
  focus_lock_default
};
//# sourceMappingURL=chunk-B33KRNJ3.js.map
