import {
  internal_default as internal_default3
} from "./chunk-ODPWEB7R.js";
import {
  radio_button_default
} from "./chunk-GX6DEPST.js";
import {
  browserScrollbarSize
} from "./chunk-MFOZ2YBE.js";
import {
  nodeBelongs
} from "./chunk-SQLMETPT.js";
import {
  usePrevious
} from "./chunk-W6L4JLBP.js";
import {
  InternalFormField
} from "./chunk-7PHO4AKW.js";
import {
  StatusIndicator
} from "./chunk-Q3RNZ4T5.js";
import {
  InternalSpaceBetween
} from "./chunk-Y4PSRXA7.js";
import {
  joinStrings
} from "./chunk-IXOWUQJP.js";
import {
  InternalContainer
} from "./chunk-56AI5YJ6.js";
import {
  useDynamicOverlap
} from "./chunk-7BYB2WD6.js";
import {
  StickyHeaderContext
} from "./chunk-GYM3IZ5B.js";
import {
  useAppLayoutContext
} from "./chunk-NABBUFNM.js";
import {
  getVisualContextClassname
} from "./chunk-VTHOLXAY.js";
import {
  focus_lock_default
} from "./chunk-NUB4MB4Q.js";
import {
  internal_default as internal_default2
} from "./chunk-WKOYGYGF.js";
import {
  ScreenreaderOnly,
  live_region_default
} from "./chunk-H6LQFJLG.js";
import {
  useInternalI18n
} from "./chunk-VOJM65QS.js";
import {
  getOverflowParents,
  scrollElementIntoView
} from "./chunk-LJTUXJUP.js";
import {
  useUniqueId
} from "./chunk-ZOQJCCJI.js";
import {
  fireCancelableEvent,
  fireNonCancelableEvent
} from "./chunk-CTALK4OT.js";
import {
  internal_default
} from "./chunk-CRWXG7GH.js";
import {
  useMobile
} from "./chunk-42KS5QK6.js";
import {
  ResizeObserver,
  useContainerBreakpoints,
  useContainerQuery,
  useResizeObserver
} from "./chunk-6QG3XHFW.js";
import {
  useMergeRefs
} from "./chunk-INN7TUPO.js";
import {
  KeyCode,
  __awaiter,
  __rest,
  applyDisplayName,
  clsx_m_default,
  createSingletonHandler,
  findUpUntil,
  getBaseProps,
  getContainingBlock,
  isDevelopment,
  supportsStickyPosition,
  useBaseComponent,
  useStableEventHandler,
  useVisualRefresh,
  warnOnce
} from "./chunk-BATVD76T.js";
import {
  require_react_dom
} from "./chunk-XY35XOXX.js";
import {
  __toESM,
  require_react
} from "./chunk-C3URVCCN.js";

// node_modules/@cloudscape-design/components/table/index.js
var import_react22 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/internal.js
var import_react21 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/tools-header.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/styles.scoped.css";
var styles_css_default = {
  "root": "awsui_root_wih1l_lik9w_97",
  "tools": "awsui_tools_wih1l_lik9w_108",
  "tools-filtering": "awsui_tools-filtering_wih1l_lik9w_114",
  "tools-align-right": "awsui_tools-align-right_wih1l_lik9w_128",
  "tools-pagination": "awsui_tools-pagination_wih1l_lik9w_132",
  "tools-preferences": "awsui_tools-preferences_wih1l_lik9w_132",
  "tools-small": "awsui_tools-small_wih1l_lik9w_138",
  "table": "awsui_table_wih1l_lik9w_144",
  "table-layout-fixed": "awsui_table-layout-fixed_wih1l_lik9w_150",
  "wrapper": "awsui_wrapper_wih1l_lik9w_154",
  "variant-stacked": "awsui_variant-stacked_wih1l_lik9w_163",
  "variant-container": "awsui_variant-container_wih1l_lik9w_163",
  "variant-embedded": "awsui_variant-embedded_wih1l_lik9w_167",
  "variant-borderless": "awsui_variant-borderless_wih1l_lik9w_167",
  "has-header": "awsui_has-header_wih1l_lik9w_170",
  "has-footer": "awsui_has-footer_wih1l_lik9w_173",
  "cell-merged": "awsui_cell-merged_wih1l_lik9w_190",
  "cell-merged-content": "awsui_cell-merged-content_wih1l_lik9w_201",
  "empty": "awsui_empty_wih1l_lik9w_216",
  "loading": "awsui_loading_wih1l_lik9w_220",
  "selection-control": "awsui_selection-control_wih1l_lik9w_229",
  "selection-control-header": "awsui_selection-control-header_wih1l_lik9w_236",
  "dark-header": "awsui_dark-header_wih1l_lik9w_245",
  "header-secondary": "awsui_header-secondary_wih1l_lik9w_250",
  "table-has-header": "awsui_table-has-header_wih1l_lik9w_266",
  "header-controls": "awsui_header-controls_wih1l_lik9w_270",
  "variant-full-page": "awsui_variant-full-page_wih1l_lik9w_274",
  "footer-wrapper": "awsui_footer-wrapper_wih1l_lik9w_287",
  "footer": "awsui_footer_wih1l_lik9w_287",
  "footer-with-pagination": "awsui_footer-with-pagination_wih1l_lik9w_295",
  "footer-pagination": "awsui_footer-pagination_wih1l_lik9w_303",
  "thead-active": "awsui_thead-active_wih1l_lik9w_307",
  "row": "awsui_row_wih1l_lik9w_308",
  "row-selected": "awsui_row-selected_wih1l_lik9w_309"
};

// node_modules/@cloudscape-design/components/table/tools-header.js
function ToolsHeader({ header, filter, pagination, preferences }) {
  const [breakpoint, ref] = useContainerBreakpoints(["xs"]);
  const isSmall = breakpoint === "default";
  const hasTools = filter || pagination || preferences;
  return import_react.default.createElement(
    import_react.default.Fragment,
    null,
    header,
    hasTools && import_react.default.createElement(
      "div",
      { ref, className: clsx_m_default(styles_css_default.tools, isSmall && styles_css_default["tools-small"]) },
      filter && import_react.default.createElement("div", { className: styles_css_default["tools-filtering"] }, filter),
      import_react.default.createElement(
        "div",
        { className: styles_css_default["tools-align-right"] },
        pagination && import_react.default.createElement("div", { className: styles_css_default["tools-pagination"] }, pagination),
        preferences && import_react.default.createElement("div", { className: styles_css_default["tools-preferences"] }, preferences)
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var import_react9 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection-control/index.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/selection-control/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/selection-control/styles.scoped.css";
var styles_css_default2 = {
  "root": "awsui_root_1ut8b_i97ok_93",
  "label": "awsui_label_1ut8b_i97ok_97",
  "stud": "awsui_stud_1ut8b_i97ok_111"
};

// node_modules/@cloudscape-design/components/table/selection-control/index.js
function SelectionControl(_a) {
  var { selectionType, indeterminate = false, onShiftToggle, onFocusUp, onFocusDown, name, ariaLabel, focusedComponent, onFocusedComponentChange } = _a, sharedProps = __rest(_a, ["selectionType", "indeterminate", "onShiftToggle", "onFocusUp", "onFocusDown", "name", "ariaLabel", "focusedComponent", "onFocusedComponentChange"]);
  const controlId = useUniqueId();
  const isMultiSelection = selectionType === "multi";
  const setShiftState = (event) => {
    if (isMultiSelection) {
      onShiftToggle && onShiftToggle(event.shiftKey);
    }
  };
  const onMouseDownHandler = (event) => {
    setShiftState(event);
    if (isMultiSelection) {
      event.preventDefault();
    }
  };
  const handleKeyDown = (event) => {
    setShiftState(event);
    if (isMultiSelection) {
      if (event.keyCode === KeyCode.up) {
        event.preventDefault();
        onFocusUp && onFocusUp(event);
      }
      if (event.keyCode === KeyCode.down) {
        event.preventDefault();
        onFocusDown && onFocusDown(event);
      }
    }
  };
  const handleClick = (event) => {
    const target = event.currentTarget;
    const nativeInput = target.tagName === "INPUT" ? target : target.querySelector("input");
    nativeInput === null || nativeInput === void 0 ? void 0 : nativeInput.focus();
  };
  const selector = isMultiSelection ? import_react2.default.createElement(internal_default3, Object.assign({}, sharedProps, { showOutline: (focusedComponent === null || focusedComponent === void 0 ? void 0 : focusedComponent.type) === "selection", onFocus: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange({ type: "selection" }), onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null), controlId, indeterminate })) : import_react2.default.createElement(radio_button_default, Object.assign({}, sharedProps, { controlId, name, value: "", label: "" }));
  return import_react2.default.createElement(
    import_react2.default.Fragment,
    null,
    import_react2.default.createElement("label", { onKeyDown: handleKeyDown, onKeyUp: setShiftState, onMouseDown: onMouseDownHandler, onMouseUp: setShiftState, onClick: handleClick, htmlFor: controlId, className: clsx_m_default(styles_css_default2.label, styles_css_default2.root), "aria-label": ariaLabel, title: ariaLabel }, selector),
    import_react2.default.createElement("span", { className: clsx_m_default(styles_css_default2.stud), "aria-hidden": true }, "\xA0")
  );
}

// node_modules/@cloudscape-design/components/table/use-selection.js
var import_react3 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/utils.js
var applyTrackBy = (trackBy, item) => {
  if (typeof trackBy === "function") {
    return trackBy(item);
  }
  return item[trackBy];
};
var getItemKey = (trackBy, item, index) => {
  if (!trackBy) {
    return index;
  }
  return applyTrackBy(trackBy, item);
};
var getTrackableValue = (trackBy, item) => {
  if (!trackBy) {
    return item;
  }
  return applyTrackBy(trackBy, item);
};
var getColumnKey = (column, index) => {
  return column.id || index;
};
var toContainerVariant = (variant) => {
  const isDefaultVariant = !variant || variant === "container";
  return isDefaultVariant ? "default" : variant === "borderless" ? "embedded" : variant;
};
function checkSortingState(columnDefinitions, sortingComparator) {
  const matchedColumn = columnDefinitions.filter((column) => column.sortingComparator === sortingComparator)[0];
  if (!matchedColumn) {
    warnOnce("Table", "Currently active sorting comparator was not found in any columns. Make sure to provide the same comparator function instance on each render.");
  }
}
function getVisibleColumnDefinitions({ columnDisplay, visibleColumns, columnDefinitions }) {
  if (columnDisplay) {
    return getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions });
  } else if (visibleColumns) {
    return getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions });
  } else {
    return columnDefinitions;
  }
}
function getVisibleColumnDefinitionsFromColumnDisplay({ columnDisplay, columnDefinitions }) {
  const columnDefinitionsById = columnDefinitions.reduce((accumulator, item) => item.id === void 0 ? accumulator : Object.assign(Object.assign({}, accumulator), { [item.id]: item }), {});
  return columnDisplay.filter((item) => item.visible).map((item) => columnDefinitionsById[item.id]).filter(Boolean);
}
function getVisibleColumnDefinitionsFromVisibleColumns({ visibleColumns, columnDefinitions }) {
  const ids = new Set(visibleColumns);
  return columnDefinitions.filter(({ id }) => id !== void 0 && ids.has(id));
}
function getStickyClassNames(styles, props) {
  return {
    [styles["sticky-cell"]]: !!props,
    [styles["sticky-cell-pad-left"]]: !!(props === null || props === void 0 ? void 0 : props.padLeft),
    [styles["sticky-cell-last-left"]]: !!(props === null || props === void 0 ? void 0 : props.lastLeft),
    [styles["sticky-cell-last-right"]]: !!(props === null || props === void 0 ? void 0 : props.lastRight)
  };
}

// node_modules/@cloudscape-design/components/table/use-selection.js
var SELECTION_ITEM = "selection-item";
var SELECTION_ROOT = "selection-root";
function findSelectionControlByIndex(rootContainer, index) {
  if (index === -1) {
    return rootContainer.querySelector(`[data-${SELECTION_ITEM}="all"] .${styles_css_default2.root} input`);
  }
  return rootContainer.querySelectorAll(`[data-${SELECTION_ITEM}="item"] .${styles_css_default2.root} input`)[index];
}
function findRootContainer(element) {
  return findUpUntil(element, (node) => node.dataset.selectionRoot === "true");
}
function useFocusMove(selectionType, totalItems) {
  if (selectionType !== "multi") {
    return {};
  }
  function moveFocus(sourceElement, fromIndex, direction) {
    let index = fromIndex;
    const rootContainer = findRootContainer(sourceElement);
    while (index >= -1 && index < totalItems) {
      index += direction;
      const control = findSelectionControlByIndex(rootContainer, index);
      if (control && !control.disabled) {
        control.focus();
        break;
      }
    }
  }
  const [moveFocusDown, moveFocusUp] = [1, -1].map((direction) => {
    return (event) => {
      const target = event.currentTarget;
      const itemNode = findUpUntil(target, (node) => node.dataset.selectionItem === "item");
      const fromIndex = Array.prototype.indexOf.call(itemNode.parentElement.children, itemNode);
      moveFocus(target, fromIndex, direction);
    };
  });
  return {
    moveFocusDown,
    moveFocusUp,
    moveFocus
  };
}
var ItemSet = class {
  constructor(trackBy, items) {
    this.map = /* @__PURE__ */ new Map();
    this.put = (item) => this.map.set.call(this.map, getTrackableValue(this.trackBy, item), item);
    this.has = (item) => this.map.has.call(this.map, getTrackableValue(this.trackBy, item));
    this.forEach = this.map.forEach.bind(this.map);
    this.trackBy = trackBy;
    items.forEach(this.put);
  }
};
var focusMarkers = {
  item: { ["data-" + SELECTION_ITEM]: "item" },
  all: { ["data-" + SELECTION_ITEM]: "all" },
  root: { ["data-" + SELECTION_ROOT]: "true" }
};
function useSelection({ items, selectedItems = [], selectionType, isItemDisabled = () => false, trackBy, onSelectionChange, ariaLabels, loading }) {
  const [shiftPressed, setShiftPressed] = (0, import_react3.useState)(false);
  const [lastClickedItem, setLastClickedItem] = (0, import_react3.useState)(null);
  const selectionName = useUniqueId();
  const finalSelectedItems = selectionType === "single" ? selectedItems.slice(0, 1) : selectedItems;
  const selectedSet = new ItemSet(trackBy, finalSelectedItems);
  const itemIndexesMap = /* @__PURE__ */ new Map();
  items.forEach((item, i) => itemIndexesMap.set(getTrackableValue(trackBy, item), i));
  const isItemSelected = selectedSet.has.bind(selectedSet);
  const getItemState = (item) => ({
    disabled: isItemDisabled(item),
    selected: isItemSelected(item)
  });
  const [allDisabled, allEnabledSelected] = selectionType ? items.reduce(([allDisabled2, allEnabledSelected2], item) => {
    const { disabled, selected } = getItemState(item);
    return [
      allDisabled2 && disabled,
      allEnabledSelected2 && (selected || disabled)
    ];
  }, [true, true]) : [true, true];
  const hasSelected = finalSelectedItems.length > 0;
  const handleToggleAll = () => {
    const requestedItems = new ItemSet(trackBy, items);
    const newSelectedItems = allEnabledSelected ? deselectItems(requestedItems) : selectItems(requestedItems);
    fireNonCancelableEvent(onSelectionChange, { selectedItems: newSelectedItems });
  };
  const getRequestedItems = (item) => {
    const requestedItems = new ItemSet(trackBy, [item]);
    let lastClickedItemIndex = lastClickedItem ? itemIndexesMap.get(getTrackableValue(trackBy, lastClickedItem)) : -1;
    if (lastClickedItemIndex === void 0) {
      lastClickedItemIndex = -1;
    }
    if (shiftPressed && lastClickedItemIndex !== -1) {
      const currentItemIndex = itemIndexesMap.get(getTrackableValue(trackBy, item));
      const start = Math.min(currentItemIndex, lastClickedItemIndex);
      const end = Math.max(currentItemIndex, lastClickedItemIndex);
      items.slice(start, end + 1).forEach((item2) => requestedItems.put(item2));
    }
    return requestedItems;
  };
  const deselectItems = (requestedItems) => {
    const newSelectedItems = [];
    selectedItems.forEach((selectedItem) => {
      const toUnselect = requestedItems.has(selectedItem);
      if (!toUnselect || isItemDisabled(selectedItem)) {
        newSelectedItems.push(selectedItem);
      }
    });
    return newSelectedItems;
  };
  const selectItems = (requestedItems) => {
    const newSelectedItems = [...selectedItems];
    requestedItems.forEach((newItem) => {
      const { selected, disabled } = getItemState(newItem);
      if (!selected && !disabled) {
        newSelectedItems.push(newItem);
      }
    });
    return newSelectedItems;
  };
  const handleToggleItem = (item) => () => {
    const { disabled, selected } = getItemState(item);
    if (disabled || selectionType === "single" && selected) {
      return;
    }
    if (selectionType === "single") {
      fireNonCancelableEvent(onSelectionChange, { selectedItems: [item] });
    } else {
      const requestedItems = getRequestedItems(item);
      const selectedItems2 = selected ? deselectItems(requestedItems) : selectItems(requestedItems);
      fireNonCancelableEvent(onSelectionChange, { selectedItems: selectedItems2 });
      setLastClickedItem(item);
    }
  };
  return {
    isItemSelected,
    getSelectAllProps: () => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        disabled: allDisabled || !!loading,
        selectionType,
        indeterminate: hasSelected && !allEnabledSelected,
        checked: hasSelected && allEnabledSelected,
        onChange: handleToggleAll,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.allItemsSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }))
      };
    },
    getItemSelectionProps: (item) => {
      var _a;
      if (!selectionType) {
        throw new Error("Invariant violation: calling selection props with missing selection type.");
      }
      return {
        name: selectionName,
        selectionType,
        ariaLabel: joinStrings(ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel, (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.itemSelectionLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, { selectedItems }, item)),
        onChange: handleToggleItem(item),
        checked: isItemSelected(item),
        disabled: isItemDisabled(item)
      };
    },
    updateShiftToggle: (value) => {
      setShiftPressed(value);
    }
  };
}

// node_modules/@cloudscape-design/components/table/header-cell/index.js
var import_react8 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/header-cell/utils.js
var stateToIcon = {
  sortable: "caret-down",
  ascending: "caret-up-filled",
  descending: "caret-down-filled"
};
var stateToAriaSort = {
  sortable: "none",
  ascending: "ascending",
  descending: "descending"
};
var getSortingStatus = (sortable, sorted, descending, disabled) => {
  if (sorted) {
    if (descending) {
      return "descending";
    }
    return "ascending";
  }
  if (sortable && !disabled) {
    return "sortable";
  }
  return void 0;
};
var getSortingIconName = (sortingState) => stateToIcon[sortingState];
var getAriaSort = (sortingState) => stateToAriaSort[sortingState];
var isSorted = (column, sortingColumn) => column === sortingColumn || column.sortingField !== void 0 && column.sortingField === sortingColumn.sortingField || column.sortingComparator !== void 0 && column.sortingComparator === sortingColumn.sortingComparator;

// node_modules/@cloudscape-design/components/table/header-cell/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/header-cell/styles.scoped.css";
var styles_css_default3 = {
  "header-cell": "awsui_header-cell_1spae_1knid_93",
  "header-cell-sticky": "awsui_header-cell-sticky_1spae_1knid_105",
  "header-cell-stuck": "awsui_header-cell-stuck_1spae_1knid_108",
  "header-cell-variant-full-page": "awsui_header-cell-variant-full-page_1spae_1knid_108",
  "header-cell-hidden": "awsui_header-cell-hidden_1spae_1knid_111",
  "header-cell-sortable": "awsui_header-cell-sortable_1spae_1knid_114",
  "sticky-cell": "awsui_sticky-cell_1spae_1knid_117",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_1spae_1knid_125",
  "has-selection": "awsui_has-selection_1spae_1knid_125",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_1spae_1knid_128",
  "header-cell-resizable": "awsui_header-cell-resizable_1spae_1knid_132",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_1spae_1knid_135",
  "sorting-icon": "awsui_sorting-icon_1spae_1knid_165",
  "edit-icon": "awsui_edit-icon_1spae_1knid_173",
  "header-cell-content": "awsui_header-cell-content_1spae_1knid_179",
  "header-cell-fake-focus": "awsui_header-cell-fake-focus_1spae_1knid_208",
  "header-cell-disabled": "awsui_header-cell-disabled_1spae_1knid_226",
  "header-cell-sorted": "awsui_header-cell-sorted_1spae_1knid_226",
  "header-cell-text": "awsui_header-cell-text_1spae_1knid_240",
  "header-cell-text-wrap": "awsui_header-cell-text-wrap_1spae_1knid_245",
  "header-cell-ascending": "awsui_header-cell-ascending_1spae_1knid_251",
  "header-cell-descending": "awsui_header-cell-descending_1spae_1knid_252",
  "is-visual-refresh": "awsui_is-visual-refresh_1spae_1knid_262",
  "has-striped-rows": "awsui_has-striped-rows_1spae_1knid_273"
};

// node_modules/@cloudscape-design/components/table/resizer/index.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/resizer/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/resizer/styles.scoped.css";
var styles_css_default4 = {
  "resize-active": "awsui_resize-active_x7peu_18l4k_93",
  "resize-active-with-focus": "awsui_resize-active-with-focus_x7peu_18l4k_93",
  "resizer": "awsui_resizer_x7peu_18l4k_98",
  "resizer-active": "awsui_resizer-active_x7peu_18l4k_114",
  "has-focus": "awsui_has-focus_x7peu_18l4k_126",
  "tracker": "awsui_tracker_x7peu_18l4k_149"
};

// node_modules/@cloudscape-design/components/table/use-column-widths.js
var import_react4 = __toESM(require_react());
var DEFAULT_COLUMN_WIDTH = 120;
function readWidths(getCell, visibleColumns) {
  var _a;
  const result = {};
  for (let index = 0; index < visibleColumns.length; index++) {
    const column = visibleColumns[index];
    let width = column.width || 0;
    const minWidth = column.minWidth || width || DEFAULT_COLUMN_WIDTH;
    if (!width && index !== visibleColumns.length - 1) {
      const colEl = getCell(column.id);
      width = (_a = colEl === null || colEl === void 0 ? void 0 : colEl.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : DEFAULT_COLUMN_WIDTH;
    }
    result[column.id] = Math.max(width, minWidth);
  }
  return result;
}
function updateWidths(visibleColumns, oldWidths, newWidth, columnId) {
  const column = visibleColumns.find((column2) => column2.id === columnId);
  const minWidth = typeof (column === null || column === void 0 ? void 0 : column.minWidth) === "number" ? column.minWidth : DEFAULT_COLUMN_WIDTH;
  newWidth = Math.max(newWidth, minWidth);
  if (oldWidths[columnId] === newWidth) {
    return oldWidths;
  }
  return Object.assign(Object.assign({}, oldWidths), { [columnId]: newWidth });
}
var WidthsContext = (0, import_react4.createContext)({
  totalWidth: 0,
  columnWidths: {},
  updateColumn: () => {
  },
  setCell: () => {
  }
});
function ColumnWidthsProvider({ visibleColumns, resizableColumns, children }) {
  const visibleColumnsRef = (0, import_react4.useRef)(null);
  const [columnWidths, setColumnWidths] = (0, import_react4.useState)({});
  const cellsRef = (0, import_react4.useRef)({});
  const getCell = (columnId) => {
    var _a;
    return (_a = cellsRef.current[columnId]) !== null && _a !== void 0 ? _a : null;
  };
  const setCell = (columnId, node) => {
    if (node) {
      cellsRef.current[columnId] = node;
    } else {
      delete cellsRef.current[columnId];
    }
  };
  (0, import_react4.useEffect)(() => {
    if (!resizableColumns) {
      return;
    }
    const updates = {};
    const lastVisible = visibleColumnsRef.current;
    if (lastVisible) {
      for (let index = 0; index < visibleColumns.length; index++) {
        const column = visibleColumns[index];
        if (!columnWidths[column.id] && lastVisible.indexOf(column.id) === -1) {
          updates[column.id] = column.width || DEFAULT_COLUMN_WIDTH;
        }
      }
      if (Object.keys(updates).length > 0) {
        setColumnWidths((columnWidths2) => Object.assign(Object.assign({}, columnWidths2), updates));
      }
    }
    visibleColumnsRef.current = visibleColumns.map((column) => column.id);
  }, [columnWidths, resizableColumns, visibleColumns]);
  (0, import_react4.useEffect)(() => {
    if (!resizableColumns) {
      return;
    }
    setColumnWidths(() => readWidths(getCell, visibleColumns));
  }, []);
  function updateColumn(columnId, newWidth) {
    setColumnWidths((columnWidths2) => updateWidths(visibleColumns, columnWidths2, newWidth, columnId));
  }
  const totalWidth = visibleColumns.reduce((total, column) => total + (columnWidths[column.id] || DEFAULT_COLUMN_WIDTH), 0);
  return import_react4.default.createElement(WidthsContext.Provider, { value: { columnWidths, totalWidth, updateColumn, setCell } }, children);
}
function useColumnWidths() {
  return (0, import_react4.useContext)(WidthsContext);
}

// node_modules/@cloudscape-design/components/table/resizer/index.js
var AUTO_GROW_START_TIME = 10;
var AUTO_GROW_INTERVAL = 10;
var AUTO_GROW_INCREMENT = 5;
function Resizer({ onDragMove, onFinish, ariaLabelledby, minWidth = DEFAULT_COLUMN_WIDTH, tabIndex, showFocusRing, onFocus, onBlur }) {
  const [isDragging, setIsDragging] = (0, import_react5.useState)(false);
  const [headerCell, setHeaderCell] = (0, import_react5.useState)();
  const autoGrowTimeout = (0, import_react5.useRef)();
  const onFinishStable = useStableEventHandler(onFinish);
  const onDragStable = useStableEventHandler(onDragMove);
  const [resizerHasFocus, setResizerHasFocus] = (0, import_react5.useState)(false);
  const [headerCellWidth, setHeaderCellWidth] = (0, import_react5.useState)(0);
  (0, import_react5.useEffect)(() => {
    if (!isDragging && !resizerHasFocus || !headerCell) {
      return;
    }
    const rootElement = findUpUntil(headerCell, (element) => element.className.indexOf(styles_css_default.root) > -1);
    const tableElement = rootElement.querySelector(`table`);
    const tracker = rootElement.querySelector(`.${styles_css_default4.tracker}`);
    const scrollParent = getOverflowParents(headerCell)[0];
    const { left: leftEdge, right: rightEdge } = scrollParent.getBoundingClientRect();
    const updateTrackerPosition = (newOffset) => {
      const { left: scrollParentLeft } = tableElement.getBoundingClientRect();
      tracker.style.top = headerCell.getBoundingClientRect().height + "px";
      tracker.style.left = newOffset - scrollParentLeft - 1 + "px";
    };
    const updateColumnWidth = (newWidth) => {
      const { right, width } = headerCell.getBoundingClientRect();
      const updatedWidth = newWidth < minWidth ? minWidth : newWidth;
      updateTrackerPosition(right + updatedWidth - width);
      setHeaderCellWidth(newWidth);
      onDragStable(newWidth);
    };
    const resizeColumn = (offset) => {
      if (offset > leftEdge) {
        const cellLeft = headerCell.getBoundingClientRect().left;
        const newWidth = offset - cellLeft;
        updateColumnWidth(newWidth);
      }
    };
    const onAutoGrow = () => {
      const width = headerCell.getBoundingClientRect().width;
      autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_INTERVAL);
      updateColumnWidth(width + AUTO_GROW_INCREMENT);
      scrollParent.scrollLeft += AUTO_GROW_INCREMENT;
    };
    const onMouseMove = (event) => {
      clearTimeout(autoGrowTimeout.current);
      const offset = event.pageX;
      if (offset > rightEdge) {
        autoGrowTimeout.current = setTimeout(onAutoGrow, AUTO_GROW_START_TIME);
      } else {
        resizeColumn(offset);
      }
    };
    const onMouseUp = (event) => {
      resizeColumn(event.pageX);
      setIsDragging(false);
      onFinishStable();
      clearTimeout(autoGrowTimeout.current);
    };
    const onKeyDown = (event) => {
      if (event.keyCode === KeyCode.left || event.keyCode === KeyCode.right) {
        event.preventDefault();
      }
      if (event.keyCode === KeyCode.left) {
        updateColumnWidth(headerCell.getBoundingClientRect().width - 10);
      }
      if (event.keyCode === KeyCode.right) {
        updateColumnWidth(headerCell.getBoundingClientRect().width + 10);
      }
    };
    updateTrackerPosition(headerCell.getBoundingClientRect().right);
    document.body.classList.add(styles_css_default4["resize-active"]);
    document.body.classList.remove(styles_css_default4["resize-active-with-focus"]);
    if (isDragging) {
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    }
    if (resizerHasFocus) {
      document.body.classList.add(styles_css_default4["resize-active-with-focus"]);
      headerCell.addEventListener("keydown", onKeyDown);
    }
    return () => {
      clearTimeout(autoGrowTimeout.current);
      document.body.classList.remove(styles_css_default4["resize-active"]);
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
      headerCell.removeEventListener("keydown", onKeyDown);
    };
  }, [headerCell, isDragging, onDragStable, onFinishStable, resizerHasFocus, minWidth]);
  return import_react5.default.createElement("span", { className: clsx_m_default(styles_css_default4.resizer, isDragging && styles_css_default4["resizer-active"], (resizerHasFocus || showFocusRing) && styles_css_default4["has-focus"]), onMouseDown: (event) => {
    if (event.button !== 0) {
      return;
    }
    event.preventDefault();
    const headerCell2 = findUpUntil(event.currentTarget, (element) => element.tagName.toLowerCase() === "th");
    setIsDragging(true);
    setHeaderCell(headerCell2);
  }, onFocus: (event) => {
    const headerCell2 = findUpUntil(event.currentTarget, (element) => element.tagName.toLowerCase() === "th");
    setHeaderCellWidth(headerCell2.getBoundingClientRect().width);
    setResizerHasFocus(true);
    setHeaderCell(headerCell2);
    onFocus === null || onFocus === void 0 ? void 0 : onFocus();
  }, onBlur: () => {
    setResizerHasFocus(false);
    onBlur === null || onBlur === void 0 ? void 0 : onBlur();
  }, role: "separator", "aria-orientation": "vertical", "aria-labelledby": ariaLabelledby, "aria-valuenow": headerCellWidth, "aria-valuetext": headerCellWidth.toString(), "aria-valuemin": minWidth, tabIndex });
}
function ResizeTracker() {
  return import_react5.default.createElement("span", { className: styles_css_default4.tracker });
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var import_react7 = __toESM(require_react());

// node_modules/@cloudscape-design/components/area-chart/async-store/index.js
var import_react6 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());
var AsyncStore = class {
  constructor(state) {
    this._listeners = [];
    this._state = state;
  }
  get() {
    return this._state;
  }
  set(cb) {
    const prevState = this._state;
    const newState = cb(prevState);
    this._state = newState;
    (0, import_react_dom.unstable_batchedUpdates)(() => {
      for (const [selector, listener] of this._listeners) {
        if (selector(prevState) !== selector(newState)) {
          listener(newState, prevState);
        }
      }
    });
  }
  subscribe(selector, listener) {
    this._listeners.push([selector, listener]);
    return () => this.unsubscribe(listener);
  }
  unsubscribe(listener) {
    for (let index = 0; index < this._listeners.length; index++) {
      const [, storedListener] = this._listeners[index];
      if (storedListener === listener) {
        this._listeners.splice(index, 1);
        break;
      }
    }
  }
};
function useReaction(store, selector, effect) {
  (0, import_react6.useLayoutEffect)(
    () => {
      const unsubscribe = store.subscribe(selector, (newState, prevState) => effect(selector(newState), selector(prevState)));
      return unsubscribe;
    },
    [store]
  );
}
function useSelector(store, selector) {
  const [state, setState] = (0, import_react6.useState)(selector(store.get()));
  useReaction(store, selector, (newState) => {
    setState(newState);
  });
  const prevStore = usePrevious(store);
  if (prevStore !== null && prevStore !== store) {
    return selector(store.get());
  }
  return state;
}

// node_modules/@cloudscape-design/components/table/sticky-columns/use-sticky-columns.js
var MINIMUM_SCROLLABLE_SPACE = 148;
function useStickyColumns({ visibleColumns, stickyColumnsFirst, stickyColumnsLast }) {
  const store = (0, import_react7.useMemo)(() => new StickyColumnsStore(), []);
  const wrapperRef = (0, import_react7.useRef)(null);
  const tableRef = (0, import_react7.useRef)(null);
  const cellsRef = (0, import_react7.useRef)({});
  const hasStickyColumns = stickyColumnsFirst + stickyColumnsLast > 0;
  const updateStickyStyles = useStableEventHandler(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  });
  useResizeObserver(wrapperRef, updateStickyStyles);
  useResizeObserver(tableRef, updateStickyStyles);
  (0, import_react7.useEffect)(() => {
    if (wrapperRef.current && tableRef.current) {
      store.updateCellStyles({
        wrapper: wrapperRef.current,
        table: tableRef.current,
        cells: cellsRef.current,
        visibleColumns,
        stickyColumnsFirst,
        stickyColumnsLast
      });
    }
  }, [store, stickyColumnsFirst, stickyColumnsLast, visibleColumns]);
  (0, import_react7.useEffect)(() => {
    if (!hasStickyColumns) {
      return;
    }
    const selector = (state) => state.wrapperState;
    const updateWrapperStyles = (state, prev) => {
      if (isWrapperStatesEqual(state, prev)) {
        return;
      }
      if (wrapperRef.current) {
        wrapperRef.current.style.scrollPaddingLeft = state.scrollPaddingLeft + "px";
        wrapperRef.current.style.scrollPaddingRight = state.scrollPaddingRight + "px";
      }
    };
    const unsubscribe = store.subscribe(selector, (newState, prevState) => updateWrapperStyles(selector(newState), selector(prevState)));
    return unsubscribe;
  }, [store, hasStickyColumns]);
  const setWrapper = (0, import_react7.useCallback)((node) => {
    if (wrapperRef.current) {
      wrapperRef.current.removeEventListener("scroll", updateStickyStyles);
    }
    if (node && hasStickyColumns) {
      node.addEventListener("scroll", updateStickyStyles);
    }
    wrapperRef.current = node;
  }, [hasStickyColumns, updateStickyStyles]);
  const setTable = (0, import_react7.useCallback)((node) => {
    tableRef.current = node;
  }, []);
  const setCell = (0, import_react7.useCallback)((columnId, node) => {
    if (node) {
      cellsRef.current[columnId] = node;
    } else {
      delete cellsRef.current[columnId];
    }
  }, []);
  return {
    isEnabled: hasStickyColumns,
    store,
    style: {
      wrapper: hasStickyColumns ? Object.assign({}, store.get().wrapperState) : void 0
    },
    refs: { wrapper: setWrapper, table: setTable, cell: setCell }
  };
}
function useStickyCellStyles({ stickyColumns, columnId, getClassName }) {
  var _a;
  const cellRef = (0, import_react7.useRef)(null);
  const setCell = stickyColumns.refs.cell;
  const unsubscribeRef = (0, import_react7.useRef)(null);
  const refCallback = (0, import_react7.useCallback)(
    (node) => {
      if (unsubscribeRef.current) {
        unsubscribeRef.current();
      }
      cellRef.current = node;
      setCell(columnId, node);
      const selector = (state) => state.cellState[columnId];
      const updateCellStyles = (state, prev) => {
        if (isCellStatesEqual(state, prev)) {
          return;
        }
        const className = getClassName(state);
        const cellElement = cellRef.current;
        if (cellElement) {
          Object.keys(className).forEach((key) => {
            if (className[key]) {
              cellElement.classList.add(key);
            } else {
              cellElement.classList.remove(key);
            }
          });
          cellElement.style.left = (state === null || state === void 0 ? void 0 : state.offset.left) !== void 0 ? `${state.offset.left}px` : "";
          cellElement.style.right = (state === null || state === void 0 ? void 0 : state.offset.right) !== void 0 ? `${state.offset.right}px` : "";
        }
      };
      if (node) {
        unsubscribeRef.current = stickyColumns.store.subscribe(selector, (newState, prevState) => {
          updateCellStyles(selector(newState), selector(prevState));
        });
      }
    },
    [columnId, setCell, stickyColumns.store]
  );
  const cellStyles = stickyColumns.store.get().cellState[columnId];
  return {
    ref: refCallback,
    className: cellStyles ? clsx_m_default(getClassName(cellStyles)) : void 0,
    style: (_a = cellStyles === null || cellStyles === void 0 ? void 0 : cellStyles.offset) !== null && _a !== void 0 ? _a : void 0
  };
}
function isCellStatesEqual(s1, s2) {
  if (s1 && s2) {
    return s1.padLeft === s2.padLeft && s1.lastLeft === s2.lastLeft && s1.lastRight === s2.lastRight && s1.offset.left === s2.offset.left && s1.offset.right === s2.offset.right;
  }
  return s1 === s2;
}
function isWrapperStatesEqual(s1, s2) {
  return s1.scrollPaddingLeft === s2.scrollPaddingLeft && s1.scrollPaddingRight === s2.scrollPaddingRight;
}
var StickyColumnsStore = class extends AsyncStore {
  constructor() {
    super({ cellState: {}, wrapperState: { scrollPaddingLeft: 0, scrollPaddingRight: 0 } });
    this.cellOffsets = /* @__PURE__ */ new Map();
    this.stickyWidthLeft = 0;
    this.stickyWidthRight = 0;
    this.isStuckToTheLeft = false;
    this.isStuckToTheRight = false;
    this.padLeft = false;
    this.generateCellStyles = (props) => {
      const isEnabled = this.isEnabled(props);
      const lastLeftStickyColumnIndex = props.stickyColumnsFirst - 1;
      const lastRightStickyColumnIndex = props.visibleColumns.length - props.stickyColumnsLast;
      return props.visibleColumns.reduce((acc, columnId, index) => {
        var _a, _b, _c, _d;
        let stickySide = "non-sticky";
        if (index < props.stickyColumnsFirst) {
          stickySide = "left";
        } else if (index >= props.visibleColumns.length - props.stickyColumnsLast) {
          stickySide = "right";
        }
        if (!isEnabled || stickySide === "non-sticky") {
          acc[columnId] = null;
          return acc;
        }
        const isFirstColumn = index === 0;
        const stickyColumnOffsetLeft = (_b = (_a = this.cellOffsets.get(columnId)) === null || _a === void 0 ? void 0 : _a.first) !== null && _b !== void 0 ? _b : 0;
        const stickyColumnOffsetRight = (_d = (_c = this.cellOffsets.get(columnId)) === null || _c === void 0 ? void 0 : _c.last) !== null && _d !== void 0 ? _d : 0;
        acc[columnId] = {
          padLeft: isFirstColumn && this.padLeft,
          lastLeft: this.isStuckToTheLeft && lastLeftStickyColumnIndex === index,
          lastRight: this.isStuckToTheRight && lastRightStickyColumnIndex === index,
          offset: {
            left: stickySide === "left" ? stickyColumnOffsetLeft : void 0,
            right: stickySide === "right" ? stickyColumnOffsetRight : void 0
          }
        };
        return acc;
      }, {});
    };
    this.updateCellOffsets = (props) => {
      var _a, _b, _c, _d, _e, _f;
      const firstColumnsWidths = [];
      for (let i = 0; i < props.visibleColumns.length; i++) {
        const element = props.cells[props.visibleColumns[i]];
        const cellWidth = (_a = element.getBoundingClientRect().width) !== null && _a !== void 0 ? _a : 0;
        firstColumnsWidths[i] = ((_b = firstColumnsWidths[i - 1]) !== null && _b !== void 0 ? _b : 0) + cellWidth;
      }
      const lastColumnsWidths = [];
      for (let i = props.visibleColumns.length - 1; i >= 0; i--) {
        const element = props.cells[props.visibleColumns[i]];
        const cellWidth = (_c = element.getBoundingClientRect().width) !== null && _c !== void 0 ? _c : 0;
        lastColumnsWidths[i] = ((_d = lastColumnsWidths[i + 1]) !== null && _d !== void 0 ? _d : 0) + cellWidth;
      }
      lastColumnsWidths.reverse();
      this.stickyWidthLeft = (_e = firstColumnsWidths[props.stickyColumnsFirst - 1]) !== null && _e !== void 0 ? _e : 0;
      this.stickyWidthRight = (_f = lastColumnsWidths[props.stickyColumnsLast - 1]) !== null && _f !== void 0 ? _f : 0;
      this.cellOffsets = props.visibleColumns.reduce((map, columnId, columnIndex) => {
        var _a2, _b2;
        return map.set(columnId, {
          first: (_a2 = firstColumnsWidths[columnIndex - 1]) !== null && _a2 !== void 0 ? _a2 : 0,
          last: (_b2 = lastColumnsWidths[props.visibleColumns.length - 1 - columnIndex - 1]) !== null && _b2 !== void 0 ? _b2 : 0
        });
      }, /* @__PURE__ */ new Map());
    };
    this.isEnabled = (props) => {
      const noStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast === 0;
      if (noStickyColumns) {
        return false;
      }
      const wrapperWidth = props.wrapper.getBoundingClientRect().width;
      const tableWidth = props.table.getBoundingClientRect().width;
      const isWrapperScrollable = tableWidth > wrapperWidth;
      if (!isWrapperScrollable) {
        return false;
      }
      const totalStickySpace = this.stickyWidthLeft + this.stickyWidthRight;
      const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
      const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
      const hasEnoughScrollableSpace = totalStickySpace + MINIMUM_SCROLLABLE_SPACE + tablePaddingLeft + tablePaddingRight < wrapperWidth;
      if (!hasEnoughScrollableSpace) {
        return false;
      }
      return true;
    };
  }
  updateCellStyles(props) {
    const hasStickyColumns = props.stickyColumnsFirst + props.stickyColumnsLast > 0;
    const hadStickyColumns = this.cellOffsets.size > 0;
    if (hasStickyColumns || hadStickyColumns) {
      this.updateScroll(props);
      this.updateCellOffsets(props);
      this.set(() => ({
        cellState: this.generateCellStyles(props),
        wrapperState: { scrollPaddingLeft: this.stickyWidthLeft, scrollPaddingRight: this.stickyWidthRight }
      }));
    }
  }
  updateScroll(props) {
    const wrapperScrollLeft = props.wrapper.scrollLeft;
    const wrapperScrollWidth = props.wrapper.scrollWidth;
    const wrapperClientWidth = props.wrapper.clientWidth;
    const tablePaddingLeft = parseFloat(getComputedStyle(props.table).paddingLeft) || 0;
    const tablePaddingRight = parseFloat(getComputedStyle(props.table).paddingRight) || 0;
    this.isStuckToTheLeft = wrapperScrollLeft > tablePaddingLeft;
    this.isStuckToTheRight = Math.ceil(wrapperScrollLeft) < wrapperScrollWidth - wrapperClientWidth - tablePaddingRight;
    this.padLeft = tablePaddingLeft !== 0 && this.isStuckToTheLeft;
  }
};

// node_modules/@cloudscape-design/components/table/header-cell/index.js
function TableHeaderCell({ className, style, tabIndex, column, activeSortingColumn, sortingDescending, sortingDisabled, wrapLines, focusedComponent, onFocusedComponentChange, hidden, onClick, colIndex, updateColumn, resizableColumns, onResizeFinish, isEditable, columnId, stickyState, cellRef }) {
  var _a;
  const i18n = useInternalI18n("table");
  const sortable = !!column.sortingComparator || !!column.sortingField;
  const sorted = !!activeSortingColumn && isSorted(column, activeSortingColumn);
  const sortingStatus = getSortingStatus(sortable, sorted, !!sortingDescending, !!sortingDisabled);
  const handleClick = () => onClick({
    sortingColumn: column,
    isDescending: sorted ? !sortingDescending : false
  });
  const handleKeyPress = ({ nativeEvent: e }) => {
    if (e.keyCode === KeyCode.enter || e.keyCode === KeyCode.space) {
      e.preventDefault();
      handleClick();
    }
  };
  const headerId = useUniqueId("table-header-");
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default3, props)
  });
  const mergedRef = useMergeRefs(stickyStyles.ref, cellRef);
  return import_react8.default.createElement(
    "th",
    { className: clsx_m_default(className, {
      [styles_css_default3["header-cell-resizable"]]: !!resizableColumns,
      [styles_css_default3["header-cell-sortable"]]: sortingStatus,
      [styles_css_default3["header-cell-sorted"]]: sortingStatus === "ascending" || sortingStatus === "descending",
      [styles_css_default3["header-cell-disabled"]]: sortingDisabled,
      [styles_css_default3["header-cell-ascending"]]: sortingStatus === "ascending",
      [styles_css_default3["header-cell-descending"]]: sortingStatus === "descending",
      [styles_css_default3["header-cell-hidden"]]: hidden
    }, stickyStyles.className), "aria-sort": sortingStatus && getAriaSort(sortingStatus), style: Object.assign(Object.assign({}, style), stickyStyles.style), scope: "col", ref: mergedRef },
    import_react8.default.createElement(
      "div",
      Object.assign({ className: clsx_m_default(styles_css_default3["header-cell-content"], {
        [styles_css_default3["header-cell-fake-focus"]]: (focusedComponent === null || focusedComponent === void 0 ? void 0 : focusedComponent.type) === "column" && focusedComponent.col === colIndex
      }), "aria-label": column.ariaLabel ? column.ariaLabel({
        sorted,
        descending: sorted && !!sortingDescending,
        disabled: !!sortingDisabled
      }) : void 0 }, sortingStatus && !sortingDisabled ? {
        onKeyPress: handleKeyPress,
        tabIndex,
        role: "button",
        onClick: handleClick,
        onFocus: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange({ type: "column", col: colIndex }),
        onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null)
      } : {}),
      import_react8.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default3["header-cell-text"], wrapLines && styles_css_default3["header-cell-text-wrap"]), id: headerId },
        column.header,
        isEditable ? import_react8.default.createElement(
          "span",
          { className: styles_css_default3["edit-icon"], role: "img", "aria-label": i18n("columnDefinitions.editConfig.editIconAriaLabel", (_a = column.editConfig) === null || _a === void 0 ? void 0 : _a.editIconAriaLabel) },
          import_react8.default.createElement(internal_default, { name: "edit" })
        ) : null
      ),
      sortingStatus && import_react8.default.createElement(
        "span",
        { className: styles_css_default3["sorting-icon"] },
        import_react8.default.createElement(internal_default, { name: getSortingIconName(sortingStatus) })
      )
    ),
    resizableColumns && import_react8.default.createElement(
      import_react8.default.Fragment,
      null,
      import_react8.default.createElement(Resizer, { tabIndex, showFocusRing: (focusedComponent === null || focusedComponent === void 0 ? void 0 : focusedComponent.type) === "resizer" && focusedComponent.col === colIndex, onDragMove: (newWidth) => updateColumn(columnId, newWidth), onFinish: onResizeFinish, ariaLabelledby: headerId, onFocus: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange({ type: "resizer", col: colIndex }), onBlur: () => onFocusedComponentChange === null || onFocusedComponentChange === void 0 ? void 0 : onFocusedComponentChange(null), minWidth: typeof column.minWidth === "string" ? parseInt(column.minWidth) : column.minWidth })
    )
  );
}

// node_modules/@cloudscape-design/components/table/thead.js
var Thead = import_react9.default.forwardRef(({ containerWidth, selectionType, getSelectAllProps, columnDefinitions, sortingColumn, sortingDisabled, sortingDescending, resizableColumns, variant, wrapLines, onFocusMove, onSortingChange, onResizeFinish, singleSelectionHeaderAriaLabel, stripedRows, sticky = false, hidden = false, stuck = false, stickyState, selectionColumnId: selectionColumnId2, focusedComponent, onFocusedComponentChange }, outerRef) => {
  const isVisualRefresh = useVisualRefresh();
  const headerCellClass = clsx_m_default(styles_css_default3["header-cell"], styles_css_default3[`header-cell-variant-${variant}`], sticky && styles_css_default3["header-cell-sticky"], stuck && styles_css_default3["header-cell-stuck"], stripedRows && styles_css_default3["has-striped-rows"], isVisualRefresh && styles_css_default3["is-visual-refresh"]);
  const selectionCellClass = clsx_m_default(styles_css_default["selection-control"], styles_css_default["selection-control-header"], isVisualRefresh && styles_css_default["is-visual-refresh"]);
  const { columnWidths, totalWidth, updateColumn, setCell } = useColumnWidths();
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId: selectionColumnId2,
    getClassName: (props) => getStickyClassNames(styles_css_default3, props)
  });
  return import_react9.default.createElement(
    "thead",
    { className: clsx_m_default(!hidden && styles_css_default["thead-active"]) },
    import_react9.default.createElement(
      "tr",
      Object.assign({}, focusMarkers.all, { ref: outerRef, "aria-rowindex": 1 }),
      selectionType ? import_react9.default.createElement("th", { className: clsx_m_default(headerCellClass, selectionCellClass, hidden && styles_css_default3["header-cell-hidden"], stickyStyles.className), style: stickyStyles.style, ref: stickyStyles.ref, scope: "col" }, selectionType === "multi" ? import_react9.default.createElement(SelectionControl, Object.assign({ onFocusDown: (event) => {
        onFocusMove(event.target, -1, 1);
      }, focusedComponent, onFocusedComponentChange }, getSelectAllProps(), sticky ? { tabIndex: -1 } : {})) : import_react9.default.createElement(ScreenreaderOnly, null, singleSelectionHeaderAriaLabel)) : null,
      columnDefinitions.map((column, colIndex) => {
        const columnId = getColumnKey(column, colIndex);
        let widthOverride;
        if (resizableColumns) {
          if (columnWidths) {
            widthOverride = columnWidths[columnId];
          }
          if (colIndex === columnDefinitions.length - 1 && containerWidth && containerWidth > totalWidth) {
            widthOverride = "auto";
          }
        }
        return import_react9.default.createElement(TableHeaderCell, { key: columnId, className: headerCellClass, style: {
          width: widthOverride || column.width,
          minWidth: sticky ? void 0 : column.minWidth,
          maxWidth: resizableColumns || sticky ? void 0 : column.maxWidth
        }, tabIndex: sticky ? -1 : 0, focusedComponent, onFocusedComponentChange, column, activeSortingColumn: sortingColumn, sortingDescending, sortingDisabled, wrapLines, hidden, colIndex, columnId, updateColumn, onResizeFinish: () => onResizeFinish(columnWidths), resizableColumns, onClick: (detail) => fireNonCancelableEvent(onSortingChange, detail), isEditable: !!column.editConfig, stickyState, cellRef: (node) => setCell(columnId, node) });
      })
    )
  );
});
var thead_default = Thead;

// node_modules/@cloudscape-design/components/table/body-cell/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/body-cell/styles.scoped.css";
var styles_css_default5 = {
  "body-cell": "awsui_body-cell_c6tup_djrxv_93",
  "body-cell-wrap": "awsui_body-cell-wrap_c6tup_djrxv_103",
  "is-visual-refresh": "awsui_is-visual-refresh_c6tup_djrxv_115",
  "has-striped-rows": "awsui_has-striped-rows_c6tup_djrxv_127",
  "body-cell-edit-active": "awsui_body-cell-edit-active_c6tup_djrxv_130",
  "body-cell-editable": "awsui_body-cell-editable_c6tup_djrxv_130",
  "has-striped-rows-sticky-cell-pad-left": "awsui_has-striped-rows-sticky-cell-pad-left_c6tup_djrxv_136",
  "has-selection": "awsui_has-selection_c6tup_djrxv_139",
  "body-cell-first-row": "awsui_body-cell-first-row_c6tup_djrxv_145",
  "body-cell-last-row": "awsui_body-cell-last-row_c6tup_djrxv_148",
  "body-cell-selected": "awsui_body-cell-selected_c6tup_djrxv_148",
  "has-footer": "awsui_has-footer_c6tup_djrxv_148",
  "body-cell-shaded": "awsui_body-cell-shaded_c6tup_djrxv_158",
  "sticky-cell": "awsui_sticky-cell_c6tup_djrxv_175",
  "sticky-cell-pad-left": "awsui_sticky-cell-pad-left_c6tup_djrxv_183",
  "sticky-cell-last-right": "awsui_sticky-cell-last-right_c6tup_djrxv_200",
  "sticky-cell-last-left": "awsui_sticky-cell-last-left_c6tup_djrxv_204",
  "body-cell-next-selected": "awsui_body-cell-next-selected_c6tup_djrxv_227",
  "body-cell-prev-selected": "awsui_body-cell-prev-selected_c6tup_djrxv_231",
  "body-cell-success": "awsui_body-cell-success_c6tup_djrxv_255",
  "body-cell-editor": "awsui_body-cell-editor_c6tup_djrxv_255",
  "body-cell-success-form": "awsui_body-cell-success-form_c6tup_djrxv_277",
  "body-cell-editor-form": "awsui_body-cell-editor-form_c6tup_djrxv_277",
  "body-cell-success-row": "awsui_body-cell-success-row_c6tup_djrxv_286",
  "body-cell-editor-row": "awsui_body-cell-editor-row_c6tup_djrxv_286",
  "body-cell-success-controls": "awsui_body-cell-success-controls_c6tup_djrxv_296",
  "body-cell-editor-controls": "awsui_body-cell-editor-controls_c6tup_djrxv_296",
  "body-cell-has-success": "awsui_body-cell-has-success_c6tup_djrxv_315"
};

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var import_react13 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/td-element.js
var import_react10 = __toESM(require_react());
var TableTdElement = import_react10.default.forwardRef(({ className, style, children, wrapLines, isRowHeader, isFirstRow, isLastRow, isSelected, isNextSelected, isPrevSelected, nativeAttributes, onClick, onMouseEnter, onMouseLeave, isEvenRow, stripedRows, isVisualRefresh, hasSelection, hasFooter, columnId, stickyState }, ref) => {
  let Element = "td";
  if (isRowHeader) {
    Element = "th";
    nativeAttributes = Object.assign(Object.assign({}, nativeAttributes), { scope: "row" });
  }
  const stickyStyles = useStickyCellStyles({
    stickyColumns: stickyState,
    columnId,
    getClassName: (props) => getStickyClassNames(styles_css_default5, props)
  });
  return import_react10.default.createElement(Element, Object.assign({ style: Object.assign(Object.assign({}, style), stickyStyles.style), className: clsx_m_default(className, styles_css_default5["body-cell"], wrapLines && styles_css_default5["body-cell-wrap"], isFirstRow && styles_css_default5["body-cell-first-row"], isLastRow && styles_css_default5["body-cell-last-row"], isSelected && styles_css_default5["body-cell-selected"], isNextSelected && styles_css_default5["body-cell-next-selected"], isPrevSelected && styles_css_default5["body-cell-prev-selected"], !isEvenRow && stripedRows && styles_css_default5["body-cell-shaded"], stripedRows && styles_css_default5["has-striped-rows"], isVisualRefresh && styles_css_default5["is-visual-refresh"], hasSelection && styles_css_default5["has-selection"], hasFooter && styles_css_default5["has-footer"], stickyStyles.className), onClick, onMouseEnter, onMouseLeave, ref: (node) => {
    if (node) {
      stickyStyles.ref(node);
      if (ref) {
        ref.current = node;
      }
    }
  } }, nativeAttributes), children);
});

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var import_react12 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/body-cell/click-away.js
var import_react11 = __toESM(require_react());
function useClickAway(onClick) {
  const awayRef = (0, import_react11.useRef)(null);
  const onClickStable = useStableEventHandler(onClick);
  (0, import_react11.useEffect)(() => {
    function handleClick(event) {
      if (!nodeBelongs(awayRef.current, event.target)) {
        onClickStable();
      }
    }
    document.addEventListener("click", handleClick, { capture: true });
    return () => document.removeEventListener("click", handleClick, { capture: true });
  }, [onClickStable]);
  return awayRef;
}

// node_modules/@cloudscape-design/components/table/body-cell/inline-editor.js
var noop = () => void 0;
function InlineEditor({ ariaLabels, item, column, onEditEnd, submitEdit, __onRender }) {
  var _a, _b, _c, _d;
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react12.useState)(false);
  const [currentEditValue, setCurrentEditValue] = (0, import_react12.useState)();
  const i18n = useInternalI18n("table");
  const focusLockRef = (0, import_react12.useRef)(null);
  const cellContext = {
    currentValue: currentEditValue,
    setValue: setCurrentEditValue
  };
  function finishEdit(cancel = false) {
    if (!cancel) {
      setCurrentEditValue(void 0);
    }
    onEditEnd(cancel);
  }
  function onSubmitClick(evt) {
    var _a2;
    return __awaiter(this, void 0, void 0, function* () {
      evt.preventDefault();
      if (currentEditValue === void 0) {
        finishEdit();
        return;
      }
      setCurrentEditLoading(true);
      try {
        yield submitEdit(item, column, currentEditValue);
        setCurrentEditLoading(false);
        finishEdit();
      } catch (e) {
        setCurrentEditLoading(false);
        (_a2 = focusLockRef.current) === null || _a2 === void 0 ? void 0 : _a2.focusFirst();
      }
    });
  }
  function onCancel() {
    if (currentEditLoading) {
      return;
    }
    finishEdit(true);
  }
  function handleEscape(event) {
    if (event.key === "Escape") {
      onCancel();
    }
  }
  const clickAwayRef = useClickAway(onCancel);
  (0, import_react12.useEffect)(() => {
    if (__onRender) {
      const timer = setTimeout(__onRender, 1);
      return () => clearTimeout(timer);
    }
  }, [__onRender]);
  const { ariaLabel = void 0, validation = noop, errorIconAriaLabel, constraintText, editingCell } = column.editConfig;
  return import_react12.default.createElement(
    focus_lock_default,
    { restoreFocus: true, ref: focusLockRef },
    import_react12.default.createElement(
      "div",
      { role: "dialog", ref: clickAwayRef, "aria-label": (_a = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _a === void 0 ? void 0 : _a.call(ariaLabels, column, item), onKeyDown: handleEscape },
      import_react12.default.createElement(
        "form",
        { onSubmit: onSubmitClick, className: styles_css_default5["body-cell-editor-form"] },
        import_react12.default.createElement(
          InternalFormField,
          { stretch: true, label: ariaLabel, constraintText, __hideLabel: true, __disableGutters: true, i18nStrings: { errorIconAriaLabel }, errorText: validation(item, currentEditValue) },
          import_react12.default.createElement(
            "div",
            { className: styles_css_default5["body-cell-editor-row"] },
            editingCell(item, cellContext),
            import_react12.default.createElement(
              "span",
              { className: styles_css_default5["body-cell-editor-controls"] },
              import_react12.default.createElement(
                InternalSpaceBetween,
                { direction: "horizontal", size: "xxs" },
                !currentEditLoading ? import_react12.default.createElement(internal_default2, { ariaLabel: (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.cancelEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), formAction: "none", iconName: "close", variant: "inline-icon", onClick: onCancel }) : null,
                import_react12.default.createElement(internal_default2, { ariaLabel: (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submitEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column), formAction: "submit", iconName: "check", variant: "inline-icon", loading: currentEditLoading })
              ),
              import_react12.default.createElement(live_region_default, null, currentEditLoading ? i18n("ariaLabels.submittingEditText", (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.submittingEditText) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column)) : "")
            )
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/table/body-cell/index.js
var submitHandlerFallback = () => {
  throw new Error("The function `handleSubmit` is required for editable columns");
};
function TableCellEditable(_a) {
  var _b, _c, _d;
  var { className, item, column, isEditing, onEditStart, onEditEnd, submitEdit, ariaLabels, isVisualRefresh, successfulEdit = false } = _a, rest = __rest(_a, ["className", "item", "column", "isEditing", "onEditStart", "onEditEnd", "submitEdit", "ariaLabels", "isVisualRefresh", "successfulEdit"]);
  const i18n = useInternalI18n("table");
  const editActivateRef = (0, import_react13.useRef)(null);
  const tdNativeAttributes = {
    "data-inline-editing-active": isEditing.toString()
  };
  const isFocusMoveNeededRef = (0, import_react13.useRef)(false);
  (0, import_react13.useEffect)(() => {
    if (!isEditing && editActivateRef.current && isFocusMoveNeededRef.current) {
      isFocusMoveNeededRef.current = false;
      editActivateRef.current.focus();
    }
  }, [isEditing]);
  const [hasHover, setHasHover] = (0, import_react13.useState)(false);
  const [hasFocus, setHasFocus] = (0, import_react13.useState)(false);
  const showIcon = hasHover || hasFocus;
  return import_react13.default.createElement(TableTdElement, Object.assign({}, rest, { nativeAttributes: tdNativeAttributes, className: clsx_m_default(className, styles_css_default5["body-cell-editable"], isEditing && styles_css_default5["body-cell-edit-active"], successfulEdit && styles_css_default5["body-cell-has-success"], isVisualRefresh && styles_css_default5["is-visual-refresh"]), onClick: !isEditing ? onEditStart : void 0, onMouseEnter: () => setHasHover(true), onMouseLeave: () => setHasHover(false) }), isEditing ? import_react13.default.createElement(InlineEditor, { ariaLabels, column, item, onEditEnd: (e) => {
    isFocusMoveNeededRef.current = true;
    onEditEnd(e);
  }, submitEdit: submitEdit !== null && submitEdit !== void 0 ? submitEdit : submitHandlerFallback }) : import_react13.default.createElement(
    import_react13.default.Fragment,
    null,
    column.cell(item),
    successfulEdit && import_react13.default.createElement(
      import_react13.default.Fragment,
      null,
      import_react13.default.createElement(
        "span",
        { className: styles_css_default5["body-cell-success"], "aria-label": (_b = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _b === void 0 ? void 0 : _b.call(ariaLabels, column), role: "img" },
        import_react13.default.createElement(internal_default, { name: "status-positive", variant: "success" })
      ),
      import_react13.default.createElement(live_region_default, null, i18n("ariaLabels.successfulEditLabel", (_c = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.successfulEditLabel) === null || _c === void 0 ? void 0 : _c.call(ariaLabels, column)))
    ),
    import_react13.default.createElement("button", { className: styles_css_default5["body-cell-editor"], "aria-label": (_d = ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.activateEditLabel) === null || _d === void 0 ? void 0 : _d.call(ariaLabels, column, item), ref: editActivateRef, onFocus: () => setHasFocus(true), onBlur: () => setHasFocus(false) }, showIcon && import_react13.default.createElement(internal_default, { name: "edit" }))
  ));
}
function TableBodyCell(_a) {
  var { isEditable } = _a, rest = __rest(_a, ["isEditable"]);
  if (isEditable || rest.isEditing) {
    return import_react13.default.createElement(TableCellEditable, Object.assign({}, rest));
  }
  const { column, item } = rest;
  return import_react13.default.createElement(TableTdElement, Object.assign({}, rest), column.cell(item));
}

// node_modules/@cloudscape-design/components/table/use-row-events.js
function useRowEvents({ onRowClick, onRowContextMenu }) {
  const onRowClickHandler = (rowIndex, item, event) => {
    const tableCell = findUpUntil(event.target, (element) => element.tagName.toLowerCase() === "td");
    if (!tableCell || !tableCell.classList.contains(styles_css_default["selection-control"])) {
      const details = { rowIndex, item };
      fireNonCancelableEvent(onRowClick, details);
    }
  };
  const onRowContextMenuHandler = (rowIndex, item, event) => {
    const details = {
      rowIndex,
      item,
      clientX: event.clientX,
      clientY: event.clientY
    };
    fireCancelableEvent(onRowContextMenu, details, event);
  };
  return {
    onRowClickHandler: onRowClick && onRowClickHandler,
    onRowContextMenuHandler: onRowContextMenu && onRowContextMenuHandler
  };
}

// node_modules/@cloudscape-design/components/internal/hooks/use-scroll-sync/index.js
var import_react14 = __toESM(require_react());
function useScrollSync(refs, disabled = !supportsStickyPosition()) {
  const activeElement = (0, import_react14.useRef)(null);
  const onScroll = (event) => {
    const targetElement = event.target;
    if (targetElement && (activeElement.current === null || activeElement.current === targetElement)) {
      requestAnimationFrame(() => {
        activeElement.current = targetElement;
        refs.forEach((ref) => {
          const element = ref.current;
          if (element && element !== targetElement) {
            element.scrollLeft = targetElement.scrollLeft;
          }
        });
        requestAnimationFrame(() => {
          activeElement.current = null;
        });
      });
    }
  };
  return !disabled ? onScroll : void 0;
}

// node_modules/@cloudscape-design/components/table/sticky-header.js
var import_react16 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
var import_react15 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrolling.js
function stickyScrolling(containerRef, stickyRef) {
  const scrollToTop = () => {
    if (!containerRef.current || !stickyRef.current) {
      return;
    }
    const scrollingOffset = calculateScrollingOffset(containerRef.current, stickyRef.current);
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  const scrollToItem = (item) => {
    if (!item || !containerRef.current || !stickyRef.current) {
      return;
    }
    const stickyBottom = stickyRef.current.getBoundingClientRect().bottom;
    const scrollingOffset = stickyBottom - item.getBoundingClientRect().top;
    if (scrollingOffset > 0) {
      scrollUpBy(scrollingOffset, containerRef.current);
    }
  };
  return {
    scrollToTop,
    scrollToItem
  };
}
function calculateScrollingOffset(container, sticky) {
  const stickyRect = sticky.getBoundingClientRect();
  const containerRect = container.getBoundingClientRect();
  return stickyRect.top - containerRect.top;
}
function scrollUpBy(amount, container) {
  const parent = getOverflowParents(container);
  if (parent.length) {
    parent[0].scrollTop -= amount;
  } else {
    window.scrollTo({ top: window.pageYOffset - amount });
  }
}

// node_modules/@cloudscape-design/components/table/use-sticky-header.js
function syncSizes(from, to) {
  const fromCells = Array.prototype.slice.apply(from.children);
  const toCells = Array.prototype.slice.apply(to.children);
  for (let i = 0; i < fromCells.length; i++) {
    let width = fromCells[i].style.width;
    if (width !== "auto") {
      width = `${fromCells[i].offsetWidth}px`;
    }
    toCells[i].style.width = width;
  }
}
var useStickyHeader = (tableRef, theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef) => {
  const isMobile = useMobile();
  const syncColumnHeaderWidths = (0, import_react15.useCallback)(() => {
    if (tableRef.current && theadRef.current && secondaryTheadRef.current && secondaryTableRef.current && tableWrapperRef.current) {
      syncSizes(theadRef.current, secondaryTheadRef.current);
      secondaryTableRef.current.style.width = `${tableRef.current.offsetWidth}px`;
      tableWrapperRef.current.style.marginTop = `-${theadRef.current.offsetHeight}px`;
    }
  }, [theadRef, secondaryTheadRef, secondaryTableRef, tableWrapperRef, tableRef]);
  (0, import_react15.useLayoutEffect)(() => {
    syncColumnHeaderWidths();
  });
  useResizeObserver(theadRef, syncColumnHeaderWidths);
  const scrollToTop = () => {
    if (!isMobile && theadRef.current && secondaryTheadRef.current && tableWrapperRef.current) {
      const scrollDist = calculateScrollingOffset(theadRef.current, secondaryTheadRef.current);
      if (scrollDist > 0) {
        scrollUpBy(scrollDist, tableWrapperRef.current);
      }
    }
  };
  const { scrollToItem } = stickyScrolling(tableWrapperRef, secondaryTheadRef);
  const scrollToRow = (itemNode) => {
    if (!isMobile) {
      scrollToItem(itemNode);
    }
  };
  return { scrollToRow, scrollToTop };
};

// node_modules/@cloudscape-design/components/table/sticky-header.js
var sticky_header_default = (0, import_react16.forwardRef)(StickyHeader);
function StickyHeader({ variant, theadProps, wrapperRef, theadRef, secondaryWrapperRef, onScroll, tableRef, tableHasHeader, contentDensity }, ref) {
  const secondaryTheadRef = (0, import_react16.useRef)(null);
  const secondaryTableRef = (0, import_react16.useRef)(null);
  const { isStuck } = (0, import_react16.useContext)(StickyHeaderContext);
  const [focusedComponent, setFocusedComponent] = (0, import_react16.useState)(null);
  const { scrollToRow, scrollToTop } = useStickyHeader(tableRef, theadRef, secondaryTheadRef, secondaryTableRef, wrapperRef);
  (0, import_react16.useImperativeHandle)(ref, () => ({
    scrollToTop,
    scrollToRow,
    setFocus: setFocusedComponent
  }));
  return import_react16.default.createElement(
    "div",
    {
      className: clsx_m_default(styles_css_default["header-secondary"], styles_css_default[`variant-${variant}`], {
        [styles_css_default.stuck]: isStuck,
        [styles_css_default["table-has-header"]]: tableHasHeader
      }),
      "aria-hidden": true,
      tabIndex: -1,
      ref: secondaryWrapperRef,
      onScroll
    },
    import_react16.default.createElement(
      "table",
      { className: clsx_m_default(styles_css_default.table, styles_css_default["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")), role: "table", ref: secondaryTableRef },
      import_react16.default.createElement(thead_default, Object.assign({ ref: secondaryTheadRef, sticky: true, stuck: isStuck, focusedComponent }, theadProps))
    )
  );
}

// node_modules/@cloudscape-design/components/internal/hooks/use-mouse-down-target.js
var import_react17 = __toESM(require_react());
var useEventListenersSingleton = createSingletonHandler((setTarget) => {
  function handleMouseDown(event) {
    setTarget(event.target);
  }
  function handleKeyDown() {
    setTarget(null);
  }
  window.addEventListener("mousedown", handleMouseDown);
  window.addEventListener("keydown", handleKeyDown);
  return () => {
    window.removeEventListener("mousedown", handleMouseDown);
    window.removeEventListener("keydown", handleKeyDown);
  };
});
function useMouseDownTarget() {
  const mouseDownTargetRef = (0, import_react17.useRef)(null);
  useEventListenersSingleton((target) => {
    mouseDownTargetRef.current = target;
  });
  return () => mouseDownTargetRef.current;
}

// node_modules/@cloudscape-design/components/table/use-table-focus-navigation.js
var import_react18 = __toESM(require_react());
function iterateTableCells(table, func) {
  table.querySelectorAll("tr").forEach((row, rowIndex) => {
    row.querySelectorAll("td").forEach((cell, cellIndex) => {
      func(cell, rowIndex, cellIndex);
    });
  });
}
function useTableFocusNavigation(selectionType, tableRoot, columnDefinitions, numRows) {
  const focusableColumns = (0, import_react18.useMemo)(() => {
    const cols = columnDefinitions.map((column) => !!column.editConfig);
    if (selectionType) {
      cols.unshift(false);
    }
    return cols;
  }, [columnDefinitions, selectionType]);
  const maxColumnIndex = focusableColumns.length - 1;
  const minColumnIndex = selectionType ? 1 : 0;
  const focusCell = (0, import_react18.useCallback)((rowIndex, columnIndex) => {
    if (tableRoot === null || tableRoot === void 0 ? void 0 : tableRoot.current) {
      iterateTableCells(tableRoot.current, (cell, rIndex, cIndex) => {
        var _a;
        if (rIndex === rowIndex && cIndex === columnIndex) {
          const editButton = cell.querySelector("button:last-child");
          if (editButton) {
            (_a = editButton.focus) === null || _a === void 0 ? void 0 : _a.call(editButton);
            scrollElementIntoView(editButton);
          }
        }
      });
    }
  }, [tableRoot]);
  const shiftFocus = (0, import_react18.useCallback)((vertical, horizontal) => {
    var _a;
    const focusedCell = (_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector("td:focus-within");
    if (!focusedCell) {
      return;
    }
    const columnIndex = focusedCell.cellIndex;
    const rowIndex = focusedCell.parentElement.rowIndex;
    let newRowIndex = rowIndex;
    let newColumnIndex = columnIndex;
    if (vertical !== 0) {
      newRowIndex = Math.min(numRows, Math.max(rowIndex + vertical, 0));
    }
    if (horizontal !== 0) {
      while (newColumnIndex <= maxColumnIndex && newColumnIndex >= minColumnIndex) {
        newColumnIndex += horizontal;
        if (focusableColumns[newColumnIndex]) {
          break;
        }
      }
    }
    if ((rowIndex !== newRowIndex || columnIndex !== newColumnIndex) && tableRoot.current) {
      focusCell(newRowIndex, newColumnIndex);
    }
  }, [focusCell, focusableColumns, maxColumnIndex, minColumnIndex, numRows, tableRoot]);
  const handleArrowKeyEvents = (0, import_react18.useCallback)((event) => {
    var _a, _b;
    const abort = !!((_a = tableRoot.current) === null || _a === void 0 ? void 0 : _a.querySelector('[data-inline-editing-active = "true"]')) || !((_b = document.activeElement) === null || _b === void 0 ? void 0 : _b.closest("[data-inline-editing-active]"));
    if (abort) {
      return;
    }
    switch (event.key) {
      case "ArrowUp":
        event.preventDefault();
        shiftFocus(-1, 0);
        break;
      case "ArrowDown":
        event.preventDefault();
        shiftFocus(1, 0);
        break;
      case "ArrowLeft":
        event.preventDefault();
        shiftFocus(0, -1);
        break;
      case "ArrowRight":
        event.preventDefault();
        shiftFocus(0, 1);
        break;
      default:
        return;
    }
  }, [shiftFocus, tableRoot]);
  (0, import_react18.useEffect)(() => {
    if (!tableRoot.current) {
      return;
    }
    const tableElement = tableRoot.current;
    tableRoot.current.addEventListener("keydown", handleArrowKeyEvents);
    return () => tableElement && tableElement.removeEventListener("keydown", handleArrowKeyEvents);
  }, [focusableColumns, handleArrowKeyEvents, tableRoot]);
}
var use_table_focus_navigation_default = useTableFocusNavigation;

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var import_react20 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var import_react19 = __toESM(require_react());

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/table/sticky-scrollbar/styles.scoped.css";
var styles_css_default6 = {
  "sticky-scrollbar": "awsui_sticky-scrollbar_faqt8_1us5r_5",
  "sticky-scrollbar-content": "awsui_sticky-scrollbar-content_faqt8_1us5r_15",
  "sticky-scrollbar-visible": "awsui_sticky-scrollbar-visible_faqt8_1us5r_18",
  "sticky-scrollbar-native-invisible": "awsui_sticky-scrollbar-native-invisible_faqt8_1us5r_21"
};

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/use-sticky-scrollbar.js
var updatePosition = (tableEl, wrapperEl, scrollbarEl, scrollbarContentEl, hasContainingBlock, consideredFooterHeight) => {
  if (!tableEl || !scrollbarEl || !wrapperEl) {
    return;
  }
  const { width: tableWidth } = tableEl.getBoundingClientRect();
  const { width: wrapperWidth } = wrapperEl.getBoundingClientRect();
  const scrollbarHeight = browserScrollbarSize().height;
  const areaIsScrollable = tableWidth > wrapperWidth;
  if (!areaIsScrollable) {
    scrollbarEl.classList.remove(styles_css_default6["sticky-scrollbar-visible"]);
  } else {
    if (!scrollbarEl.classList.contains(styles_css_default6["sticky-scrollbar-visible"])) {
      requestAnimationFrame(() => {
        scrollbarEl.scrollLeft = wrapperEl.scrollLeft;
      });
    }
    scrollbarEl.classList.add(styles_css_default6["sticky-scrollbar-visible"]);
    if (!scrollbarHeight) {
      scrollbarEl.classList.add(styles_css_default6["sticky-scrollbar-native-invisible"]);
    }
  }
  if (scrollbarHeight && scrollbarEl && scrollbarContentEl) {
    scrollbarEl.style.height = `${scrollbarHeight}px`;
    scrollbarContentEl.style.height = `${scrollbarHeight}px`;
  }
  if (tableEl && wrapperEl && scrollbarContentEl && scrollbarEl) {
    const wrapperElRect = wrapperEl.getBoundingClientRect();
    const tableElRect = tableEl.getBoundingClientRect();
    scrollbarEl.style.width = `${wrapperElRect.width}px`;
    scrollbarContentEl.style.width = `${tableElRect.width}px`;
    scrollbarEl.style.bottom = hasContainingBlock ? "0px" : `${consideredFooterHeight}px`;
  }
};
function useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, footerHeight) {
  const [hasContainingBlock, setHasContainingBlock] = (0, import_react19.useState)(false);
  const [hasOverflowParent, setHasOverflowParent] = (0, import_react19.useState)(false);
  const consideredFooterHeight = hasContainingBlock || hasOverflowParent ? 0 : footerHeight;
  const wrapperEl = wrapperRef.current;
  (0, import_react19.useEffect)(() => {
    if (wrapperEl && supportsStickyPosition()) {
      setHasContainingBlock(!!getContainingBlock(wrapperEl));
      setHasOverflowParent(!!getOverflowParents(wrapperEl)[0]);
    }
  }, [wrapperEl]);
  (0, import_react19.useEffect)(() => {
    if (supportsStickyPosition() && wrapperRef.current && tableRef.current) {
      const observer = new ResizeObserver(() => {
        if (scrollbarContentRef.current) {
          updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
        }
      });
      observer.observe(wrapperRef.current);
      observer.observe(tableRef.current);
      return () => {
        observer.disconnect();
      };
    }
  }, [scrollbarContentRef, scrollbarRef, tableRef, wrapperRef, consideredFooterHeight, hasContainingBlock]);
  (0, import_react19.useEffect)(() => {
    if (supportsStickyPosition()) {
      const resizeHandler = () => {
        updatePosition(tableRef.current, wrapperRef.current, scrollbarRef.current, scrollbarContentRef.current, hasContainingBlock, consideredFooterHeight);
      };
      resizeHandler();
      window.addEventListener("resize", resizeHandler);
      return () => {
        window.removeEventListener("resize", resizeHandler);
      };
    }
  }, [tableRef, wrapperRef, scrollbarRef, scrollbarContentRef, hasContainingBlock, consideredFooterHeight]);
}

// node_modules/@cloudscape-design/components/table/sticky-scrollbar/sticky-scrollbar.js
var sticky_scrollbar_default = (0, import_react20.forwardRef)(StickyScrollbar);
function StickyScrollbar({ wrapperRef, tableRef, onScroll }, ref) {
  const scrollbarRef = import_react20.default.useRef(null);
  const scrollbarContentRef = import_react20.default.useRef(null);
  const mergedRef = useMergeRefs(ref, scrollbarRef);
  const { stickyOffsetBottom } = useAppLayoutContext();
  useStickyScrollbar(scrollbarRef, scrollbarContentRef, tableRef, wrapperRef, stickyOffsetBottom);
  return import_react20.default.createElement(
    "div",
    { ref: mergedRef, className: styles_css_default6["sticky-scrollbar"], onScroll },
    import_react20.default.createElement("div", { ref: scrollbarContentRef, className: styles_css_default6["sticky-scrollbar-content"] })
  );
}

// node_modules/@cloudscape-design/components/table/column-widths-utils.js
function checkColumnWidths(columnDefinitions) {
  for (const column of columnDefinitions) {
    checkProperty(column, "minWidth");
    checkProperty(column, "width");
  }
}
function checkProperty(column, name) {
  const value = column[name];
  if (typeof value !== "number" && typeof value !== "undefined") {
    warnOnce("Table", `resizableColumns feature requires ${name} property to be a number, got ${value}. The component may work incorrectly.`);
  }
}

// node_modules/@cloudscape-design/components/table/internal.js
var SELECTION_COLUMN_WIDTH = 54;
var selectionColumnId = Symbol("selection-column-id");
var InternalTable = import_react21.default.forwardRef((_a, ref) => {
  var _b, _c, _d;
  var { header, footer, empty, filter, pagination, preferences, items, columnDefinitions, trackBy, loading, loadingText, selectionType, selectedItems, isItemDisabled, ariaLabels, onSelectionChange, onSortingChange, sortingColumn, sortingDescending, sortingDisabled, visibleColumns, stickyHeader, stickyHeaderVerticalOffset, onRowClick, onRowContextMenu, wrapLines, stripedRows, contentDensity, submitEdit, onEditCancel, resizableColumns, onColumnWidthsChange, variant, __internalRootRef, totalItemsCount, firstIndex, renderAriaLive, stickyColumns, columnDisplay } = _a, rest = __rest(_a, ["header", "footer", "empty", "filter", "pagination", "preferences", "items", "columnDefinitions", "trackBy", "loading", "loadingText", "selectionType", "selectedItems", "isItemDisabled", "ariaLabels", "onSelectionChange", "onSortingChange", "sortingColumn", "sortingDescending", "sortingDisabled", "visibleColumns", "stickyHeader", "stickyHeaderVerticalOffset", "onRowClick", "onRowContextMenu", "wrapLines", "stripedRows", "contentDensity", "submitEdit", "onEditCancel", "resizableColumns", "onColumnWidthsChange", "variant", "__internalRootRef", "totalItemsCount", "firstIndex", "renderAriaLive", "stickyColumns", "columnDisplay"]);
  const baseProps = getBaseProps(rest);
  stickyHeader = stickyHeader && supportsStickyPosition();
  const [containerWidth, wrapperMeasureRef] = useContainerQuery(({ width }) => width);
  const wrapperRefObject = (0, import_react21.useRef)(null);
  const [tableWidth, tableMeasureRef] = useContainerQuery(({ width }) => width);
  const tableRefObject = (0, import_react21.useRef)(null);
  const secondaryWrapperRef = import_react21.default.useRef(null);
  const theadRef = (0, import_react21.useRef)(null);
  const stickyHeaderRef = import_react21.default.useRef(null);
  const scrollbarRef = import_react21.default.useRef(null);
  const [currentEditCell, setCurrentEditCell] = (0, import_react21.useState)(null);
  const [lastSuccessfulEditCell, setLastSuccessfulEditCell] = (0, import_react21.useState)(null);
  const [currentEditLoading, setCurrentEditLoading] = (0, import_react21.useState)(false);
  (0, import_react21.useImperativeHandle)(ref, () => {
    var _a2;
    return {
      scrollToTop: ((_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToTop) || (() => void 0),
      cancelEdit: () => setCurrentEditCell(null)
    };
  }, []);
  const handleScroll = useScrollSync([wrapperRefObject, scrollbarRef, secondaryWrapperRef]);
  const { moveFocusDown, moveFocusUp, moveFocus } = useFocusMove(selectionType, items.length);
  const { onRowClickHandler, onRowContextMenuHandler } = useRowEvents({ onRowClick, onRowContextMenu });
  const visibleColumnDefinitions = getVisibleColumnDefinitions({
    columnDefinitions,
    columnDisplay,
    visibleColumns
  });
  const { isItemSelected, getSelectAllProps, getItemSelectionProps, updateShiftToggle } = useSelection({
    items,
    trackBy,
    selectedItems,
    selectionType,
    isItemDisabled,
    onSelectionChange,
    ariaLabels,
    loading
  });
  if (isDevelopment) {
    if (resizableColumns) {
      checkColumnWidths(columnDefinitions);
    }
    if (sortingColumn === null || sortingColumn === void 0 ? void 0 : sortingColumn.sortingComparator) {
      checkSortingState(columnDefinitions, sortingColumn.sortingComparator);
    }
  }
  const isVisualRefresh = useVisualRefresh();
  const computedVariant = isVisualRefresh ? variant : ["embedded", "full-page"].indexOf(variant) > -1 ? "container" : variant;
  const hasHeader = !!(header || filter || pagination || preferences);
  const hasSelection = !!selectionType;
  const hasFooterPagination = variant === "full-page" && !!pagination;
  const hasFooter = !!footer || hasFooterPagination;
  const visibleColumnWidthsWithSelection = [];
  const visibleColumnIdsWithSelection = [];
  if (hasSelection) {
    visibleColumnWidthsWithSelection.push({ id: selectionColumnId, width: SELECTION_COLUMN_WIDTH });
    visibleColumnIdsWithSelection.push(selectionColumnId);
  }
  for (let columnIndex = 0; columnIndex < visibleColumnDefinitions.length; columnIndex++) {
    const columnId = getColumnKey(visibleColumnDefinitions[columnIndex], columnIndex);
    visibleColumnWidthsWithSelection.push(Object.assign(Object.assign({}, visibleColumnDefinitions[columnIndex]), { id: columnId }));
    visibleColumnIdsWithSelection.push(columnId);
  }
  const stickyState = useStickyColumns({
    visibleColumns: visibleColumnIdsWithSelection,
    stickyColumnsFirst: ((_b = stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) !== null && _b !== void 0 ? _b : 0) + ((stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.first) && hasSelection ? 1 : 0),
    stickyColumnsLast: (stickyColumns === null || stickyColumns === void 0 ? void 0 : stickyColumns.last) || 0
  });
  const theadProps = {
    containerWidth,
    selectionType,
    getSelectAllProps,
    columnDefinitions: visibleColumnDefinitions,
    variant: computedVariant,
    wrapLines,
    resizableColumns,
    sortingColumn,
    sortingDisabled,
    sortingDescending,
    onSortingChange,
    onFocusMove: moveFocus,
    onResizeFinish(newWidth) {
      const widthsDetail = columnDefinitions.map((column, index) => newWidth[getColumnKey(column, index)] || column.width || DEFAULT_COLUMN_WIDTH);
      const widthsChanged = widthsDetail.some((width, index) => columnDefinitions[index].width !== width);
      if (widthsChanged) {
        fireNonCancelableEvent(onColumnWidthsChange, { widths: widthsDetail });
      }
    },
    singleSelectionHeaderAriaLabel: ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.selectionGroupLabel,
    stripedRows,
    stickyState,
    selectionColumnId
  };
  const wrapperRef = useMergeRefs(wrapperMeasureRef, wrapperRefObject, stickyState.refs.wrapper);
  const tableRef = useMergeRefs(tableMeasureRef, tableRefObject, stickyState.refs.table);
  const isWrapperScrollable = tableWidth && containerWidth && tableWidth > containerWidth;
  const wrapperProps = isWrapperScrollable ? { role: "region", tabIndex: 0, "aria-label": ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel } : {};
  const getMouseDownTarget = useMouseDownTarget();
  const wrapWithInlineLoadingState = (submitEdit2) => {
    if (!submitEdit2) {
      return void 0;
    }
    return (...args) => __awaiter(void 0, void 0, void 0, function* () {
      setCurrentEditLoading(true);
      try {
        yield submitEdit2(...args);
      } finally {
        setCurrentEditLoading(false);
      }
    });
  };
  const hasDynamicHeight = computedVariant === "full-page";
  const overlapElement = useDynamicOverlap({ disabled: !hasDynamicHeight });
  use_table_focus_navigation_default(selectionType, tableRefObject, visibleColumnDefinitions, items === null || items === void 0 ? void 0 : items.length);
  const toolsHeaderWrapper = (0, import_react21.useRef)(null);
  const toolsHeaderHeight = (_d = (_c = toolsHeaderWrapper === null || toolsHeaderWrapper === void 0 ? void 0 : toolsHeaderWrapper.current) === null || _c === void 0 ? void 0 : _c.getBoundingClientRect().height) !== null && _d !== void 0 ? _d : 0;
  return import_react21.default.createElement(
    ColumnWidthsProvider,
    { visibleColumns: visibleColumnWidthsWithSelection, resizableColumns },
    import_react21.default.createElement(
      InternalContainer,
      Object.assign({}, baseProps, { __internalRootRef, className: clsx_m_default(baseProps.className, styles_css_default.root), header: import_react21.default.createElement(
        import_react21.default.Fragment,
        null,
        hasHeader && import_react21.default.createElement(
          "div",
          { ref: overlapElement, className: clsx_m_default(hasDynamicHeight && [styles_css_default["dark-header"], "awsui-context-content-header"]) },
          import_react21.default.createElement(
            "div",
            { ref: toolsHeaderWrapper, className: clsx_m_default(styles_css_default["header-controls"], styles_css_default[`variant-${computedVariant}`]) },
            import_react21.default.createElement(ToolsHeader, { header, filter, pagination, preferences })
          )
        ),
        stickyHeader && import_react21.default.createElement(sticky_header_default, { ref: stickyHeaderRef, variant: computedVariant, theadProps, wrapperRef: wrapperRefObject, theadRef, secondaryWrapperRef, tableRef: tableRefObject, onScroll: handleScroll, tableHasHeader: hasHeader, contentDensity })
      ), disableHeaderPaddings: true, disableContentPaddings: true, variant: toContainerVariant(computedVariant), __disableFooterPaddings: true, __disableFooterDivider: true, __disableStickyMobile: false, footer: hasFooter ? import_react21.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default["footer-wrapper"], styles_css_default[`variant-${computedVariant}`]) },
        import_react21.default.createElement(
          "div",
          { className: clsx_m_default(styles_css_default.footer, hasFooterPagination && styles_css_default["footer-with-pagination"]) },
          footer && import_react21.default.createElement("span", null, footer),
          hasFooterPagination && import_react21.default.createElement("div", { className: styles_css_default["footer-pagination"] }, pagination)
        )
      ) : null, __stickyHeader: stickyHeader, __mobileStickyOffset: toolsHeaderHeight, __stickyOffset: stickyHeaderVerticalOffset }, focusMarkers.root),
      import_react21.default.createElement(
        "div",
        Object.assign({ ref: wrapperRef, className: clsx_m_default(styles_css_default.wrapper, styles_css_default[`variant-${computedVariant}`], {
          [styles_css_default["has-footer"]]: hasFooter,
          [styles_css_default["has-header"]]: hasHeader
        }), onScroll: handleScroll }, wrapperProps),
        !!renderAriaLive && !!firstIndex && import_react21.default.createElement(
          live_region_default,
          null,
          import_react21.default.createElement("span", null, renderAriaLive({ totalItemsCount, firstIndex, lastIndex: firstIndex + items.length - 1 }))
        ),
        import_react21.default.createElement(
          "table",
          {
            ref: tableRef,
            className: clsx_m_default(styles_css_default.table, resizableColumns && styles_css_default["table-layout-fixed"], contentDensity === "compact" && getVisualContextClassname("compact-table")),
            role: "table",
            "aria-label": ariaLabels === null || ariaLabels === void 0 ? void 0 : ariaLabels.tableLabel,
            "aria-rowcount": totalItemsCount ? totalItemsCount + 1 : -1
          },
          import_react21.default.createElement(thead_default, Object.assign({ ref: theadRef, hidden: stickyHeader, onFocusedComponentChange: (component) => {
            var _a2;
            return (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.setFocus(component);
          } }, theadProps)),
          import_react21.default.createElement("tbody", null, loading || items.length === 0 ? import_react21.default.createElement(
            "tr",
            null,
            import_react21.default.createElement(
              "td",
              { colSpan: selectionType ? visibleColumnDefinitions.length + 1 : visibleColumnDefinitions.length, className: clsx_m_default(styles_css_default["cell-merged"], hasFooter && styles_css_default["has-footer"]) },
              import_react21.default.createElement("div", { className: styles_css_default["cell-merged-content"], style: {
                width: supportsStickyPosition() && containerWidth && Math.floor(containerWidth) || void 0
              } }, loading ? import_react21.default.createElement(
                StatusIndicator,
                { type: "loading", className: styles_css_default.loading, wrapText: true },
                import_react21.default.createElement(live_region_default, { visible: true }, loadingText)
              ) : import_react21.default.createElement("div", { className: styles_css_default.empty }, empty))
            )
          ) : items.map((item, rowIndex) => {
            const firstVisible = rowIndex === 0;
            const lastVisible = rowIndex === items.length - 1;
            const isEven = rowIndex % 2 === 0;
            const isSelected = !!selectionType && isItemSelected(item);
            const isPrevSelected = !!selectionType && !firstVisible && isItemSelected(items[rowIndex - 1]);
            const isNextSelected = !!selectionType && !lastVisible && isItemSelected(items[rowIndex + 1]);
            return import_react21.default.createElement(
              "tr",
              Object.assign({ key: getItemKey(trackBy, item, rowIndex), className: clsx_m_default(styles_css_default.row, isSelected && styles_css_default["row-selected"]), onFocus: ({ currentTarget }) => {
                var _a2;
                if (!currentTarget.contains(getMouseDownTarget())) {
                  (_a2 = stickyHeaderRef.current) === null || _a2 === void 0 ? void 0 : _a2.scrollToRow(currentTarget);
                }
              } }, focusMarkers.item, { onClick: onRowClickHandler && onRowClickHandler.bind(null, rowIndex, item), onContextMenu: onRowContextMenuHandler && onRowContextMenuHandler.bind(null, rowIndex, item), "aria-rowindex": firstIndex ? firstIndex + rowIndex + 1 : void 0 }),
              selectionType !== void 0 && import_react21.default.createElement(
                TableTdElement,
                { className: clsx_m_default(styles_css_default["selection-control"]), isVisualRefresh, isFirstRow: firstVisible, isLastRow: lastVisible, isSelected, isNextSelected, isPrevSelected, wrapLines: false, isEvenRow: isEven, stripedRows, hasSelection, hasFooter, stickyState, columnId: selectionColumnId },
                import_react21.default.createElement(SelectionControl, Object.assign({ onFocusDown: moveFocusDown, onFocusUp: moveFocusUp, onShiftToggle: updateShiftToggle }, getItemSelectionProps(item)))
              ),
              visibleColumnDefinitions.map((column, colIndex) => {
                var _a2;
                const isEditing = !!currentEditCell && currentEditCell[0] === rowIndex && currentEditCell[1] === colIndex;
                const successfulEdit = !!lastSuccessfulEditCell && lastSuccessfulEditCell[0] === rowIndex && lastSuccessfulEditCell[1] === colIndex;
                const isEditable = !!column.editConfig && !currentEditLoading;
                return import_react21.default.createElement(TableBodyCell, { key: getColumnKey(column, colIndex), style: resizableColumns ? {} : {
                  width: column.width,
                  minWidth: column.minWidth,
                  maxWidth: column.maxWidth
                }, ariaLabels, column, item, wrapLines, isEditable, isEditing, isRowHeader: column.isRowHeader, isFirstRow: firstVisible, isLastRow: lastVisible, isSelected, isNextSelected, isPrevSelected, successfulEdit, onEditStart: () => {
                  setLastSuccessfulEditCell(null);
                  setCurrentEditCell([rowIndex, colIndex]);
                }, onEditEnd: (editCancelled) => {
                  const eventCancelled = fireCancelableEvent(onEditCancel, {});
                  if (!eventCancelled) {
                    setCurrentEditCell(null);
                    if (!editCancelled) {
                      setLastSuccessfulEditCell([rowIndex, colIndex]);
                    }
                  }
                }, submitEdit: wrapWithInlineLoadingState(submitEdit), hasFooter, stripedRows, isEvenRow: isEven, columnId: (_a2 = column.id) !== null && _a2 !== void 0 ? _a2 : colIndex, stickyState, isVisualRefresh });
              })
            );
          }))
        ),
        resizableColumns && import_react21.default.createElement(ResizeTracker, null)
      ),
      import_react21.default.createElement(sticky_scrollbar_default, { ref: scrollbarRef, wrapperRef: wrapperRefObject, tableRef: tableRefObject, onScroll: handleScroll })
    )
  );
});
var internal_default4 = InternalTable;

// node_modules/@cloudscape-design/components/table/index.js
var Table = import_react22.default.forwardRef((_a, ref) => {
  var { items = [], selectedItems = [], variant = "container", contentDensity = "comfortable" } = _a, props = __rest(_a, ["items", "selectedItems", "variant", "contentDensity"]);
  const baseComponentProps = useBaseComponent("Table");
  return import_react22.default.createElement(internal_default4, Object.assign({ items, selectedItems, variant, contentDensity }, props, baseComponentProps, { ref }));
});
applyDisplayName(Table, "Table");
var table_default = Table;

export {
  ToolsHeader,
  SelectionControl,
  getItemKey,
  useFocusMove,
  focusMarkers,
  useSelection,
  AsyncStore,
  useReaction,
  useSelector,
  stickyScrolling,
  useMouseDownTarget,
  internal_default4 as internal_default,
  table_default
};
//# sourceMappingURL=chunk-FCQUFLYB.js.map
