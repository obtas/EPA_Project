{
  "version": 3,
  "sources": ["../../src/internal/breakpoints.ts", "../../src/internal/hooks/use-mobile/index.ts"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nexport type Breakpoint = 'default' | 'xxs' | 'xs' | 's' | 'm' | 'l' | 'xl';\n\nconst BREAKPOINT_MAPPING: [Breakpoint, number][] = [\n  ['xl', 1840],\n  ['l', 1320],\n  ['m', 1120],\n  ['s', 912],\n  ['xs', 688],\n  ['xxs', 465],\n  ['default', -1],\n];\n\nexport const mobileBreakpoint = BREAKPOINT_MAPPING.filter(b => b[0] === 'xs')[0][1];\n\nconst BREAKPOINTS_DESCENDING = BREAKPOINT_MAPPING.map(([bp]) => bp);\n\n/**\n * Take a breakpoint mapping and return the breakpoint value that most closely matches the actual breakpoint.\n */\nexport function matchBreakpointMapping<T>(subset: Partial<Record<Breakpoint, T>>, actual: Breakpoint): T | null {\n  const qualifyingBreakpoints = BREAKPOINT_MAPPING.slice(BREAKPOINTS_DESCENDING.indexOf(actual));\n  for (const [breakpoint] of qualifyingBreakpoints) {\n    const breakpointValue = subset[breakpoint];\n    if (breakpointValue !== undefined) {\n      return breakpointValue;\n    }\n  }\n  return null;\n}\n\n/**\n * Get the named breakpoint for a provided width, optionally filtering to a subset of breakpoints.\n */\nexport function getMatchingBreakpoint(width: number, breakpointFilter?: readonly Breakpoint[]): Breakpoint {\n  for (const [breakpoint, breakpointWidth] of BREAKPOINT_MAPPING) {\n    if (width > breakpointWidth && (!breakpointFilter || breakpointFilter.indexOf(breakpoint) !== -1)) {\n      return breakpoint;\n    }\n  }\n  return 'default';\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { getMatchingBreakpoint, mobileBreakpoint } from '../../breakpoints';\nimport { createSingletonState } from '../use-singleton-handler';\n\nfunction getIsMobile() {\n  if (typeof window === 'undefined') {\n    // assume desktop in server-rendering\n    return false;\n  }\n\n  if (window.matchMedia) {\n    /**\n     * Some browsers include the scrollbar width in their media query calculations, but\n     * some browsers don't. Thus we can't use `window.innerWidth` or\n     * `document.documentElement.clientWidth` to get a very accurate result (since we\n     * wouldn't know which one of them to use).\n     * Instead, we use the media query here in JS too.\n     */\n    return window.matchMedia(`(max-width: ${mobileBreakpoint}px)`).matches;\n  }\n\n  return getMatchingBreakpoint(window.innerWidth, ['xs']) !== 'xs';\n}\n\nexport const useMobile = createSingletonState<boolean>({\n  initialState: () => getIsMobile(),\n  factory: handler => {\n    const listener = () => handler(getIsMobile());\n    window.addEventListener('resize', listener);\n    return () => {\n      window.removeEventListener('resize', listener);\n    };\n  },\n});\n"],
  "mappings": ";;;;;AAIA,IAAM,qBAA6C;EACjD,CAAC,MAAM,IAAI;EACX,CAAC,KAAK,IAAI;EACV,CAAC,KAAK,IAAI;EACV,CAAC,KAAK,GAAG;EACT,CAAC,MAAM,GAAG;EACV,CAAC,OAAO,GAAG;EACX,CAAC,WAAW,EAAE;;AAGT,IAAM,mBAAmB,mBAAmB,OAAO,SAAA,GAAC;AAAI,SAAA,EAAE,OAAO;AAAT,CAAa,EAAE,GAAG;AAEjF,IAAM,yBAAyB,mBAAmB,IAAI,SAAC,IAAI;MAAH,KAAE,GAAA;AAAM,SAAA;AAAA,CAAE;AAmB5D,SAAU,sBAAsB,OAAe,kBAAwC;AAC3F,WAA4C,KAAA,GAAA,uBAAA,oBAAA,KAAA,qBAAA,QAAA,MAAoB;AAArD,QAAA,KAAA,qBAAA,KAAC,aAAU,GAAA,IAAE,kBAAe,GAAA;AACrC,QAAI,QAAQ,oBAAoB,CAAC,oBAAoB,iBAAiB,QAAQ,UAAU,MAAM,KAAK;AACjG,aAAO;;;AAGX,SAAO;AACT;;;ACrCA,SAAS,cAAW;AAClB,MAAI,OAAO,WAAW,aAAa;AAEjC,WAAO;;AAGT,MAAI,OAAO,YAAY;AAQrB,WAAO,OAAO,WAAW,eAAA,OAAe,kBAAgB,KAAA,CAAK,EAAE;;AAGjE,SAAO,sBAAsB,OAAO,YAAY,CAAC,IAAI,CAAC,MAAM;AAC9D;AAEO,IAAM,YAAY,qBAA8B;EACrD,cAAc,WAAA;AAAM,WAAA,YAAW;EAAX;EACpB,SAAS,SAAA,SAAO;AACd,QAAM,WAAW,WAAA;AAAM,aAAA,QAAQ,YAAW,CAAE;IAArB;AACvB,WAAO,iBAAiB,UAAU,QAAQ;AAC1C,WAAO,WAAA;AACL,aAAO,oBAAoB,UAAU,QAAQ;IAC/C;EACF;CACD;",
  "names": []
}
