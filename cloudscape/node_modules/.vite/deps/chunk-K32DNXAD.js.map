{
  "version": 3,
  "sources": ["../../src/container/use-sticky-header.ts"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { RefObject, useState, useLayoutEffect, useCallback, useEffect, createContext, useMemo } from 'react';\nimport { useAppLayoutContext } from '../internal/context/app-layout-context';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport { findUpUntil, supportsStickyPosition } from '../internal/utils/dom';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nimport { useVisualRefresh } from '../internal/hooks/use-visual-mode';\nimport customCssProps from '../internal/generated/custom-css-properties';\n\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({ isStuck: false });\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number\n) => {\n  const currentRootRef = rootRef.current;\n  const currentHeaderRef = headerRef.current;\n  const totalBorder = useMemo(() => {\n    const containerRootBorder = currentRootRef\n      ? parseInt(getComputedStyle(currentRootRef).getPropertyValue('border-top-width'), 10)\n      : 0;\n    const headerBorder = currentHeaderRef\n      ? parseInt(getComputedStyle(currentHeaderRef).getPropertyValue('border-top-width'), 10)\n      : 0;\n    return containerRootBorder + headerBorder;\n  }, [currentRootRef, currentHeaderRef]);\n\n  // We reach into AppLayoutContext in case sticky header needs to be offset down by the height\n  // of other sticky elements positioned on top of the view.\n  const { stickyOffsetTop } = useAppLayoutContext();\n  const isSticky = useSupportsStickyHeader() && !!__stickyHeader;\n  const isRefresh = useVisualRefresh();\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const effectiveStickyOffset = __stickyOffset ?? (hasInnerOverflowParents ? 0 : stickyOffsetTop);\n\n  /**\n   * The AppLayout refactor removed the need for passing the sticky offset in px all the time through the\n   * AppLayoutDomContext provider because that information already exists on the DOM in a custom property\n   * on the Layout subcomponent. Thus, if the Container header is sticky, we are in Visual Refresh and use\n   * body scroll then we will use that property. When a component is used outside AppLayout, we fall back\n   * to the default offset calculated in AppLayoutDomContext.\n   */\n  let computedOffset = `${effectiveStickyOffset - totalBorder}px`;\n  if (isRefresh && !hasInnerOverflowParents) {\n    computedOffset = `var(${customCssProps.offsetTopWithNotifications}, ${computedOffset})`;\n  }\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(() => {\n    if (rootRef.current && headerRef.current) {\n      const rootTop = rootRef.current.getBoundingClientRect().top;\n      const headerTop = headerRef.current.getBoundingClientRect().top;\n      if (rootTop + totalBorder < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n    }\n  }, [rootRef, headerRef, totalBorder]);\n  useEffect(() => {\n    if (isSticky) {\n      window.addEventListener('scroll', checkIfStuck, true);\n      window.addEventListener('resize', checkIfStuck);\n      return () => {\n        window.removeEventListener('scroll', checkIfStuck, true);\n        window.removeEventListener('resize', checkIfStuck);\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    stickyStyles,\n  };\n};\n\nexport function useSupportsStickyHeader() {\n  const isMobile = useMobile();\n  return supportsStickyPosition() && !isMobile;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;AAEA,mBAAqG;AAY9F,IAAM,0BAAsB,4BAAwC,EAAE,SAAS,MAAK,CAAE;AAEtF,IAAM,kBAAkB,SAC7B,SACA,WACA,gBACA,gBAAuB;AAEvB,MAAM,iBAAiB,QAAQ;AAC/B,MAAM,mBAAmB,UAAU;AACnC,MAAM,kBAAc,sBAAQ,WAAA;AAC1B,QAAM,sBAAsB,iBACxB,SAAS,iBAAiB,cAAc,EAAE,iBAAiB,kBAAkB,GAAG,EAAE,IAClF;AACJ,QAAM,eAAe,mBACjB,SAAS,iBAAiB,gBAAgB,EAAE,iBAAiB,kBAAkB,GAAG,EAAE,IACpF;AACJ,WAAO,sBAAsB;EAC/B,GAAG,CAAC,gBAAgB,gBAAgB,CAAC;AAI7B,MAAA,kBAAoB,oBAAmB,EAAE;AACjD,MAAM,WAAW,wBAAuB,KAAM,CAAC,CAAC;AAChD,MAAM,YAAY,iBAAgB;AAG5B,MAAA,SAAwD,uBAAS,KAAK,GAArE,0BAAuB,GAAA,IAAE,6BAA0B,GAAA;AACpD,MAAA,SAAwB,uBAAS,KAAK,GAArC,UAAO,GAAA,IAAE,aAAU,GAAA;AAC1B,oCAAgB,WAAA;AACd,QAAI,QAAQ,SAAS;AACnB,UAAM,kBAAkB,mBAAmB,QAAQ,OAAO;AAC1D,UAAM,cAAc,YAAY,QAAQ,SAAS,SAAA,MAAI;AAAI,eAAA,KAAK,YAAY;MAAjB,CAAuB;AAKhF,iCAA2B,gBAAgB,SAAS,KAAK,gBAAgB,OAAO,WAAW;;EAE/F,GAAG,CAAC,OAAO,CAAC;AAEZ,MAAM,wBAAwB,mBAAc,QAAd,mBAAc,SAAd,iBAAmB,0BAA0B,IAAI;AAS/E,MAAI,iBAAiB,GAAA,OAAG,wBAAwB,aAAW,IAAA;AAC3D,MAAI,aAAa,CAAC,yBAAyB;AACzC,qBAAiB,OAAA,OAAO,8BAAe,4BAA0B,IAAA,EAAA,OAAK,gBAAc,GAAA;;AAGtF,MAAM,eAAe,WACjB;IACE,OAAO;MACL,KAAK;;MAGT,CAAA;AAIJ,MAAM,mBAAe,0BAAY,WAAA;AAC/B,QAAI,QAAQ,WAAW,UAAU,SAAS;AACxC,UAAM,UAAU,QAAQ,QAAQ,sBAAqB,EAAG;AACxD,UAAM,YAAY,UAAU,QAAQ,sBAAqB,EAAG;AAC5D,UAAI,UAAU,cAAc,WAAW;AACrC,mBAAW,IAAI;aACV;AACL,mBAAW,KAAK;;;EAGtB,GAAG,CAAC,SAAS,WAAW,WAAW,CAAC;AACpC,8BAAU,WAAA;AACR,QAAI,UAAU;AACZ,aAAO,iBAAiB,UAAU,cAAc,IAAI;AACpD,aAAO,iBAAiB,UAAU,YAAY;AAC9C,aAAO,WAAA;AACL,eAAO,oBAAoB,UAAU,cAAc,IAAI;AACvD,eAAO,oBAAoB,UAAU,YAAY;MACnD;;EAEJ,GAAG,CAAC,UAAU,YAAY,CAAC;AAC3B,SAAO;IACL;IACA;IACA;;AAEJ;AAEM,SAAU,0BAAuB;AACrC,MAAM,WAAW,UAAS;AAC1B,SAAO,uBAAsB,KAAM,CAAC;AACtC;",
  "names": []
}
