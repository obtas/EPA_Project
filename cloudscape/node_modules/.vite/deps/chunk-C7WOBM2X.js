import {
  AbstractSwitch,
  FormFieldContext,
  InternalFormField,
  browserScrollbarSize,
  internal_default as internal_default2,
  internal_default2 as internal_default3,
  radio_button_default,
  styles_css_default,
  useFormFieldContext
} from "./chunk-AEATPONT.js";
import {
  InternalSpaceBetween,
  require_react_keyed_flatten_children
} from "./chunk-7GVACSZY.js";
import {
  Portal
} from "./chunk-TM5SCOBX.js";
import {
  focus_lock_default
} from "./chunk-B33KRNJ3.js";
import {
  InternalHeader
} from "./chunk-HAME2ABT.js";
import {
  scrollElementIntoView,
  useUniqueId
} from "./chunk-5PTPSAWI.js";
import {
  InternalBox
} from "./chunk-OLA4AI5K.js";
import {
  InternalButton,
  useForwardFocus
} from "./chunk-46IS5YID.js";
import {
  useInternalI18n
} from "./chunk-VOJM65QS.js";
import {
  useContainerBreakpoints,
  useContainerQuery
} from "./chunk-7EUAENCI.js";
import {
  fireNonCancelableEvent
} from "./chunk-CTALK4OT.js";
import {
  internal_default,
  useMergeRefs
} from "./chunk-4FOLHITS.js";
import {
  KeyCode,
  __rest,
  applyDisplayName,
  clsx_m_default,
  getBaseProps,
  isDevelopment,
  useBaseComponent,
  useVisualRefresh,
  warnOnce
} from "./chunk-YXZ34YT5.js";
import {
  require_react_dom
} from "./chunk-XY35XOXX.js";
import {
  __toESM,
  require_react
} from "./chunk-C3URVCCN.js";

// node_modules/@cloudscape-design/components/collection-preferences/index.js
var import_react22 = __toESM(require_react());

// node_modules/@cloudscape-design/components/modal/internal.js
var import_react2 = __toESM(require_react());

// node_modules/@cloudscape-design/components/modal/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/modal/styles.scoped.css";
var styles_css_default2 = {
  "dialog": "awsui_dialog_1d2i7_k6v6r_105",
  "modal-slide-up": "awsui_modal-slide-up_1d2i7_k6v6r_1",
  "awsui-motion-fade-in-0": "awsui_awsui-motion-fade-in-0_1d2i7_k6v6r_1",
  "refresh": "awsui_refresh_1d2i7_k6v6r_128",
  "awsui-motion-scale-popup": "awsui_awsui-motion-scale-popup_1d2i7_k6v6r_1",
  "root": "awsui_root_1d2i7_k6v6r_161",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_1d2i7_k6v6r_1",
  "hidden": "awsui_hidden_1d2i7_k6v6r_226",
  "focus-lock": "awsui_focus-lock_1d2i7_k6v6r_230",
  "small": "awsui_small_1d2i7_k6v6r_248",
  "medium": "awsui_medium_1d2i7_k6v6r_251",
  "large": "awsui_large_1d2i7_k6v6r_254",
  "max": "awsui_max_1d2i7_k6v6r_257",
  "breakpoint-xs": "awsui_breakpoint-xs_1d2i7_k6v6r_257",
  "container": "awsui_container_1d2i7_k6v6r_262",
  "content": "awsui_content_1d2i7_k6v6r_281",
  "no-paddings": "awsui_no-paddings_1d2i7_k6v6r_284",
  "header": "awsui_header_1d2i7_k6v6r_288",
  "header--text": "awsui_header--text_1d2i7_k6v6r_295",
  "footer": "awsui_footer_1d2i7_k6v6r_299",
  "footer--stuck": "awsui_footer--stuck_1d2i7_k6v6r_307",
  "dismiss-control": "awsui_dismiss-control_1d2i7_k6v6r_316",
  "modal-open": "awsui_modal-open_1d2i7_k6v6r_320"
};

// node_modules/@cloudscape-design/components/modal/body-scroll.js
var initialBodyPaddingRightStyle = void 0;
function disableBodyScrolling() {
  setBodyScrollbarPadding();
  document.body.classList.add(styles_css_default2["modal-open"]);
}
function enableBodyScrolling() {
  document.body.classList.remove(styles_css_default2["modal-open"]);
  restoreBodyScrollbarPadding();
}
function setBodyScrollbarPadding() {
  if (bodyHasScrollbar()) {
    initialBodyPaddingRightStyle = document.body.style.paddingRight;
    const initialBodyPaddingRight = computedBodyPaddingRightPixels();
    const scrollbarWidth = browserScrollbarSize().width;
    const newBodyPaddingRight = initialBodyPaddingRight + scrollbarWidth;
    document.body.style.paddingRight = newBodyPaddingRight + "px";
  }
}
function computedBodyPaddingRightPixels() {
  return parseInt(window.getComputedStyle(document.body).paddingRight, 10);
}
function restoreBodyScrollbarPadding() {
  if (initialBodyPaddingRightStyle) {
    document.body.style.setProperty("padding-right", initialBodyPaddingRightStyle);
  } else {
    document.body.style.removeProperty("padding-right");
  }
  initialBodyPaddingRightStyle = void 0;
}
function bodyHasScrollbar() {
  return document.body.clientWidth < window.innerWidth;
}

// node_modules/@cloudscape-design/components/internal/hooks/use-intersection-observer/index.js
var import_react = __toESM(require_react());
function useIntersectionObserver() {
  const observerRef = (0, import_react.useRef)(null);
  const [isIntersecting, setIsIntersecting] = (0, import_react.useState)(false);
  const ref = (0, import_react.useCallback)((targetElement) => {
    if (typeof IntersectionObserver === "undefined") {
      return;
    }
    if (observerRef.current) {
      observerRef.current.disconnect();
    }
    if (targetElement) {
      observerRef.current = new IntersectionObserver(([entry]) => setIsIntersecting(entry.isIntersecting));
      observerRef.current.observe(targetElement);
    }
  }, []);
  return { ref, isIntersecting };
}

// node_modules/@cloudscape-design/components/modal/internal.js
function InternalModal(_a) {
  var { modalRoot } = _a, rest = __rest(_a, ["modalRoot"]);
  return import_react2.default.createElement(
    Portal,
    { container: modalRoot },
    import_react2.default.createElement(InnerModal, Object.assign({}, rest))
  );
}
function InnerModal(_a) {
  var { size, visible, header, children, footer, disableContentPaddings, onDismiss, __internalRootRef = null } = _a, rest = __rest(_a, ["size", "visible", "header", "children", "footer", "disableContentPaddings", "onDismiss", "__internalRootRef"]);
  const instanceUniqueId = useUniqueId();
  const headerId = `${rest.id || instanceUniqueId}-header`;
  const lastMouseDownElementRef = (0, import_react2.useRef)(null);
  const [breakpoint, breakpointsRef] = useContainerBreakpoints(["xs"]);
  const i18n = useInternalI18n("modal");
  const closeAriaLabel = i18n("closeAriaLabel", rest.closeAriaLabel);
  const refObject = (0, import_react2.useRef)(null);
  const mergedRef = useMergeRefs(breakpointsRef, refObject, __internalRootRef);
  const isRefresh = useVisualRefresh();
  const baseProps = getBaseProps(rest);
  (0, import_react2.useEffect)(() => {
    return () => {
      enableBodyScrolling();
    };
  }, []);
  (0, import_react2.useEffect)(() => {
    if (visible) {
      disableBodyScrolling();
    } else {
      enableBodyScrolling();
    }
  }, [visible]);
  (0, import_react2.useEffect)(() => {
    if (visible && refObject.current) {
      refObject.current.scrollTop = 0;
    }
  }, [visible]);
  const dismiss = (reason) => fireNonCancelableEvent(onDismiss, { reason });
  const onOverlayMouseDown = (event) => {
    lastMouseDownElementRef.current = event.target;
  };
  const onOverlayClick = (event) => {
    const overlay = refObject.current;
    const lastClicked = lastMouseDownElementRef.current;
    if (event.target === overlay && lastClicked === overlay) {
      dismiss("overlay");
    }
  };
  const onCloseButtonClick = () => dismiss("closeButton");
  const escKeyHandler = (event) => {
    if (event.keyCode === KeyCode.escape) {
      dismiss("keyboard");
    }
  };
  const { ref: stickySentinelRef, isIntersecting: footerStuck } = useIntersectionObserver();
  const [footerHeight, footerRef] = useContainerQuery((rect) => rect.borderBoxHeight);
  return import_react2.default.createElement(
    FormFieldContext.Provider,
    { value: {} },
    import_react2.default.createElement(
      "div",
      Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default2.root, { [styles_css_default2.hidden]: !visible }, baseProps.className, isRefresh && styles_css_default2.refresh), role: "dialog", "aria-modal": true, "aria-labelledby": headerId, onMouseDown: onOverlayMouseDown, onClick: onOverlayClick, ref: mergedRef, style: footerHeight ? { scrollPaddingBottom: footerHeight } : void 0 }),
      import_react2.default.createElement(
        focus_lock_default,
        { disabled: !visible, autoFocus: true, restoreFocus: true, className: styles_css_default2["focus-lock"] },
        import_react2.default.createElement(
          "div",
          { className: clsx_m_default(styles_css_default2.dialog, styles_css_default2[size], styles_css_default2[`breakpoint-${breakpoint}`], isRefresh && styles_css_default2.refresh), onKeyDown: escKeyHandler },
          import_react2.default.createElement(
            "div",
            { className: styles_css_default2.container },
            import_react2.default.createElement(
              "div",
              { className: styles_css_default2.header },
              import_react2.default.createElement(
                InternalHeader,
                { variant: "h2", __disableActionsWrapping: true, actions: import_react2.default.createElement(InternalButton, { ariaLabel: closeAriaLabel, className: styles_css_default2["dismiss-control"], variant: "modal-dismiss", iconName: "close", formAction: "none", onClick: onCloseButtonClick }) },
                import_react2.default.createElement("span", { id: headerId, className: styles_css_default2["header--text"] }, header)
              )
            ),
            import_react2.default.createElement(
              "div",
              { className: clsx_m_default(styles_css_default2.content, { [styles_css_default2["no-paddings"]]: disableContentPaddings }) },
              children,
              import_react2.default.createElement("div", { ref: stickySentinelRef })
            ),
            footer && import_react2.default.createElement("div", { ref: footerRef, className: clsx_m_default(styles_css_default2.footer, footerStuck && styles_css_default2["footer--stuck"]) }, footer)
          )
        )
      )
    )
  );
}

// node_modules/@cloudscape-design/components/collection-preferences/utils.js
var import_react8 = __toESM(require_react());

// node_modules/@cloudscape-design/components/column-layout/internal.js
var import_react5 = __toESM(require_react());

// node_modules/@cloudscape-design/components/column-layout/flexible-column-layout/index.js
var import_react3 = __toESM(require_react());
var import_react_keyed_flatten_children = __toESM(require_react_keyed_flatten_children());

// node_modules/@cloudscape-design/components/column-layout/flexible-column-layout/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/column-layout/flexible-column-layout/styles.scoped.css";
var styles_css_default3 = {
  "css-grid": "awsui_css-grid_zqq3x_19kru_9",
  "grid-no-gutters": "awsui_grid-no-gutters_zqq3x_19kru_13",
  "grid-variant-text-grid": "awsui_grid-variant-text-grid_zqq3x_19kru_16",
  "item": "awsui_item_zqq3x_19kru_16",
  "first-column": "awsui_first-column_zqq3x_19kru_21"
};

// node_modules/@cloudscape-design/components/column-layout/flexible-column-layout/index.js
var isOdd = (value) => value % 2 !== 0;
function calculcateCssColumnCount(columns, minColumnWidth, containerWidth) {
  if (!containerWidth) {
    return columns;
  }
  const targetColumnCount = Math.min(columns, Math.floor(containerWidth / minColumnWidth));
  return Math.max(1, targetColumnCount < columns && isOdd(targetColumnCount) ? targetColumnCount - 1 : targetColumnCount);
}
function FlexibleColumnLayout({ columns = 1, minColumnWidth = 0, disableGutters, variant, children }) {
  const [containerWidth, containerRef] = useContainerQuery((rect) => rect.width);
  const columnCount = calculcateCssColumnCount(columns, minColumnWidth, containerWidth);
  const shouldDisableGutters = variant !== "text-grid" && disableGutters;
  const flattenedChildren = (0, import_react_keyed_flatten_children.default)(children);
  return import_react3.default.createElement("div", { ref: containerRef, className: clsx_m_default(styles_css_default3["css-grid"], styles_css_default3[`grid-variant-${variant}`], shouldDisableGutters && [styles_css_default3["grid-no-gutters"]]), style: { gridTemplateColumns: `repeat(${columnCount}, 1fr)` } }, flattenedChildren.map((child, i) => {
    const key2 = child.key;
    return import_react3.default.createElement("div", { key: key2, className: clsx_m_default(styles_css_default3.item, {
      [styles_css_default3["first-column"]]: i % columnCount === 0
    }) }, child);
  }));
}

// node_modules/@cloudscape-design/components/column-layout/grid-column-layout.js
var import_react4 = __toESM(require_react());
var import_react_keyed_flatten_children2 = __toESM(require_react_keyed_flatten_children());

// node_modules/@cloudscape-design/components/column-layout/util.js
function repeat(value, times) {
  const array = [];
  for (let i = 0; i < times; i++) {
    array[i] = value;
  }
  return array;
}

// node_modules/@cloudscape-design/components/column-layout/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/column-layout/styles.scoped.css";
var styles_css_default4 = {
  "column-layout": "awsui_column-layout_vvxn7_1ve47_93",
  "grid": "awsui_grid_vvxn7_1ve47_106",
  "grid-no-gutters": "awsui_grid-no-gutters_vvxn7_1ve47_111",
  "grid-variant-text-grid": "awsui_grid-variant-text-grid_vvxn7_1ve47_114",
  "grid-breakpoint-default": "awsui_grid-breakpoint-default_vvxn7_1ve47_121",
  "grid-columns-1": "awsui_grid-columns-1_vvxn7_1ve47_124",
  "grid-breakpoint-xxs": "awsui_grid-breakpoint-xxs_vvxn7_1ve47_124",
  "grid-breakpoint-xs": "awsui_grid-breakpoint-xs_vvxn7_1ve47_127",
  "grid-columns-2": "awsui_grid-columns-2_vvxn7_1ve47_130",
  "grid-columns-3": "awsui_grid-columns-3_vvxn7_1ve47_136",
  "grid-columns-4": "awsui_grid-columns-4_vvxn7_1ve47_142",
  "grid-vertical-borders": "awsui_grid-vertical-borders_vvxn7_1ve47_155",
  "grid-horizontal-borders": "awsui_grid-horizontal-borders_vvxn7_1ve47_188"
};

// node_modules/@cloudscape-design/components/column-layout/grid-column-layout.js
var COLUMN_DEFS = {
  1: { colspan: { default: 12, xxs: 12, xs: 12 } },
  2: { colspan: { default: 12, xxs: 6, xs: 6 } },
  3: { colspan: { default: 12, xxs: 6, xs: 4 } },
  4: { colspan: { default: 12, xxs: 6, xs: 3 } }
};
function GridColumnLayout({ columns, variant, borders, disableGutters, __breakpoint, children }) {
  var _a;
  const isTextGridVariant = variant === "text-grid";
  const shouldDisableGutters = !isTextGridVariant && disableGutters;
  const shouldHaveHorizontalBorders = !isTextGridVariant && (borders === "horizontal" || borders === "all");
  const shouldHaveVerticalBorders = !isTextGridVariant && (borders === "vertical" || borders === "all");
  const flattenedChildren = (0, import_react_keyed_flatten_children2.default)(children);
  const [breakpoint, ref] = useContainerBreakpoints(COLUMN_TRIGGERS);
  return import_react4.default.createElement(internal_default3, { ref, disableGutters: true, gridDefinition: repeat((_a = COLUMN_DEFS[columns]) !== null && _a !== void 0 ? _a : {}, flattenedChildren.length), className: clsx_m_default(styles_css_default4.grid, styles_css_default4[`grid-columns-${columns}`], styles_css_default4[`grid-variant-${variant}`], {
    [styles_css_default4["grid-horizontal-borders"]]: shouldHaveHorizontalBorders,
    [styles_css_default4["grid-vertical-borders"]]: shouldHaveVerticalBorders,
    [styles_css_default4["grid-no-gutters"]]: shouldDisableGutters
  }), __breakpoint: __breakpoint || breakpoint, __responsiveClassName: (breakpoint2) => breakpoint2 && styles_css_default4[`grid-breakpoint-${breakpoint2}`] }, children);
}

// node_modules/@cloudscape-design/components/column-layout/internal.js
var COLUMN_TRIGGERS = ["default", "xxs", "xs"];
function ColumnLayout(_a) {
  var { columns = 1, variant = "default", borders = "none", disableGutters = false, minColumnWidth, children, __breakpoint, __internalRootRef } = _a, restProps = __rest(_a, ["columns", "variant", "borders", "disableGutters", "minColumnWidth", "children", "__breakpoint", "__internalRootRef"]);
  const baseProps = getBaseProps(restProps);
  return import_react5.default.createElement("div", Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default4["column-layout"]), ref: __internalRootRef }), minColumnWidth ? import_react5.default.createElement(FlexibleColumnLayout, { columns, borders, variant, minColumnWidth, disableGutters }, children) : import_react5.default.createElement(GridColumnLayout, { columns, variant, borders, disableGutters, __breakpoint }, children));
}

// node_modules/@cloudscape-design/components/radio-group/internal.js
var import_react7 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/hooks/forward-focus/radio-group.js
var import_react6 = __toESM(require_react());
function useRadioGroupForwardFocus(forwardedRef, items, value) {
  const itemRef = (0, import_react6.useRef)(null);
  const itemIndex = items && findIndex(items, (item) => item.value === value);
  (0, import_react6.useImperativeHandle)(forwardedRef, () => ({
    focus() {
      var _a;
      (_a = itemRef.current) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }));
  return [itemRef, itemIndex !== void 0 && itemIndex !== -1 ? itemIndex : 0];
}
function findIndex(items, predicate) {
  for (let i = 0; i < items.length; i++) {
    if (predicate(items[i])) {
      return i;
    }
  }
  return -1;
}

// node_modules/@cloudscape-design/components/radio-group/internal.js
var InternalRadioGroup = import_react7.default.forwardRef((_a, ref) => {
  var { name, value, items, ariaLabel, ariaRequired, ariaControls, onChange, __internalRootRef = null } = _a, props = __rest(_a, ["name", "value", "items", "ariaLabel", "ariaRequired", "ariaControls", "onChange", "__internalRootRef"]);
  const { ariaDescribedby, ariaLabelledby } = useFormFieldContext(props);
  const baseProps = getBaseProps(props);
  const generatedName = useUniqueId("awsui-radio-");
  const [radioButtonRef, radioButtonRefIndex] = useRadioGroupForwardFocus(ref, items, value);
  return import_react7.default.createElement("div", Object.assign({ role: "radiogroup", "aria-labelledby": ariaLabelledby, "aria-label": ariaLabel, "aria-describedby": ariaDescribedby, "aria-required": ariaRequired, "aria-controls": ariaControls }, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default.root), ref: __internalRootRef }), items && items.map((item, index) => import_react7.default.createElement(radio_button_default, { key: item.value, ref: index === radioButtonRefIndex ? radioButtonRef : void 0, checked: item.value === value, name: name || generatedName, value: item.value, label: item.label, description: item.description, disabled: item.disabled, onChange, controlId: item.controlId })));
});
var internal_default4 = InternalRadioGroup;

// node_modules/@cloudscape-design/components/collection-preferences/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/collection-preferences/styles.scoped.css";
var styles_css_default5 = {
  "visible-content": "awsui_visible-content_tc96w_1iq9a_185",
  "visible-content-toggle": "awsui_visible-content-toggle_tc96w_1iq9a_186",
  "visible-content-groups": "awsui_visible-content-groups_tc96w_1iq9a_187",
  "visible-content-group": "awsui_visible-content-group_tc96w_1iq9a_187",
  "visible-content-title": "awsui_visible-content-title_tc96w_1iq9a_192",
  "visible-content-group-label": "awsui_visible-content-group-label_tc96w_1iq9a_201",
  "visible-content-option": "awsui_visible-content-option_tc96w_1iq9a_207",
  "visible-content-option-label": "awsui_visible-content-option-label_tc96w_1iq9a_218",
  "content-display-option-toggle": "awsui_content-display-option-toggle_tc96w_1iq9a_409",
  "content-display-option-content": "awsui_content-display-option-content_tc96w_1iq9a_413",
  "content-display-option": "awsui_content-display-option_tc96w_1iq9a_409",
  "placeholder": "awsui_placeholder_tc96w_1iq9a_436",
  "sorting": "awsui_sorting_tc96w_1iq9a_436",
  "content-display-option-label": "awsui_content-display-option-label_tc96w_1iq9a_463",
  "drag-overlay": "awsui_drag-overlay_tc96w_1iq9a_471",
  "content-display": "awsui_content-display_tc96w_1iq9a_409",
  "content-display-title": "awsui_content-display-title_tc96w_1iq9a_498",
  "content-display-description": "awsui_content-display-description_tc96w_1iq9a_506",
  "content-display-option-list": "awsui_content-display-option-list_tc96w_1iq9a_514",
  "root": "awsui_root_tc96w_1iq9a_520",
  "modal-root": "awsui_modal-root_tc96w_1iq9a_521",
  "trigger-button": "awsui_trigger-button_tc96w_1iq9a_522",
  "cancel-button": "awsui_cancel-button_tc96w_1iq9a_523",
  "confirm-button": "awsui_confirm-button_tc96w_1iq9a_524",
  "custom": "awsui_custom_tc96w_1iq9a_525",
  "second-column-small": "awsui_second-column-small_tc96w_1iq9a_529",
  "wrap-lines": "awsui_wrap-lines_tc96w_1iq9a_533",
  "striped-rows": "awsui_striped-rows_tc96w_1iq9a_534",
  "content-density": "awsui_content-density_tc96w_1iq9a_535",
  "page-size": "awsui_page-size_tc96w_1iq9a_536",
  "page-size-form-field": "awsui_page-size-form-field_tc96w_1iq9a_537",
  "page-size-radio-group": "awsui_page-size-radio-group_tc96w_1iq9a_538",
  "sticky-columns": "awsui_sticky-columns_tc96w_1iq9a_539",
  "sticky-columns-form-field": "awsui_sticky-columns-form-field_tc96w_1iq9a_540",
  "sticky-columns-radio-group": "awsui_sticky-columns-radio-group_tc96w_1iq9a_541",
  "sticky-columns-first": "awsui_sticky-columns-first_tc96w_1iq9a_542",
  "sticky-columns-last": "awsui_sticky-columns-last_tc96w_1iq9a_543"
};

// node_modules/@cloudscape-design/components/collection-preferences/utils.js
var copyPreferences = ({ pageSize, wrapLines, stripedRows, contentDensity, visibleContent, contentDisplay, stickyColumns, custom }) => ({
  pageSize,
  wrapLines,
  stripedRows,
  contentDensity,
  visibleContent,
  contentDisplay,
  stickyColumns,
  custom
});
var mergePreferences = (newPref, oldPref) => {
  const newObj = Object.assign({}, oldPref);
  const prefNames = [
    "pageSize",
    "wrapLines",
    "stripedRows",
    "contentDensity",
    "visibleContent",
    "custom",
    "contentDisplay",
    "stickyColumns"
  ];
  for (const prefName of prefNames) {
    if (newPref[prefName] !== void 0) {
      newObj[prefName] = newPref[prefName];
    }
  }
  return newObj;
};
var ModalContentLayout = ({ left, right }) => {
  const [breakpoint, ref] = useContainerBreakpoints(["xs"]);
  const smallContainer = breakpoint === "default";
  if (smallContainer) {
    return import_react8.default.createElement(
      "div",
      { ref },
      left && import_react8.default.createElement("div", null, left),
      right && import_react8.default.createElement("div", { className: clsx_m_default(left && styles_css_default5["second-column-small"]) }, right)
    );
  }
  const columns = left && right ? 2 : 1;
  return import_react8.default.createElement(
    "div",
    { ref },
    import_react8.default.createElement(
      ColumnLayout,
      { columns, variant: "text-grid" },
      left && import_react8.default.createElement("div", null, left),
      right && import_react8.default.createElement("div", null, right)
    )
  );
};
var PageSizePreference = ({ title, options, value, onChange }) => {
  const i18n = useInternalI18n("collection-preferences");
  return import_react8.default.createElement(
    "div",
    { className: styles_css_default5["page-size"] },
    import_react8.default.createElement(
      InternalFormField,
      { label: i18n("pageSizePreference.title", title), stretch: true, className: styles_css_default5["page-size-form-field"] },
      import_react8.default.createElement(internal_default4, { className: styles_css_default5["page-size-radio-group"], value: `${value}`, items: options.map(({ label, value: value2 }) => ({ label, value: `${value2}` })), onChange: ({ detail }) => onChange(parseInt(detail.value, 10)) })
    )
  );
};
var WrapLinesPreference = ({ label, description, value, onChange }) => {
  const i18n = useInternalI18n("collection-preferences");
  return import_react8.default.createElement(internal_default2, { checked: !!value, description: i18n("wrapLinesPreference.description", description), onChange: ({ detail }) => onChange(detail.checked), className: styles_css_default5["wrap-lines"] }, i18n("wrapLinesPreference.label", label));
};
function StripedRowsPreference({ label, description, value, onChange }) {
  const i18n = useInternalI18n("collection-preferences");
  return import_react8.default.createElement(internal_default2, { checked: !!value, description: i18n("stripedRowsPreference.description", description), onChange: ({ detail }) => onChange(detail.checked), className: styles_css_default5["striped-rows"] }, i18n("stripedRowsPreference.label", label));
}
var ContentDensityPreference = ({ label, description, value, onChange }) => {
  const i18n = useInternalI18n("collection-preferences");
  return import_react8.default.createElement(internal_default2, { checked: value === "compact", description: i18n("contentDensityPreference.description", description), onChange: ({ detail }) => onChange(detail.checked ? "compact" : "comfortable"), className: styles_css_default5["content-density"] }, i18n("contentDensityPreference.label", label));
};
var StickyPreference = ({ firstOrLast, preference, value, onChange }) => {
  const { title, description, options } = preference;
  return import_react8.default.createElement(
    "div",
    { className: styles_css_default5[`sticky-columns-${firstOrLast}`] },
    import_react8.default.createElement(
      InternalFormField,
      { className: styles_css_default5["sticky-columns-form-field"], label: title, description },
      import_react8.default.createElement(internal_default4, { className: styles_css_default5["sticky-columns-radio-group"], value: typeof value !== "undefined" ? `${value}` : null, items: options.map(({ label, value: value2 }) => ({ label, value: `${value2}` })), onChange: ({ detail }) => onChange(Number(detail.value)) })
    )
  );
};
var StickyColumnsPreference = ({ firstColumns, lastColumns, onChange, value }) => {
  return import_react8.default.createElement(
    InternalSpaceBetween,
    { className: styles_css_default5["sticky-columns"], size: "l" },
    firstColumns && import_react8.default.createElement(StickyPreference, { firstOrLast: "first", preference: firstColumns, value: value === null || value === void 0 ? void 0 : value.first, onChange: (newValue) => onChange(Object.assign(Object.assign({}, value), { first: newValue })) }),
    lastColumns && import_react8.default.createElement(StickyPreference, { firstOrLast: "last", preference: lastColumns, value: value === null || value === void 0 ? void 0 : value.last, onChange: (newValue) => onChange(Object.assign(Object.assign({}, value), { last: newValue })) })
  );
};
var CustomPreference = ({ value, customPreference, onChange }) => {
  const [customState, setCustomState] = (0, import_react8.useState)(value);
  if (customPreference) {
    return import_react8.default.createElement("div", { className: styles_css_default5.custom }, customPreference(customState, (value2) => {
      setCustomState(() => value2);
      onChange(value2);
    }));
  }
  return null;
};

// node_modules/@cloudscape-design/components/collection-preferences/visible-content.js
var import_react10 = __toESM(require_react());

// node_modules/@cloudscape-design/components/toggle/internal.js
var import_react9 = __toESM(require_react());

// node_modules/@cloudscape-design/components/toggle/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/toggle/styles.scoped.css";
var styles_css_default6 = {
  "root": "awsui_root_4yi2u_1ib9h_93",
  "outline": "awsui_outline_4yi2u_1ib9h_107",
  "toggle-control": "awsui_toggle-control_4yi2u_1ib9h_126",
  "toggle-control-checked": "awsui_toggle-control-checked_4yi2u_1ib9h_135",
  "toggle-control-disabled": "awsui_toggle-control-disabled_4yi2u_1ib9h_138",
  "toggle-handle": "awsui_toggle-handle_4yi2u_1ib9h_145",
  "toggle-handle-checked": "awsui_toggle-handle-checked_4yi2u_1ib9h_157",
  "toggle-handle-disabled": "awsui_toggle-handle-disabled_4yi2u_1ib9h_160"
};

// node_modules/@cloudscape-design/components/toggle/internal.js
var InternalToggle = import_react9.default.forwardRef((_a, ref) => {
  var { controlId, checked, name, disabled, children, description, ariaLabel, ariaControls, onFocus, onBlur, onChange, __internalRootRef = null } = _a, rest = __rest(_a, ["controlId", "checked", "name", "disabled", "children", "description", "ariaLabel", "ariaControls", "onFocus", "onBlur", "onChange", "__internalRootRef"]);
  const { ariaDescribedby, ariaLabelledby } = useFormFieldContext(rest);
  const baseProps = getBaseProps(rest);
  const checkboxRef = (0, import_react9.useRef)(null);
  useForwardFocus(ref, checkboxRef);
  return import_react9.default.createElement(AbstractSwitch, Object.assign({}, baseProps, { className: clsx_m_default(styles_css_default6.root, baseProps.className), controlClassName: clsx_m_default(styles_css_default6["toggle-control"], {
    [styles_css_default6["toggle-control-checked"]]: checked,
    [styles_css_default6["toggle-control-disabled"]]: disabled
  }), outlineClassName: styles_css_default6.outline, controlId, disabled, label: children, description, descriptionBottomPadding: true, ariaLabel, ariaLabelledby, ariaDescribedby, ariaControls, nativeControl: (nativeControlProps) => import_react9.default.createElement("input", Object.assign({}, nativeControlProps, {
    ref: checkboxRef,
    type: "checkbox",
    checked,
    name,
    onFocus: () => fireNonCancelableEvent(onFocus),
    onBlur: () => fireNonCancelableEvent(onBlur),
    onChange: () => {
    }
  })), onClick: () => {
    var _a2;
    (_a2 = checkboxRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
    fireNonCancelableEvent(onChange, { checked: !checked });
  }, styledControl: import_react9.default.createElement("span", { className: clsx_m_default(styles_css_default6["toggle-handle"], {
    [styles_css_default6["toggle-handle-checked"]]: checked,
    [styles_css_default6["toggle-handle-disabled"]]: disabled
  }) }), __internalRootRef }));
});
var internal_default5 = InternalToggle;

// node_modules/@cloudscape-design/components/collection-preferences/visible-content.js
var isVisible = (id, visibleIds) => visibleIds.indexOf(id) !== -1;
var className = (suffix) => ({
  className: styles_css_default5[`visible-content-${suffix}`]
});
function VisibleContentPreference({ title, options, value = [], onChange }) {
  const idPrefix = useUniqueId("visible-content");
  const flatOptionsIds = options.reduce((ids2, group) => [...ids2, ...group.options.reduce((groupIds, option) => [...groupIds, option.id], [])], []);
  const onToggle = (id) => {
    if (!isVisible(id, value)) {
      onChange([...value, id].sort((firstId, secondId) => flatOptionsIds.indexOf(firstId) - flatOptionsIds.indexOf(secondId)));
    } else {
      onChange(value.filter((currentId) => currentId !== id));
    }
  };
  const selectionOption = (option, optionGroupIndex, optionIndex) => {
    const labelId = `${idPrefix}-${optionGroupIndex}-${optionIndex}`;
    return import_react10.default.createElement(
      "div",
      Object.assign({ key: optionIndex }, className("option")),
      import_react10.default.createElement("label", Object.assign({}, className("option-label"), { htmlFor: labelId }), option.label),
      import_react10.default.createElement(
        "div",
        Object.assign({}, className("toggle")),
        import_react10.default.createElement(internal_default5, { checked: isVisible(option.id, value), onChange: () => onToggle(option.id), disabled: option.editable === false, controlId: labelId })
      )
    );
  };
  const outerGroupLabelId = `${idPrefix}-outer`;
  return import_react10.default.createElement(
    "div",
    { className: styles_css_default5["visible-content"] },
    import_react10.default.createElement("h3", Object.assign({}, className("title"), { id: outerGroupLabelId }), title),
    import_react10.default.createElement(InternalSpaceBetween, Object.assign({}, className("groups"), { size: "xs" }), options.map((optionGroup, optionGroupIndex) => {
      const groupLabelId = `${idPrefix}-${optionGroupIndex}`;
      return import_react10.default.createElement(
        "div",
        Object.assign({ key: optionGroupIndex }, className("group"), { role: "group", "aria-labelledby": `${outerGroupLabelId} ${groupLabelId}` }),
        import_react10.default.createElement("div", Object.assign({}, className("group-label"), { id: groupLabelId }), optionGroup.label),
        import_react10.default.createElement("div", null, optionGroup.options.map((option, optionIndex) => selectionOption(option, optionGroupIndex, optionIndex)))
      );
    }))
  );
}

// node_modules/@cloudscape-design/components/internal/hooks/check-controlled/index.js
function checkControlled(componentName2, propertyName, propertyValue, handlerName, handlerValue) {
  if (propertyValue !== void 0 && handlerValue === void 0 && isDevelopment) {
    warnOnce(componentName2, `You provided \`${propertyName}\` prop without an \`${handlerName}\` handler. This will render a read-only component. If the component should be mutable, set an \`${handlerName}\` handler.`);
  }
}

// node_modules/@cloudscape-design/components/collection-preferences/content-display/index.js
var import_react21 = __toESM(require_react());

// node_modules/@cloudscape-design/components/collection-preferences/content-display/utils.js
function getSortedOptions({ options, contentDisplay }) {
  const optionsById = options.reduce((currentValue, option) => Object.assign(Object.assign({}, currentValue), { [option.id]: option }), {});
  return contentDisplay.map(({ id, visible }) => Object.assign(Object.assign({}, optionsById[id]), { visible })).filter(Boolean);
}

// node_modules/@dnd-kit/core/dist/core.esm.js
var import_react13 = __toESM(require_react());
var import_react_dom = __toESM(require_react_dom());

// node_modules/@dnd-kit/utilities/dist/utilities.esm.js
var import_react11 = __toESM(require_react());
function useCombinedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return (0, import_react11.useMemo)(
    () => (node) => {
      refs.forEach((ref) => ref(node));
    },
    refs
  );
}
var canUseDOM = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
function isWindow(element) {
  const elementString = Object.prototype.toString.call(element);
  return elementString === "[object Window]" || elementString === "[object global]";
}
function isNode(node) {
  return "nodeType" in node;
}
function getWindow(target) {
  var _target$ownerDocument, _target$ownerDocument2;
  if (!target) {
    return window;
  }
  if (isWindow(target)) {
    return target;
  }
  if (!isNode(target)) {
    return window;
  }
  return (_target$ownerDocument = (_target$ownerDocument2 = target.ownerDocument) == null ? void 0 : _target$ownerDocument2.defaultView) != null ? _target$ownerDocument : window;
}
function isDocument(node) {
  const {
    Document
  } = getWindow(node);
  return node instanceof Document;
}
function isHTMLElement(node) {
  if (isWindow(node)) {
    return false;
  }
  return node instanceof getWindow(node).HTMLElement;
}
function isSVGElement(node) {
  return node instanceof getWindow(node).SVGElement;
}
function getOwnerDocument(target) {
  if (!target) {
    return document;
  }
  if (isWindow(target)) {
    return target.document;
  }
  if (!isNode(target)) {
    return document;
  }
  if (isDocument(target)) {
    return target;
  }
  if (isHTMLElement(target)) {
    return target.ownerDocument;
  }
  return document;
}
var useIsomorphicLayoutEffect = canUseDOM ? import_react11.useLayoutEffect : import_react11.useEffect;
function useEvent(handler) {
  const handlerRef = (0, import_react11.useRef)(handler);
  useIsomorphicLayoutEffect(() => {
    handlerRef.current = handler;
  });
  return (0, import_react11.useCallback)(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return handlerRef.current == null ? void 0 : handlerRef.current(...args);
  }, []);
}
function useInterval() {
  const intervalRef = (0, import_react11.useRef)(null);
  const set = (0, import_react11.useCallback)((listener, duration) => {
    intervalRef.current = setInterval(listener, duration);
  }, []);
  const clear = (0, import_react11.useCallback)(() => {
    if (intervalRef.current !== null) {
      clearInterval(intervalRef.current);
      intervalRef.current = null;
    }
  }, []);
  return [set, clear];
}
function useLatestValue(value, dependencies) {
  if (dependencies === void 0) {
    dependencies = [value];
  }
  const valueRef = (0, import_react11.useRef)(value);
  useIsomorphicLayoutEffect(() => {
    if (valueRef.current !== value) {
      valueRef.current = value;
    }
  }, dependencies);
  return valueRef;
}
function useLazyMemo(callback, dependencies) {
  const valueRef = (0, import_react11.useRef)();
  return (0, import_react11.useMemo)(
    () => {
      const newValue = callback(valueRef.current);
      valueRef.current = newValue;
      return newValue;
    },
    [...dependencies]
  );
}
function useNodeRef(onChange) {
  const onChangeHandler = useEvent(onChange);
  const node = (0, import_react11.useRef)(null);
  const setNodeRef = (0, import_react11.useCallback)(
    (element) => {
      if (element !== node.current) {
        onChangeHandler == null ? void 0 : onChangeHandler(element, node.current);
      }
      node.current = element;
    },
    []
  );
  return [node, setNodeRef];
}
function usePrevious(value) {
  const ref = (0, import_react11.useRef)();
  (0, import_react11.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref.current;
}
var ids = {};
function useUniqueId2(prefix, value) {
  return (0, import_react11.useMemo)(() => {
    if (value) {
      return value;
    }
    const id = ids[prefix] == null ? 0 : ids[prefix] + 1;
    ids[prefix] = id;
    return prefix + "-" + id;
  }, [prefix, value]);
}
function createAdjustmentFn(modifier) {
  return function(object) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((accumulator, adjustment) => {
      const entries = Object.entries(adjustment);
      for (const [key2, valueAdjustment] of entries) {
        const value = accumulator[key2];
        if (value != null) {
          accumulator[key2] = value + modifier * valueAdjustment;
        }
      }
      return accumulator;
    }, {
      ...object
    });
  };
}
var add = createAdjustmentFn(1);
var subtract = createAdjustmentFn(-1);
function hasViewportRelativeCoordinates(event) {
  return "clientX" in event && "clientY" in event;
}
function isKeyboardEvent(event) {
  if (!event) {
    return false;
  }
  const {
    KeyboardEvent
  } = getWindow(event.target);
  return KeyboardEvent && event instanceof KeyboardEvent;
}
function isTouchEvent(event) {
  if (!event) {
    return false;
  }
  const {
    TouchEvent
  } = getWindow(event.target);
  return TouchEvent && event instanceof TouchEvent;
}
function getEventCoordinates(event) {
  if (isTouchEvent(event)) {
    if (event.touches && event.touches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.touches[0];
      return {
        x,
        y
      };
    } else if (event.changedTouches && event.changedTouches.length) {
      const {
        clientX: x,
        clientY: y
      } = event.changedTouches[0];
      return {
        x,
        y
      };
    }
  }
  if (hasViewportRelativeCoordinates(event)) {
    return {
      x: event.clientX,
      y: event.clientY
    };
  }
  return null;
}
var CSS = Object.freeze({
  Translate: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        x,
        y
      } = transform;
      return "translate3d(" + (x ? Math.round(x) : 0) + "px, " + (y ? Math.round(y) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(transform) {
      if (!transform) {
        return;
      }
      const {
        scaleX,
        scaleY
      } = transform;
      return "scaleX(" + scaleX + ") scaleY(" + scaleY + ")";
    }
  },
  Transform: {
    toString(transform) {
      if (!transform) {
        return;
      }
      return [CSS.Translate.toString(transform), CSS.Scale.toString(transform)].join(" ");
    }
  },
  Transition: {
    toString(_ref) {
      let {
        property,
        duration,
        easing
      } = _ref;
      return property + " " + duration + "ms " + easing;
    }
  }
});
var SELECTOR = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function findFirstFocusableNode(element) {
  if (element.matches(SELECTOR)) {
    return element;
  }
  return element.querySelector(SELECTOR);
}

// node_modules/@dnd-kit/accessibility/dist/accessibility.esm.js
var import_react12 = __toESM(require_react());
var hiddenStyles = {
  display: "none"
};
function HiddenText(_ref) {
  let {
    id,
    value
  } = _ref;
  return import_react12.default.createElement("div", {
    id,
    style: hiddenStyles
  }, value);
}
var visuallyHidden = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function LiveRegion(_ref) {
  let {
    id,
    announcement
  } = _ref;
  return import_react12.default.createElement("div", {
    id,
    style: visuallyHidden,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": true
  }, announcement);
}
function useAnnouncement() {
  const [announcement, setAnnouncement] = (0, import_react12.useState)("");
  const announce = (0, import_react12.useCallback)((value) => {
    if (value != null) {
      setAnnouncement(value);
    }
  }, []);
  return {
    announce,
    announcement
  };
}

// node_modules/@dnd-kit/core/dist/core.esm.js
var DndMonitorContext = (0, import_react13.createContext)(null);
function useDndMonitor(listener) {
  const registerListener = (0, import_react13.useContext)(DndMonitorContext);
  (0, import_react13.useEffect)(() => {
    if (!registerListener) {
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    }
    const unsubscribe = registerListener(listener);
    return unsubscribe;
  }, [listener, registerListener]);
}
function useDndMonitorProvider() {
  const [listeners] = (0, import_react13.useState)(() => /* @__PURE__ */ new Set());
  const registerListener = (0, import_react13.useCallback)((listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  }, [listeners]);
  const dispatch = (0, import_react13.useCallback)((_ref) => {
    let {
      type,
      event
    } = _ref;
    listeners.forEach((listener) => {
      var _listener$type;
      return (_listener$type = listener[type]) == null ? void 0 : _listener$type.call(listener, event);
    });
  }, [listeners]);
  return [dispatch, registerListener];
}
var defaultScreenReaderInstructions = {
  draggable: "\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  "
};
var defaultAnnouncements = {
  onDragStart(_ref) {
    let {
      active
    } = _ref;
    return "Picked up draggable item " + active.id + ".";
  },
  onDragOver(_ref2) {
    let {
      active,
      over
    } = _ref2;
    if (over) {
      return "Draggable item " + active.id + " was moved over droppable area " + over.id + ".";
    }
    return "Draggable item " + active.id + " is no longer over a droppable area.";
  },
  onDragEnd(_ref3) {
    let {
      active,
      over
    } = _ref3;
    if (over) {
      return "Draggable item " + active.id + " was dropped over droppable area " + over.id;
    }
    return "Draggable item " + active.id + " was dropped.";
  },
  onDragCancel(_ref4) {
    let {
      active
    } = _ref4;
    return "Dragging was cancelled. Draggable item " + active.id + " was dropped.";
  }
};
function Accessibility(_ref) {
  let {
    announcements = defaultAnnouncements,
    container,
    hiddenTextDescribedById,
    screenReaderInstructions = defaultScreenReaderInstructions
  } = _ref;
  const {
    announce,
    announcement
  } = useAnnouncement();
  const liveRegionId = useUniqueId2("DndLiveRegion");
  const [mounted, setMounted] = (0, import_react13.useState)(false);
  (0, import_react13.useEffect)(() => {
    setMounted(true);
  }, []);
  useDndMonitor((0, import_react13.useMemo)(() => ({
    onDragStart(_ref2) {
      let {
        active
      } = _ref2;
      announce(announcements.onDragStart({
        active
      }));
    },
    onDragMove(_ref3) {
      let {
        active,
        over
      } = _ref3;
      if (announcements.onDragMove) {
        announce(announcements.onDragMove({
          active,
          over
        }));
      }
    },
    onDragOver(_ref4) {
      let {
        active,
        over
      } = _ref4;
      announce(announcements.onDragOver({
        active,
        over
      }));
    },
    onDragEnd(_ref5) {
      let {
        active,
        over
      } = _ref5;
      announce(announcements.onDragEnd({
        active,
        over
      }));
    },
    onDragCancel(_ref6) {
      let {
        active,
        over
      } = _ref6;
      announce(announcements.onDragCancel({
        active,
        over
      }));
    }
  }), [announce, announcements]));
  if (!mounted) {
    return null;
  }
  const markup = import_react13.default.createElement(import_react13.default.Fragment, null, import_react13.default.createElement(HiddenText, {
    id: hiddenTextDescribedById,
    value: screenReaderInstructions.draggable
  }), import_react13.default.createElement(LiveRegion, {
    id: liveRegionId,
    announcement
  }));
  return container ? (0, import_react_dom.createPortal)(markup, container) : markup;
}
var Action;
(function(Action2) {
  Action2["DragStart"] = "dragStart";
  Action2["DragMove"] = "dragMove";
  Action2["DragEnd"] = "dragEnd";
  Action2["DragCancel"] = "dragCancel";
  Action2["DragOver"] = "dragOver";
  Action2["RegisterDroppable"] = "registerDroppable";
  Action2["SetDroppableDisabled"] = "setDroppableDisabled";
  Action2["UnregisterDroppable"] = "unregisterDroppable";
})(Action || (Action = {}));
function noop() {
}
function useSensor(sensor, options) {
  return (0, import_react13.useMemo)(
    () => ({
      sensor,
      options: options != null ? options : {}
    }),
    [sensor, options]
  );
}
function useSensors() {
  for (var _len = arguments.length, sensors = new Array(_len), _key = 0; _key < _len; _key++) {
    sensors[_key] = arguments[_key];
  }
  return (0, import_react13.useMemo)(
    () => [...sensors].filter((sensor) => sensor != null),
    [...sensors]
  );
}
var defaultCoordinates = Object.freeze({
  x: 0,
  y: 0
});
function distanceBetween(p1, p2) {
  return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
}
function getRelativeTransformOrigin(event, rect) {
  const eventCoordinates = getEventCoordinates(event);
  if (!eventCoordinates) {
    return "0 0";
  }
  const transformOrigin = {
    x: (eventCoordinates.x - rect.left) / rect.width * 100,
    y: (eventCoordinates.y - rect.top) / rect.height * 100
  };
  return transformOrigin.x + "% " + transformOrigin.y + "%";
}
function sortCollisionsAsc(_ref, _ref2) {
  let {
    data: {
      value: a
    }
  } = _ref;
  let {
    data: {
      value: b
    }
  } = _ref2;
  return a - b;
}
function sortCollisionsDesc(_ref3, _ref4) {
  let {
    data: {
      value: a
    }
  } = _ref3;
  let {
    data: {
      value: b
    }
  } = _ref4;
  return b - a;
}
function getFirstCollision(collisions, property) {
  if (!collisions || collisions.length === 0) {
    return null;
  }
  const [firstCollision] = collisions;
  return property ? firstCollision[property] : firstCollision;
}
function centerOfRectangle(rect, left, top) {
  if (left === void 0) {
    left = rect.left;
  }
  if (top === void 0) {
    top = rect.top;
  }
  return {
    x: left + rect.width * 0.5,
    y: top + rect.height * 0.5
  };
}
var closestCenter = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const centerRect = centerOfRectangle(collisionRect, collisionRect.left, collisionRect.top);
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const distBetween = distanceBetween(centerOfRectangle(rect), centerRect);
      collisions.push({
        id,
        data: {
          droppableContainer,
          value: distBetween
        }
      });
    }
  }
  return collisions.sort(sortCollisionsAsc);
};
function getIntersectionRatio(entry, target) {
  const top = Math.max(target.top, entry.top);
  const left = Math.max(target.left, entry.left);
  const right = Math.min(target.left + target.width, entry.left + entry.width);
  const bottom = Math.min(target.top + target.height, entry.top + entry.height);
  const width = right - left;
  const height = bottom - top;
  if (left < right && top < bottom) {
    const targetArea = target.width * target.height;
    const entryArea = entry.width * entry.height;
    const intersectionArea = width * height;
    const intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
}
var rectIntersection = (_ref) => {
  let {
    collisionRect,
    droppableRects,
    droppableContainers
  } = _ref;
  const collisions = [];
  for (const droppableContainer of droppableContainers) {
    const {
      id
    } = droppableContainer;
    const rect = droppableRects.get(id);
    if (rect) {
      const intersectionRatio = getIntersectionRatio(rect, collisionRect);
      if (intersectionRatio > 0) {
        collisions.push({
          id,
          data: {
            droppableContainer,
            value: intersectionRatio
          }
        });
      }
    }
  }
  return collisions.sort(sortCollisionsDesc);
};
function adjustScale(transform, rect1, rect2) {
  return {
    ...transform,
    scaleX: rect1 && rect2 ? rect1.width / rect2.width : 1,
    scaleY: rect1 && rect2 ? rect1.height / rect2.height : 1
  };
}
function getRectDelta(rect1, rect2) {
  return rect1 && rect2 ? {
    x: rect1.left - rect2.left,
    y: rect1.top - rect2.top
  } : defaultCoordinates;
}
function createRectAdjustmentFn(modifier) {
  return function adjustClientRect(rect) {
    for (var _len = arguments.length, adjustments = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      adjustments[_key - 1] = arguments[_key];
    }
    return adjustments.reduce((acc, adjustment) => ({
      ...acc,
      top: acc.top + modifier * adjustment.y,
      bottom: acc.bottom + modifier * adjustment.y,
      left: acc.left + modifier * adjustment.x,
      right: acc.right + modifier * adjustment.x
    }), {
      ...rect
    });
  };
}
var getAdjustedRect = createRectAdjustmentFn(1);
function parseTransform(transform) {
  if (transform.startsWith("matrix3d(")) {
    const transformArray = transform.slice(9, -1).split(/, /);
    return {
      x: +transformArray[12],
      y: +transformArray[13],
      scaleX: +transformArray[0],
      scaleY: +transformArray[5]
    };
  } else if (transform.startsWith("matrix(")) {
    const transformArray = transform.slice(7, -1).split(/, /);
    return {
      x: +transformArray[4],
      y: +transformArray[5],
      scaleX: +transformArray[0],
      scaleY: +transformArray[3]
    };
  }
  return null;
}
function inverseTransform(rect, transform, transformOrigin) {
  const parsedTransform = parseTransform(transform);
  if (!parsedTransform) {
    return rect;
  }
  const {
    scaleX,
    scaleY,
    x: translateX,
    y: translateY
  } = parsedTransform;
  const x = rect.left - translateX - (1 - scaleX) * parseFloat(transformOrigin);
  const y = rect.top - translateY - (1 - scaleY) * parseFloat(transformOrigin.slice(transformOrigin.indexOf(" ") + 1));
  const w = scaleX ? rect.width / scaleX : rect.width;
  const h = scaleY ? rect.height / scaleY : rect.height;
  return {
    width: w,
    height: h,
    top: y,
    right: x + w,
    bottom: y + h,
    left: x
  };
}
var defaultOptions = {
  ignoreTransform: false
};
function getClientRect(element, options) {
  if (options === void 0) {
    options = defaultOptions;
  }
  let rect = element.getBoundingClientRect();
  if (options.ignoreTransform) {
    const {
      transform,
      transformOrigin
    } = getWindow(element).getComputedStyle(element);
    if (transform) {
      rect = inverseTransform(rect, transform, transformOrigin);
    }
  }
  const {
    top,
    left,
    width,
    height,
    bottom,
    right
  } = rect;
  return {
    top,
    left,
    width,
    height,
    bottom,
    right
  };
}
function getTransformAgnosticClientRect(element) {
  return getClientRect(element, {
    ignoreTransform: true
  });
}
function getWindowClientRect(element) {
  const width = element.innerWidth;
  const height = element.innerHeight;
  return {
    top: 0,
    left: 0,
    right: width,
    bottom: height,
    width,
    height
  };
}
function isFixed(node, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(node).getComputedStyle(node);
  }
  return computedStyle.position === "fixed";
}
function isScrollable(element, computedStyle) {
  if (computedStyle === void 0) {
    computedStyle = getWindow(element).getComputedStyle(element);
  }
  const overflowRegex = /(auto|scroll|overlay)/;
  const properties2 = ["overflow", "overflowX", "overflowY"];
  return properties2.some((property) => {
    const value = computedStyle[property];
    return typeof value === "string" ? overflowRegex.test(value) : false;
  });
}
function getScrollableAncestors(element, limit) {
  const scrollParents = [];
  function findScrollableAncestors(node) {
    if (limit != null && scrollParents.length >= limit) {
      return scrollParents;
    }
    if (!node) {
      return scrollParents;
    }
    if (isDocument(node) && node.scrollingElement != null && !scrollParents.includes(node.scrollingElement)) {
      scrollParents.push(node.scrollingElement);
      return scrollParents;
    }
    if (!isHTMLElement(node) || isSVGElement(node)) {
      return scrollParents;
    }
    if (scrollParents.includes(node)) {
      return scrollParents;
    }
    const computedStyle = getWindow(element).getComputedStyle(node);
    if (node !== element) {
      if (isScrollable(node, computedStyle)) {
        scrollParents.push(node);
      }
    }
    if (isFixed(node, computedStyle)) {
      return scrollParents;
    }
    return findScrollableAncestors(node.parentNode);
  }
  if (!element) {
    return scrollParents;
  }
  return findScrollableAncestors(element);
}
function getFirstScrollableAncestor(node) {
  const [firstScrollableAncestor] = getScrollableAncestors(node, 1);
  return firstScrollableAncestor != null ? firstScrollableAncestor : null;
}
function getScrollableElement(element) {
  if (!canUseDOM || !element) {
    return null;
  }
  if (isWindow(element)) {
    return element;
  }
  if (!isNode(element)) {
    return null;
  }
  if (isDocument(element) || element === getOwnerDocument(element).scrollingElement) {
    return window;
  }
  if (isHTMLElement(element)) {
    return element;
  }
  return null;
}
function getScrollXCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollX;
  }
  return element.scrollLeft;
}
function getScrollYCoordinate(element) {
  if (isWindow(element)) {
    return element.scrollY;
  }
  return element.scrollTop;
}
function getScrollCoordinates(element) {
  return {
    x: getScrollXCoordinate(element),
    y: getScrollYCoordinate(element)
  };
}
var Direction;
(function(Direction2) {
  Direction2[Direction2["Forward"] = 1] = "Forward";
  Direction2[Direction2["Backward"] = -1] = "Backward";
})(Direction || (Direction = {}));
function isDocumentScrollingElement(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
var defaultThreshold = {
  x: 0.2,
  y: 0.2
};
function getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, _ref, acceleration, thresholdPercentage) {
  let {
    top,
    left,
    right,
    bottom
  } = _ref;
  if (acceleration === void 0) {
    acceleration = 10;
  }
  if (thresholdPercentage === void 0) {
    thresholdPercentage = defaultThreshold;
  }
  const {
    isTop,
    isBottom,
    isLeft,
    isRight
  } = getScrollPosition(scrollContainer);
  const direction = {
    x: 0,
    y: 0
  };
  const speed = {
    x: 0,
    y: 0
  };
  const threshold = {
    height: scrollContainerRect.height * thresholdPercentage.y,
    width: scrollContainerRect.width * thresholdPercentage.x
  };
  if (!isTop && top <= scrollContainerRect.top + threshold.height) {
    direction.y = Direction.Backward;
    speed.y = acceleration * Math.abs((scrollContainerRect.top + threshold.height - top) / threshold.height);
  } else if (!isBottom && bottom >= scrollContainerRect.bottom - threshold.height) {
    direction.y = Direction.Forward;
    speed.y = acceleration * Math.abs((scrollContainerRect.bottom - threshold.height - bottom) / threshold.height);
  }
  if (!isRight && right >= scrollContainerRect.right - threshold.width) {
    direction.x = Direction.Forward;
    speed.x = acceleration * Math.abs((scrollContainerRect.right - threshold.width - right) / threshold.width);
  } else if (!isLeft && left <= scrollContainerRect.left + threshold.width) {
    direction.x = Direction.Backward;
    speed.x = acceleration * Math.abs((scrollContainerRect.left + threshold.width - left) / threshold.width);
  }
  return {
    direction,
    speed
  };
}
function getScrollElementRect(element) {
  if (element === document.scrollingElement) {
    const {
      innerWidth,
      innerHeight
    } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const {
    top,
    left,
    right,
    bottom
  } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getScrollOffsets(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return add(acc, getScrollCoordinates(node));
  }, defaultCoordinates);
}
function getScrollXOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollXCoordinate(node);
  }, 0);
}
function getScrollYOffset(scrollableAncestors) {
  return scrollableAncestors.reduce((acc, node) => {
    return acc + getScrollYCoordinate(node);
  }, 0);
}
function scrollIntoViewIfNeeded(element, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  if (!element) {
    return;
  }
  const {
    top,
    left,
    bottom,
    right
  } = measure(element);
  const firstScrollableAncestor = getFirstScrollableAncestor(element);
  if (!firstScrollableAncestor) {
    return;
  }
  if (bottom <= 0 || right <= 0 || top >= window.innerHeight || left >= window.innerWidth) {
    element.scrollIntoView({
      block: "center",
      inline: "center"
    });
  }
}
var properties = [["x", ["left", "right"], getScrollXOffset], ["y", ["top", "bottom"], getScrollYOffset]];
var Rect = class {
  constructor(rect, element) {
    this.rect = void 0;
    this.width = void 0;
    this.height = void 0;
    this.top = void 0;
    this.bottom = void 0;
    this.right = void 0;
    this.left = void 0;
    const scrollableAncestors = getScrollableAncestors(element);
    const scrollOffsets = getScrollOffsets(scrollableAncestors);
    this.rect = {
      ...rect
    };
    this.width = rect.width;
    this.height = rect.height;
    for (const [axis, keys, getScrollOffset] of properties) {
      for (const key2 of keys) {
        Object.defineProperty(this, key2, {
          get: () => {
            const currentOffsets = getScrollOffset(scrollableAncestors);
            const scrollOffsetsDeltla = scrollOffsets[axis] - currentOffsets;
            return this.rect[key2] + scrollOffsetsDeltla;
          },
          enumerable: true
        });
      }
    }
    Object.defineProperty(this, "rect", {
      enumerable: false
    });
  }
};
var Listeners = class {
  constructor(target) {
    this.target = void 0;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _this$target;
        return (_this$target = this.target) == null ? void 0 : _this$target.removeEventListener(...listener);
      });
    };
    this.target = target;
  }
  add(eventName, handler, options) {
    var _this$target2;
    (_this$target2 = this.target) == null ? void 0 : _this$target2.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
};
function getEventListenerTarget(target) {
  const {
    EventTarget
  } = getWindow(target);
  return target instanceof EventTarget ? target : getOwnerDocument(target);
}
function hasExceededDistance(delta, measurement) {
  const dx = Math.abs(delta.x);
  const dy = Math.abs(delta.y);
  if (typeof measurement === "number") {
    return Math.sqrt(dx ** 2 + dy ** 2) > measurement;
  }
  if ("x" in measurement && "y" in measurement) {
    return dx > measurement.x && dy > measurement.y;
  }
  if ("x" in measurement) {
    return dx > measurement.x;
  }
  if ("y" in measurement) {
    return dy > measurement.y;
  }
  return false;
}
var EventName;
(function(EventName3) {
  EventName3["Click"] = "click";
  EventName3["DragStart"] = "dragstart";
  EventName3["Keydown"] = "keydown";
  EventName3["ContextMenu"] = "contextmenu";
  EventName3["Resize"] = "resize";
  EventName3["SelectionChange"] = "selectionchange";
  EventName3["VisibilityChange"] = "visibilitychange";
})(EventName || (EventName = {}));
function preventDefault(event) {
  event.preventDefault();
}
function stopPropagation(event) {
  event.stopPropagation();
}
var KeyboardCode;
(function(KeyboardCode3) {
  KeyboardCode3["Space"] = "Space";
  KeyboardCode3["Down"] = "ArrowDown";
  KeyboardCode3["Right"] = "ArrowRight";
  KeyboardCode3["Left"] = "ArrowLeft";
  KeyboardCode3["Up"] = "ArrowUp";
  KeyboardCode3["Esc"] = "Escape";
  KeyboardCode3["Enter"] = "Enter";
})(KeyboardCode || (KeyboardCode = {}));
var defaultKeyboardCodes = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};
var defaultKeyboardCoordinateGetter = (event, _ref) => {
  let {
    currentCoordinates
  } = _ref;
  switch (event.code) {
    case KeyboardCode.Right:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x + 25
      };
    case KeyboardCode.Left:
      return {
        ...currentCoordinates,
        x: currentCoordinates.x - 25
      };
    case KeyboardCode.Down:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y + 25
      };
    case KeyboardCode.Up:
      return {
        ...currentCoordinates,
        y: currentCoordinates.y - 25
      };
  }
  return void 0;
};
var KeyboardSensor = class {
  constructor(props) {
    this.props = void 0;
    this.autoScrollEnabled = false;
    this.referenceCoordinates = void 0;
    this.listeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    const {
      event: {
        target
      }
    } = props;
    this.props = props;
    this.listeners = new Listeners(getOwnerDocument(target));
    this.windowListeners = new Listeners(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    this.handleStart();
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode,
      onStart
    } = this.props;
    const node = activeNode.node.current;
    if (node) {
      scrollIntoViewIfNeeded(node);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const {
        active,
        context,
        options
      } = this.props;
      const {
        keyboardCodes = defaultKeyboardCodes,
        coordinateGetter = defaultKeyboardCoordinateGetter,
        scrollBehavior = "smooth"
      } = options;
      const {
        code
      } = event;
      if (keyboardCodes.end.includes(code)) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.includes(code)) {
        this.handleCancel(event);
        return;
      }
      const {
        collisionRect
      } = context.current;
      const currentCoordinates = collisionRect ? {
        x: collisionRect.left,
        y: collisionRect.top
      } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
        const scrollDelta = {
          x: 0,
          y: 0
        };
        const {
          scrollableAncestors
        } = context.current;
        for (const scrollContainer of scrollableAncestors) {
          const direction = event.code;
          const {
            isTop,
            isRight,
            isLeft,
            isBottom,
            maxScroll,
            minScroll
          } = getScrollPosition(scrollContainer);
          const scrollElementRect = getScrollElementRect(scrollContainer);
          const clampedCoordinates = {
            x: Math.min(direction === KeyboardCode.Right ? scrollElementRect.right - scrollElementRect.width / 2 : scrollElementRect.right, Math.max(direction === KeyboardCode.Right ? scrollElementRect.left : scrollElementRect.left + scrollElementRect.width / 2, newCoordinates.x)),
            y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
          };
          const canScrollX = direction === KeyboardCode.Right && !isRight || direction === KeyboardCode.Left && !isLeft;
          const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
          if (canScrollX && clampedCoordinates.x !== newCoordinates.x) {
            const newScrollCoordinates = scrollContainer.scrollLeft + coordinatesDelta.x;
            const canScrollToNewCoordinates = direction === KeyboardCode.Right && newScrollCoordinates <= maxScroll.x || direction === KeyboardCode.Left && newScrollCoordinates >= minScroll.x;
            if (canScrollToNewCoordinates && !coordinatesDelta.y) {
              scrollContainer.scrollTo({
                left: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.x = scrollContainer.scrollLeft - newScrollCoordinates;
            } else {
              scrollDelta.x = direction === KeyboardCode.Right ? scrollContainer.scrollLeft - maxScroll.x : scrollContainer.scrollLeft - minScroll.x;
            }
            if (scrollDelta.x) {
              scrollContainer.scrollBy({
                left: -scrollDelta.x,
                behavior: scrollBehavior
              });
            }
            break;
          } else if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
            const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
            const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
            if (canScrollToNewCoordinates && !coordinatesDelta.x) {
              scrollContainer.scrollTo({
                top: newScrollCoordinates,
                behavior: scrollBehavior
              });
              return;
            }
            if (canScrollToNewCoordinates) {
              scrollDelta.y = scrollContainer.scrollTop - newScrollCoordinates;
            } else {
              scrollDelta.y = direction === KeyboardCode.Down ? scrollContainer.scrollTop - maxScroll.y : scrollContainer.scrollTop - minScroll.y;
            }
            if (scrollDelta.y) {
              scrollContainer.scrollBy({
                top: -scrollDelta.y,
                behavior: scrollBehavior
              });
            }
            break;
          }
        }
        this.handleMove(event, add(subtract(newCoordinates, this.referenceCoordinates), scrollDelta));
      }
    }
  }
  handleMove(event, coordinates) {
    const {
      onMove
    } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event) {
    const {
      onEnd
    } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const {
      onCancel
    } = this.props;
    event.preventDefault();
    this.detach();
    onCancel();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
};
KeyboardSensor.activators = [{
  eventName: "onKeyDown",
  handler: (event, _ref, _ref2) => {
    let {
      keyboardCodes = defaultKeyboardCodes,
      onActivation
    } = _ref;
    let {
      active
    } = _ref2;
    const {
      code
    } = event.nativeEvent;
    if (keyboardCodes.start.includes(code)) {
      const activator = active.activatorNode.current;
      if (activator && event.target !== activator) {
        return false;
      }
      event.preventDefault();
      onActivation == null ? void 0 : onActivation({
        event: event.nativeEvent
      });
      return true;
    }
    return false;
  }
}];
function isDistanceConstraint(constraint) {
  return Boolean(constraint && "distance" in constraint);
}
function isDelayConstraint(constraint) {
  return Boolean(constraint && "delay" in constraint);
}
var AbstractPointerSensor = class {
  constructor(props, events2, listenerTarget) {
    var _getEventCoordinates;
    if (listenerTarget === void 0) {
      listenerTarget = getEventListenerTarget(props.event.target);
    }
    this.props = void 0;
    this.events = void 0;
    this.autoScrollEnabled = true;
    this.document = void 0;
    this.activated = false;
    this.initialCoordinates = void 0;
    this.timeoutId = null;
    this.listeners = void 0;
    this.documentListeners = void 0;
    this.windowListeners = void 0;
    this.props = props;
    this.events = events2;
    const {
      event
    } = props;
    const {
      target
    } = event;
    this.props = props;
    this.events = events2;
    this.document = getOwnerDocument(target);
    this.documentListeners = new Listeners(this.document);
    this.listeners = new Listeners(listenerTarget);
    this.windowListeners = new Listeners(getWindow(target));
    this.initialCoordinates = (_getEventCoordinates = getEventCoordinates(event)) != null ? _getEventCoordinates : defaultCoordinates;
    this.handleStart = this.handleStart.bind(this);
    this.handleMove = this.handleMove.bind(this);
    this.handleEnd = this.handleEnd.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.handleKeydown = this.handleKeydown.bind(this);
    this.removeTextSelection = this.removeTextSelection.bind(this);
    this.attach();
  }
  attach() {
    const {
      events: events2,
      props: {
        options: {
          activationConstraint
        }
      }
    } = this;
    this.listeners.add(events2.move.name, this.handleMove, {
      passive: false
    });
    this.listeners.add(events2.end.name, this.handleEnd);
    this.windowListeners.add(EventName.Resize, this.handleCancel);
    this.windowListeners.add(EventName.DragStart, preventDefault);
    this.windowListeners.add(EventName.VisibilityChange, this.handleCancel);
    this.windowListeners.add(EventName.ContextMenu, preventDefault);
    this.documentListeners.add(EventName.Keydown, this.handleKeydown);
    if (activationConstraint) {
      if (isDistanceConstraint(activationConstraint)) {
        return;
      }
      if (isDelayConstraint(activationConstraint)) {
        this.timeoutId = setTimeout(this.handleStart, activationConstraint.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll();
    this.windowListeners.removeAll();
    setTimeout(this.documentListeners.removeAll, 50);
    if (this.timeoutId !== null) {
      clearTimeout(this.timeoutId);
      this.timeoutId = null;
    }
  }
  handleStart() {
    const {
      initialCoordinates
    } = this;
    const {
      onStart
    } = this.props;
    if (initialCoordinates) {
      this.activated = true;
      this.documentListeners.add(EventName.Click, stopPropagation, {
        capture: true
      });
      this.removeTextSelection();
      this.documentListeners.add(EventName.SelectionChange, this.removeTextSelection);
      onStart(initialCoordinates);
    }
  }
  handleMove(event) {
    var _getEventCoordinates2;
    const {
      activated,
      initialCoordinates,
      props
    } = this;
    const {
      onMove,
      options: {
        activationConstraint
      }
    } = props;
    if (!initialCoordinates) {
      return;
    }
    const coordinates = (_getEventCoordinates2 = getEventCoordinates(event)) != null ? _getEventCoordinates2 : defaultCoordinates;
    const delta = subtract(initialCoordinates, coordinates);
    if (!activated && activationConstraint) {
      if (isDelayConstraint(activationConstraint)) {
        if (hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        return;
      }
      if (isDistanceConstraint(activationConstraint)) {
        if (activationConstraint.tolerance != null && hasExceededDistance(delta, activationConstraint.tolerance)) {
          return this.handleCancel();
        }
        if (hasExceededDistance(delta, activationConstraint.distance)) {
          return this.handleStart();
        }
        return;
      }
    }
    if (event.cancelable) {
      event.preventDefault();
    }
    onMove(coordinates);
  }
  handleEnd() {
    const {
      onEnd
    } = this.props;
    this.detach();
    onEnd();
  }
  handleCancel() {
    const {
      onCancel
    } = this.props;
    this.detach();
    onCancel();
  }
  handleKeydown(event) {
    if (event.code === KeyboardCode.Esc) {
      this.handleCancel();
    }
  }
  removeTextSelection() {
    var _this$document$getSel;
    (_this$document$getSel = this.document.getSelection()) == null ? void 0 : _this$document$getSel.removeAllRanges();
  }
};
var events = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
var PointerSensor = class extends AbstractPointerSensor {
  constructor(props) {
    const {
      event
    } = props;
    const listenerTarget = getOwnerDocument(event.target);
    super(props, events, listenerTarget);
  }
};
PointerSensor.activators = [{
  eventName: "onPointerDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (!event.isPrimary || event.button !== 0) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$1 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var MouseButton;
(function(MouseButton2) {
  MouseButton2[MouseButton2["RightClick"] = 2] = "RightClick";
})(MouseButton || (MouseButton = {}));
var MouseSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$1, getOwnerDocument(props.event.target));
  }
};
MouseSensor.activators = [{
  eventName: "onMouseDown",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    if (event.button === MouseButton.RightClick) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var events$2 = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
var TouchSensor = class extends AbstractPointerSensor {
  constructor(props) {
    super(props, events$2);
  }
  static setup() {
    window.addEventListener(events$2.move.name, noop2, {
      capture: false,
      passive: false
    });
    return function teardown() {
      window.removeEventListener(events$2.move.name, noop2);
    };
    function noop2() {
    }
  }
};
TouchSensor.activators = [{
  eventName: "onTouchStart",
  handler: (_ref, _ref2) => {
    let {
      nativeEvent: event
    } = _ref;
    let {
      onActivation
    } = _ref2;
    const {
      touches
    } = event;
    if (touches.length > 1) {
      return false;
    }
    onActivation == null ? void 0 : onActivation({
      event
    });
    return true;
  }
}];
var AutoScrollActivator;
(function(AutoScrollActivator2) {
  AutoScrollActivator2[AutoScrollActivator2["Pointer"] = 0] = "Pointer";
  AutoScrollActivator2[AutoScrollActivator2["DraggableRect"] = 1] = "DraggableRect";
})(AutoScrollActivator || (AutoScrollActivator = {}));
var TraversalOrder;
(function(TraversalOrder2) {
  TraversalOrder2[TraversalOrder2["TreeOrder"] = 0] = "TreeOrder";
  TraversalOrder2[TraversalOrder2["ReversedTreeOrder"] = 1] = "ReversedTreeOrder";
})(TraversalOrder || (TraversalOrder = {}));
function useAutoScroller(_ref) {
  let {
    acceleration,
    activator = AutoScrollActivator.Pointer,
    canScroll,
    draggingRect,
    enabled,
    interval = 5,
    order = TraversalOrder.TreeOrder,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects,
    delta,
    threshold
  } = _ref;
  const scrollIntent = useScrollIntent({
    delta,
    disabled: !enabled
  });
  const [setAutoScrollInterval, clearAutoScrollInterval] = useInterval();
  const scrollSpeed = (0, import_react13.useRef)({
    x: 0,
    y: 0
  });
  const scrollDirection = (0, import_react13.useRef)({
    x: 0,
    y: 0
  });
  const rect = (0, import_react13.useMemo)(() => {
    switch (activator) {
      case AutoScrollActivator.Pointer:
        return pointerCoordinates ? {
          top: pointerCoordinates.y,
          bottom: pointerCoordinates.y,
          left: pointerCoordinates.x,
          right: pointerCoordinates.x
        } : null;
      case AutoScrollActivator.DraggableRect:
        return draggingRect;
    }
  }, [activator, draggingRect, pointerCoordinates]);
  const scrollContainerRef = (0, import_react13.useRef)(null);
  const autoScroll = (0, import_react13.useCallback)(() => {
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer) {
      return;
    }
    const scrollLeft = scrollSpeed.current.x * scrollDirection.current.x;
    const scrollTop = scrollSpeed.current.y * scrollDirection.current.y;
    scrollContainer.scrollBy(scrollLeft, scrollTop);
  }, []);
  const sortedScrollableAncestors = (0, import_react13.useMemo)(() => order === TraversalOrder.TreeOrder ? [...scrollableAncestors].reverse() : scrollableAncestors, [order, scrollableAncestors]);
  (0, import_react13.useEffect)(
    () => {
      if (!enabled || !scrollableAncestors.length || !rect) {
        clearAutoScrollInterval();
        return;
      }
      for (const scrollContainer of sortedScrollableAncestors) {
        if ((canScroll == null ? void 0 : canScroll(scrollContainer)) === false) {
          continue;
        }
        const index = scrollableAncestors.indexOf(scrollContainer);
        const scrollContainerRect = scrollableAncestorRects[index];
        if (!scrollContainerRect) {
          continue;
        }
        const {
          direction,
          speed
        } = getScrollDirectionAndSpeed(scrollContainer, scrollContainerRect, rect, acceleration, threshold);
        for (const axis of ["x", "y"]) {
          if (!scrollIntent[axis][direction[axis]]) {
            speed[axis] = 0;
            direction[axis] = 0;
          }
        }
        if (speed.x > 0 || speed.y > 0) {
          clearAutoScrollInterval();
          scrollContainerRef.current = scrollContainer;
          setAutoScrollInterval(autoScroll, interval);
          scrollSpeed.current = speed;
          scrollDirection.current = direction;
          return;
        }
      }
      scrollSpeed.current = {
        x: 0,
        y: 0
      };
      scrollDirection.current = {
        x: 0,
        y: 0
      };
      clearAutoScrollInterval();
    },
    [
      acceleration,
      autoScroll,
      canScroll,
      clearAutoScrollInterval,
      enabled,
      interval,
      JSON.stringify(rect),
      JSON.stringify(scrollIntent),
      setAutoScrollInterval,
      scrollableAncestors,
      sortedScrollableAncestors,
      scrollableAncestorRects,
      JSON.stringify(threshold)
    ]
  );
}
var defaultScrollIntent = {
  x: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  },
  y: {
    [Direction.Backward]: false,
    [Direction.Forward]: false
  }
};
function useScrollIntent(_ref2) {
  let {
    delta,
    disabled
  } = _ref2;
  const previousDelta = usePrevious(delta);
  return useLazyMemo((previousIntent) => {
    if (disabled || !previousDelta || !previousIntent) {
      return defaultScrollIntent;
    }
    const direction = {
      x: Math.sign(delta.x - previousDelta.x),
      y: Math.sign(delta.y - previousDelta.y)
    };
    return {
      x: {
        [Direction.Backward]: previousIntent.x[Direction.Backward] || direction.x === -1,
        [Direction.Forward]: previousIntent.x[Direction.Forward] || direction.x === 1
      },
      y: {
        [Direction.Backward]: previousIntent.y[Direction.Backward] || direction.y === -1,
        [Direction.Forward]: previousIntent.y[Direction.Forward] || direction.y === 1
      }
    };
  }, [disabled, delta, previousDelta]);
}
function useCachedNode(draggableNodes, id) {
  const draggableNode = id !== null ? draggableNodes.get(id) : void 0;
  const node = draggableNode ? draggableNode.node.current : null;
  return useLazyMemo((cachedNode) => {
    var _ref;
    if (id === null) {
      return null;
    }
    return (_ref = node != null ? node : cachedNode) != null ? _ref : null;
  }, [node, id]);
}
function useCombineActivators(sensors, getSyntheticHandler) {
  return (0, import_react13.useMemo)(() => sensors.reduce((accumulator, sensor) => {
    const {
      sensor: Sensor
    } = sensor;
    const sensorActivators = Sensor.activators.map((activator) => ({
      eventName: activator.eventName,
      handler: getSyntheticHandler(activator.handler, sensor)
    }));
    return [...accumulator, ...sensorActivators];
  }, []), [sensors, getSyntheticHandler]);
}
var MeasuringStrategy;
(function(MeasuringStrategy2) {
  MeasuringStrategy2[MeasuringStrategy2["Always"] = 0] = "Always";
  MeasuringStrategy2[MeasuringStrategy2["BeforeDragging"] = 1] = "BeforeDragging";
  MeasuringStrategy2[MeasuringStrategy2["WhileDragging"] = 2] = "WhileDragging";
})(MeasuringStrategy || (MeasuringStrategy = {}));
var MeasuringFrequency;
(function(MeasuringFrequency2) {
  MeasuringFrequency2["Optimized"] = "optimized";
})(MeasuringFrequency || (MeasuringFrequency = {}));
var defaultValue = /* @__PURE__ */ new Map();
function useDroppableMeasuring(containers, _ref) {
  let {
    dragging,
    dependencies,
    config
  } = _ref;
  const [queue, setQueue] = (0, import_react13.useState)(null);
  const {
    frequency,
    measure,
    strategy
  } = config;
  const containersRef = (0, import_react13.useRef)(containers);
  const disabled = isDisabled();
  const disabledRef = useLatestValue(disabled);
  const measureDroppableContainers = (0, import_react13.useCallback)(function(ids2) {
    if (ids2 === void 0) {
      ids2 = [];
    }
    if (disabledRef.current) {
      return;
    }
    setQueue((value) => {
      if (value === null) {
        return ids2;
      }
      return value.concat(ids2.filter((id) => !value.includes(id)));
    });
  }, [disabledRef]);
  const timeoutId = (0, import_react13.useRef)(null);
  const droppableRects = useLazyMemo((previousValue) => {
    if (disabled && !dragging) {
      return defaultValue;
    }
    if (!previousValue || previousValue === defaultValue || containersRef.current !== containers || queue != null) {
      const map = /* @__PURE__ */ new Map();
      for (let container of containers) {
        if (!container) {
          continue;
        }
        if (queue && queue.length > 0 && !queue.includes(container.id) && container.rect.current) {
          map.set(container.id, container.rect.current);
          continue;
        }
        const node = container.node.current;
        const rect = node ? new Rect(measure(node), node) : null;
        container.rect.current = rect;
        if (rect) {
          map.set(container.id, rect);
        }
      }
      return map;
    }
    return previousValue;
  }, [containers, queue, dragging, disabled, measure]);
  (0, import_react13.useEffect)(() => {
    containersRef.current = containers;
  }, [containers]);
  (0, import_react13.useEffect)(
    () => {
      if (disabled) {
        return;
      }
      measureDroppableContainers();
    },
    [dragging, disabled]
  );
  (0, import_react13.useEffect)(
    () => {
      if (queue && queue.length > 0) {
        setQueue(null);
      }
    },
    [JSON.stringify(queue)]
  );
  (0, import_react13.useEffect)(
    () => {
      if (disabled || typeof frequency !== "number" || timeoutId.current !== null) {
        return;
      }
      timeoutId.current = setTimeout(() => {
        measureDroppableContainers();
        timeoutId.current = null;
      }, frequency);
    },
    [frequency, disabled, measureDroppableContainers, ...dependencies]
  );
  return {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled: queue != null
  };
  function isDisabled() {
    switch (strategy) {
      case MeasuringStrategy.Always:
        return false;
      case MeasuringStrategy.BeforeDragging:
        return dragging;
      default:
        return !dragging;
    }
  }
}
function useInitialValue(value, computeFn) {
  return useLazyMemo((previousValue) => {
    if (!value) {
      return null;
    }
    if (previousValue) {
      return previousValue;
    }
    return typeof computeFn === "function" ? computeFn(value) : value;
  }, [computeFn, value]);
}
function useInitialRect(node, measure) {
  return useInitialValue(node, measure);
}
function useMutationObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleMutations = useEvent(callback);
  const mutationObserver = (0, import_react13.useMemo)(() => {
    if (disabled || typeof window === "undefined" || typeof window.MutationObserver === "undefined") {
      return void 0;
    }
    const {
      MutationObserver
    } = window;
    return new MutationObserver(handleMutations);
  }, [handleMutations, disabled]);
  (0, import_react13.useEffect)(() => {
    return () => mutationObserver == null ? void 0 : mutationObserver.disconnect();
  }, [mutationObserver]);
  return mutationObserver;
}
function useResizeObserver(_ref) {
  let {
    callback,
    disabled
  } = _ref;
  const handleResize = useEvent(callback);
  const resizeObserver = (0, import_react13.useMemo)(
    () => {
      if (disabled || typeof window === "undefined" || typeof window.ResizeObserver === "undefined") {
        return void 0;
      }
      const {
        ResizeObserver
      } = window;
      return new ResizeObserver(handleResize);
    },
    [disabled]
  );
  (0, import_react13.useEffect)(() => {
    return () => resizeObserver == null ? void 0 : resizeObserver.disconnect();
  }, [resizeObserver]);
  return resizeObserver;
}
function defaultMeasure(element) {
  return new Rect(getClientRect(element), element);
}
function useRect(element, measure, fallbackRect) {
  if (measure === void 0) {
    measure = defaultMeasure;
  }
  const [rect, measureRect] = (0, import_react13.useReducer)(reducer2, null);
  const mutationObserver = useMutationObserver({
    callback(records) {
      if (!element) {
        return;
      }
      for (const record of records) {
        const {
          type,
          target
        } = record;
        if (type === "childList" && target instanceof HTMLElement && target.contains(element)) {
          measureRect();
          break;
        }
      }
    }
  });
  const resizeObserver = useResizeObserver({
    callback: measureRect
  });
  useIsomorphicLayoutEffect(() => {
    measureRect();
    if (element) {
      resizeObserver == null ? void 0 : resizeObserver.observe(element);
      mutationObserver == null ? void 0 : mutationObserver.observe(document.body, {
        childList: true,
        subtree: true
      });
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      mutationObserver == null ? void 0 : mutationObserver.disconnect();
    }
  }, [element]);
  return rect;
  function reducer2(currentRect) {
    if (!element) {
      return null;
    }
    if (element.isConnected === false) {
      var _ref;
      return (_ref = currentRect != null ? currentRect : fallbackRect) != null ? _ref : null;
    }
    const newRect = measure(element);
    if (JSON.stringify(currentRect) === JSON.stringify(newRect)) {
      return currentRect;
    }
    return newRect;
  }
}
function useRectDelta(rect) {
  const initialRect = useInitialValue(rect);
  return getRectDelta(rect, initialRect);
}
var defaultValue$1 = [];
function useScrollableAncestors(node) {
  const previousNode = (0, import_react13.useRef)(node);
  const ancestors = useLazyMemo((previousValue) => {
    if (!node) {
      return defaultValue$1;
    }
    if (previousValue && previousValue !== defaultValue$1 && node && previousNode.current && node.parentNode === previousNode.current.parentNode) {
      return previousValue;
    }
    return getScrollableAncestors(node);
  }, [node]);
  (0, import_react13.useEffect)(() => {
    previousNode.current = node;
  }, [node]);
  return ancestors;
}
function useScrollOffsets(elements) {
  const [scrollCoordinates, setScrollCoordinates] = (0, import_react13.useState)(null);
  const prevElements = (0, import_react13.useRef)(elements);
  const handleScroll = (0, import_react13.useCallback)((event) => {
    const scrollingElement = getScrollableElement(event.target);
    if (!scrollingElement) {
      return;
    }
    setScrollCoordinates((scrollCoordinates2) => {
      if (!scrollCoordinates2) {
        return null;
      }
      scrollCoordinates2.set(scrollingElement, getScrollCoordinates(scrollingElement));
      return new Map(scrollCoordinates2);
    });
  }, []);
  (0, import_react13.useEffect)(() => {
    const previousElements = prevElements.current;
    if (elements !== previousElements) {
      cleanup(previousElements);
      const entries = elements.map((element) => {
        const scrollableElement = getScrollableElement(element);
        if (scrollableElement) {
          scrollableElement.addEventListener("scroll", handleScroll, {
            passive: true
          });
          return [scrollableElement, getScrollCoordinates(scrollableElement)];
        }
        return null;
      }).filter((entry) => entry != null);
      setScrollCoordinates(entries.length ? new Map(entries) : null);
      prevElements.current = elements;
    }
    return () => {
      cleanup(elements);
      cleanup(previousElements);
    };
    function cleanup(elements2) {
      elements2.forEach((element) => {
        const scrollableElement = getScrollableElement(element);
        scrollableElement == null ? void 0 : scrollableElement.removeEventListener("scroll", handleScroll);
      });
    }
  }, [handleScroll, elements]);
  return (0, import_react13.useMemo)(() => {
    if (elements.length) {
      return scrollCoordinates ? Array.from(scrollCoordinates.values()).reduce((acc, coordinates) => add(acc, coordinates), defaultCoordinates) : getScrollOffsets(elements);
    }
    return defaultCoordinates;
  }, [elements, scrollCoordinates]);
}
function useScrollOffsetsDelta(scrollOffsets, dependencies) {
  if (dependencies === void 0) {
    dependencies = [];
  }
  const initialScrollOffsets = (0, import_react13.useRef)(null);
  (0, import_react13.useEffect)(
    () => {
      initialScrollOffsets.current = null;
    },
    dependencies
  );
  (0, import_react13.useEffect)(() => {
    const hasScrollOffsets = scrollOffsets !== defaultCoordinates;
    if (hasScrollOffsets && !initialScrollOffsets.current) {
      initialScrollOffsets.current = scrollOffsets;
    }
    if (!hasScrollOffsets && initialScrollOffsets.current) {
      initialScrollOffsets.current = null;
    }
  }, [scrollOffsets]);
  return initialScrollOffsets.current ? subtract(scrollOffsets, initialScrollOffsets.current) : defaultCoordinates;
}
function useSensorSetup(sensors) {
  (0, import_react13.useEffect)(
    () => {
      if (!canUseDOM) {
        return;
      }
      const teardownFns = sensors.map((_ref) => {
        let {
          sensor
        } = _ref;
        return sensor.setup == null ? void 0 : sensor.setup();
      });
      return () => {
        for (const teardown of teardownFns) {
          teardown == null ? void 0 : teardown();
        }
      };
    },
    sensors.map((_ref2) => {
      let {
        sensor
      } = _ref2;
      return sensor;
    })
  );
}
function useSyntheticListeners(listeners, id) {
  return (0, import_react13.useMemo)(() => {
    return listeners.reduce((acc, _ref) => {
      let {
        eventName,
        handler
      } = _ref;
      acc[eventName] = (event) => {
        handler(event, id);
      };
      return acc;
    }, {});
  }, [listeners, id]);
}
function useWindowRect(element) {
  return (0, import_react13.useMemo)(() => element ? getWindowClientRect(element) : null, [element]);
}
var defaultValue$2 = [];
function useRects(elements, measure) {
  if (measure === void 0) {
    measure = getClientRect;
  }
  const [firstElement] = elements;
  const windowRect = useWindowRect(firstElement ? getWindow(firstElement) : null);
  const [rects, measureRects] = (0, import_react13.useReducer)(reducer2, defaultValue$2);
  const resizeObserver = useResizeObserver({
    callback: measureRects
  });
  if (elements.length > 0 && rects === defaultValue$2) {
    measureRects();
  }
  useIsomorphicLayoutEffect(() => {
    if (elements.length) {
      elements.forEach((element) => resizeObserver == null ? void 0 : resizeObserver.observe(element));
    } else {
      resizeObserver == null ? void 0 : resizeObserver.disconnect();
      measureRects();
    }
  }, [elements]);
  return rects;
  function reducer2() {
    if (!elements.length) {
      return defaultValue$2;
    }
    return elements.map((element) => isDocumentScrollingElement(element) ? windowRect : new Rect(measure(element), element));
  }
}
function getMeasurableNode(node) {
  if (!node) {
    return null;
  }
  if (node.children.length > 1) {
    return node;
  }
  const firstChild = node.children[0];
  return isHTMLElement(firstChild) ? firstChild : node;
}
function useDragOverlayMeasuring(_ref) {
  let {
    measure
  } = _ref;
  const [rect, setRect] = (0, import_react13.useState)(null);
  const handleResize = (0, import_react13.useCallback)((entries) => {
    for (const {
      target
    } of entries) {
      if (isHTMLElement(target)) {
        setRect((rect2) => {
          const newRect = measure(target);
          return rect2 ? {
            ...rect2,
            width: newRect.width,
            height: newRect.height
          } : newRect;
        });
        break;
      }
    }
  }, [measure]);
  const resizeObserver = useResizeObserver({
    callback: handleResize
  });
  const handleNodeChange = (0, import_react13.useCallback)((element) => {
    const node = getMeasurableNode(element);
    resizeObserver == null ? void 0 : resizeObserver.disconnect();
    if (node) {
      resizeObserver == null ? void 0 : resizeObserver.observe(node);
    }
    setRect(node ? measure(node) : null);
  }, [measure, resizeObserver]);
  const [nodeRef, setRef] = useNodeRef(handleNodeChange);
  return (0, import_react13.useMemo)(() => ({
    nodeRef,
    rect,
    setRef
  }), [rect, nodeRef, setRef]);
}
var defaultSensors = [{
  sensor: PointerSensor,
  options: {}
}, {
  sensor: KeyboardSensor,
  options: {}
}];
var defaultData = {
  current: {}
};
var defaultMeasuringConfiguration = {
  draggable: {
    measure: getTransformAgnosticClientRect
  },
  droppable: {
    measure: getTransformAgnosticClientRect,
    strategy: MeasuringStrategy.WhileDragging,
    frequency: MeasuringFrequency.Optimized
  },
  dragOverlay: {
    measure: getClientRect
  }
};
var DroppableContainersMap = class extends Map {
  get(id) {
    var _super$get;
    return id != null ? (_super$get = super.get(id)) != null ? _super$get : void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((_ref) => {
      let {
        disabled
      } = _ref;
      return !disabled;
    });
  }
  getNodeFor(id) {
    var _this$get$node$curren, _this$get;
    return (_this$get$node$curren = (_this$get = this.get(id)) == null ? void 0 : _this$get.node.current) != null ? _this$get$node$curren : void 0;
  }
};
var defaultPublicContext = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: new DroppableContainersMap(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: noop
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: defaultMeasuringConfiguration,
  measureDroppableContainers: noop,
  windowRect: null,
  measuringScheduled: false
};
var defaultInternalContext = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: noop,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: noop
};
var InternalContext = (0, import_react13.createContext)(defaultInternalContext);
var PublicContext = (0, import_react13.createContext)(defaultPublicContext);
function getInitialState() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new DroppableContainersMap()
    }
  };
}
function reducer(state, action) {
  switch (action.type) {
    case Action.DragStart:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          initialCoordinates: action.initialCoordinates,
          active: action.active
        }
      };
    case Action.DragMove:
      if (!state.draggable.active) {
        return state;
      }
      return {
        ...state,
        draggable: {
          ...state.draggable,
          translate: {
            x: action.coordinates.x - state.draggable.initialCoordinates.x,
            y: action.coordinates.y - state.draggable.initialCoordinates.y
          }
        }
      };
    case Action.DragEnd:
    case Action.DragCancel:
      return {
        ...state,
        draggable: {
          ...state.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Action.RegisterDroppable: {
      const {
        element
      } = action;
      const {
        id
      } = element;
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, element);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.SetDroppableDisabled: {
      const {
        id,
        key: key2,
        disabled
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.set(id, {
        ...element,
        disabled
      });
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    case Action.UnregisterDroppable: {
      const {
        id,
        key: key2
      } = action;
      const element = state.droppable.containers.get(id);
      if (!element || key2 !== element.key) {
        return state;
      }
      const containers = new DroppableContainersMap(state.droppable.containers);
      containers.delete(id);
      return {
        ...state,
        droppable: {
          ...state.droppable,
          containers
        }
      };
    }
    default: {
      return state;
    }
  }
}
function RestoreFocus(_ref) {
  let {
    disabled
  } = _ref;
  const {
    active,
    activatorEvent,
    draggableNodes
  } = (0, import_react13.useContext)(InternalContext);
  const previousActivatorEvent = usePrevious(activatorEvent);
  const previousActiveId = usePrevious(active == null ? void 0 : active.id);
  (0, import_react13.useEffect)(() => {
    if (disabled) {
      return;
    }
    if (!activatorEvent && previousActivatorEvent && previousActiveId != null) {
      if (!isKeyboardEvent(previousActivatorEvent)) {
        return;
      }
      if (document.activeElement === previousActivatorEvent.target) {
        return;
      }
      const draggableNode = draggableNodes.get(previousActiveId);
      if (!draggableNode) {
        return;
      }
      const {
        activatorNode,
        node
      } = draggableNode;
      if (!activatorNode.current && !node.current) {
        return;
      }
      requestAnimationFrame(() => {
        for (const element of [activatorNode.current, node.current]) {
          if (!element) {
            continue;
          }
          const focusableNode = findFirstFocusableNode(element);
          if (focusableNode) {
            focusableNode.focus();
            break;
          }
        }
      });
    }
  }, [activatorEvent, disabled, draggableNodes, previousActiveId, previousActivatorEvent]);
  return null;
}
function applyModifiers(modifiers, _ref) {
  let {
    transform,
    ...args
  } = _ref;
  return modifiers != null && modifiers.length ? modifiers.reduce((accumulator, modifier) => {
    return modifier({
      transform: accumulator,
      ...args
    });
  }, transform) : transform;
}
function useMeasuringConfiguration(config) {
  return (0, import_react13.useMemo)(
    () => ({
      draggable: {
        ...defaultMeasuringConfiguration.draggable,
        ...config == null ? void 0 : config.draggable
      },
      droppable: {
        ...defaultMeasuringConfiguration.droppable,
        ...config == null ? void 0 : config.droppable
      },
      dragOverlay: {
        ...defaultMeasuringConfiguration.dragOverlay,
        ...config == null ? void 0 : config.dragOverlay
      }
    }),
    [config == null ? void 0 : config.draggable, config == null ? void 0 : config.droppable, config == null ? void 0 : config.dragOverlay]
  );
}
function useLayoutShiftScrollCompensation(_ref) {
  let {
    activeNode,
    measure,
    initialRect,
    config = true
  } = _ref;
  const initialized = (0, import_react13.useRef)(false);
  const {
    x,
    y
  } = typeof config === "boolean" ? {
    x: config,
    y: config
  } : config;
  useIsomorphicLayoutEffect(() => {
    const disabled = !x && !y;
    if (disabled || !activeNode) {
      initialized.current = false;
      return;
    }
    if (initialized.current || !initialRect) {
      return;
    }
    const node = activeNode == null ? void 0 : activeNode.node.current;
    if (!node || node.isConnected === false) {
      return;
    }
    const rect = measure(node);
    const rectDelta = getRectDelta(rect, initialRect);
    if (!x) {
      rectDelta.x = 0;
    }
    if (!y) {
      rectDelta.y = 0;
    }
    initialized.current = true;
    if (Math.abs(rectDelta.x) > 0 || Math.abs(rectDelta.y) > 0) {
      const firstScrollableAncestor = getFirstScrollableAncestor(node);
      if (firstScrollableAncestor) {
        firstScrollableAncestor.scrollBy({
          top: rectDelta.y,
          left: rectDelta.x
        });
      }
    }
  }, [activeNode, x, y, initialRect, measure]);
}
var ActiveDraggableContext = (0, import_react13.createContext)({
  ...defaultCoordinates,
  scaleX: 1,
  scaleY: 1
});
var Status;
(function(Status2) {
  Status2[Status2["Uninitialized"] = 0] = "Uninitialized";
  Status2[Status2["Initializing"] = 1] = "Initializing";
  Status2[Status2["Initialized"] = 2] = "Initialized";
})(Status || (Status = {}));
var DndContext = (0, import_react13.memo)(function DndContext2(_ref) {
  var _sensorContext$curren, _dragOverlay$nodeRef$, _dragOverlay$rect, _over$rect;
  let {
    id,
    accessibility,
    autoScroll = true,
    children,
    sensors = defaultSensors,
    collisionDetection = rectIntersection,
    measuring,
    modifiers,
    ...props
  } = _ref;
  const store = (0, import_react13.useReducer)(reducer, void 0, getInitialState);
  const [state, dispatch] = store;
  const [dispatchMonitorEvent, registerMonitorListener] = useDndMonitorProvider();
  const [status, setStatus] = (0, import_react13.useState)(Status.Uninitialized);
  const isInitialized = status === Status.Initialized;
  const {
    draggable: {
      active: activeId,
      nodes: draggableNodes,
      translate
    },
    droppable: {
      containers: droppableContainers
    }
  } = state;
  const node = activeId ? draggableNodes.get(activeId) : null;
  const activeRects = (0, import_react13.useRef)({
    initial: null,
    translated: null
  });
  const active = (0, import_react13.useMemo)(() => {
    var _node$data;
    return activeId != null ? {
      id: activeId,
      data: (_node$data = node == null ? void 0 : node.data) != null ? _node$data : defaultData,
      rect: activeRects
    } : null;
  }, [activeId, node]);
  const activeRef = (0, import_react13.useRef)(null);
  const [activeSensor, setActiveSensor] = (0, import_react13.useState)(null);
  const [activatorEvent, setActivatorEvent] = (0, import_react13.useState)(null);
  const latestProps = useLatestValue(props, Object.values(props));
  const draggableDescribedById = useUniqueId2("DndDescribedBy", id);
  const enabledDroppableContainers = (0, import_react13.useMemo)(() => droppableContainers.getEnabled(), [droppableContainers]);
  const measuringConfiguration = useMeasuringConfiguration(measuring);
  const {
    droppableRects,
    measureDroppableContainers,
    measuringScheduled
  } = useDroppableMeasuring(enabledDroppableContainers, {
    dragging: isInitialized,
    dependencies: [translate.x, translate.y],
    config: measuringConfiguration.droppable
  });
  const activeNode = useCachedNode(draggableNodes, activeId);
  const activationCoordinates = (0, import_react13.useMemo)(() => activatorEvent ? getEventCoordinates(activatorEvent) : null, [activatorEvent]);
  const autoScrollOptions = getAutoScrollerOptions();
  const initialActiveNodeRect = useInitialRect(activeNode, measuringConfiguration.draggable.measure);
  useLayoutShiftScrollCompensation({
    activeNode: activeId ? draggableNodes.get(activeId) : null,
    config: autoScrollOptions.layoutShiftCompensation,
    initialRect: initialActiveNodeRect,
    measure: measuringConfiguration.draggable.measure
  });
  const activeNodeRect = useRect(activeNode, measuringConfiguration.draggable.measure, initialActiveNodeRect);
  const containerNodeRect = useRect(activeNode ? activeNode.parentElement : null);
  const sensorContext = (0, import_react13.useRef)({
    activatorEvent: null,
    active: null,
    activeNode,
    collisionRect: null,
    collisions: null,
    droppableRects,
    draggableNodes,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  });
  const overNode = droppableContainers.getNodeFor((_sensorContext$curren = sensorContext.current.over) == null ? void 0 : _sensorContext$curren.id);
  const dragOverlay = useDragOverlayMeasuring({
    measure: measuringConfiguration.dragOverlay.measure
  });
  const draggingNode = (_dragOverlay$nodeRef$ = dragOverlay.nodeRef.current) != null ? _dragOverlay$nodeRef$ : activeNode;
  const draggingNodeRect = isInitialized ? (_dragOverlay$rect = dragOverlay.rect) != null ? _dragOverlay$rect : activeNodeRect : null;
  const usesDragOverlay = Boolean(dragOverlay.nodeRef.current && dragOverlay.rect);
  const nodeRectDelta = useRectDelta(usesDragOverlay ? null : activeNodeRect);
  const windowRect = useWindowRect(draggingNode ? getWindow(draggingNode) : null);
  const scrollableAncestors = useScrollableAncestors(isInitialized ? overNode != null ? overNode : activeNode : null);
  const scrollableAncestorRects = useRects(scrollableAncestors);
  const modifiedTranslate = applyModifiers(modifiers, {
    transform: {
      x: translate.x - nodeRectDelta.x,
      y: translate.y - nodeRectDelta.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect,
    over: sensorContext.current.over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  });
  const pointerCoordinates = activationCoordinates ? add(activationCoordinates, translate) : null;
  const scrollOffsets = useScrollOffsets(scrollableAncestors);
  const scrollAdjustment = useScrollOffsetsDelta(scrollOffsets);
  const activeNodeScrollDelta = useScrollOffsetsDelta(scrollOffsets, [activeNodeRect]);
  const scrollAdjustedTranslate = add(modifiedTranslate, scrollAdjustment);
  const collisionRect = draggingNodeRect ? getAdjustedRect(draggingNodeRect, modifiedTranslate) : null;
  const collisions = active && collisionRect ? collisionDetection({
    active,
    collisionRect,
    droppableRects,
    droppableContainers: enabledDroppableContainers,
    pointerCoordinates
  }) : null;
  const overId = getFirstCollision(collisions, "id");
  const [over, setOver] = (0, import_react13.useState)(null);
  const appliedTranslate = usesDragOverlay ? modifiedTranslate : add(modifiedTranslate, activeNodeScrollDelta);
  const transform = adjustScale(appliedTranslate, (_over$rect = over == null ? void 0 : over.rect) != null ? _over$rect : null, activeNodeRect);
  const instantiateSensor = (0, import_react13.useCallback)(
    (event, _ref2) => {
      let {
        sensor: Sensor,
        options
      } = _ref2;
      if (activeRef.current == null) {
        return;
      }
      const activeNode2 = draggableNodes.get(activeRef.current);
      if (!activeNode2) {
        return;
      }
      const activatorEvent2 = event.nativeEvent;
      const sensorInstance = new Sensor({
        active: activeRef.current,
        activeNode: activeNode2,
        event: activatorEvent2,
        options,
        context: sensorContext,
        onStart(initialCoordinates) {
          const id2 = activeRef.current;
          if (id2 == null) {
            return;
          }
          const draggableNode = draggableNodes.get(id2);
          if (!draggableNode) {
            return;
          }
          const {
            onDragStart
          } = latestProps.current;
          const event2 = {
            active: {
              id: id2,
              data: draggableNode.data,
              rect: activeRects
            }
          };
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            onDragStart == null ? void 0 : onDragStart(event2);
            setStatus(Status.Initializing);
            dispatch({
              type: Action.DragStart,
              initialCoordinates,
              active: id2
            });
            dispatchMonitorEvent({
              type: "onDragStart",
              event: event2
            });
          });
        },
        onMove(coordinates) {
          dispatch({
            type: Action.DragMove,
            coordinates
          });
        },
        onEnd: createHandler(Action.DragEnd),
        onCancel: createHandler(Action.DragCancel)
      });
      (0, import_react_dom.unstable_batchedUpdates)(() => {
        setActiveSensor(sensorInstance);
        setActivatorEvent(event.nativeEvent);
      });
      function createHandler(type) {
        return async function handler() {
          const {
            active: active2,
            collisions: collisions2,
            over: over2,
            scrollAdjustedTranslate: scrollAdjustedTranslate2
          } = sensorContext.current;
          let event2 = null;
          if (active2 && scrollAdjustedTranslate2) {
            const {
              cancelDrop
            } = latestProps.current;
            event2 = {
              activatorEvent: activatorEvent2,
              active: active2,
              collisions: collisions2,
              delta: scrollAdjustedTranslate2,
              over: over2
            };
            if (type === Action.DragEnd && typeof cancelDrop === "function") {
              const shouldCancel = await Promise.resolve(cancelDrop(event2));
              if (shouldCancel) {
                type = Action.DragCancel;
              }
            }
          }
          activeRef.current = null;
          (0, import_react_dom.unstable_batchedUpdates)(() => {
            dispatch({
              type
            });
            setStatus(Status.Uninitialized);
            setOver(null);
            setActiveSensor(null);
            setActivatorEvent(null);
            const eventName = type === Action.DragEnd ? "onDragEnd" : "onDragCancel";
            if (event2) {
              const handler2 = latestProps.current[eventName];
              handler2 == null ? void 0 : handler2(event2);
              dispatchMonitorEvent({
                type: eventName,
                event: event2
              });
            }
          });
        };
      }
    },
    [draggableNodes]
  );
  const bindActivatorToSensorInstantiator = (0, import_react13.useCallback)((handler, sensor) => {
    return (event, active2) => {
      const nativeEvent = event.nativeEvent;
      const activeDraggableNode = draggableNodes.get(active2);
      if (activeRef.current !== null || !activeDraggableNode || nativeEvent.dndKit || nativeEvent.defaultPrevented) {
        return;
      }
      const activationContext = {
        active: activeDraggableNode
      };
      const shouldActivate = handler(event, sensor.options, activationContext);
      if (shouldActivate === true) {
        nativeEvent.dndKit = {
          capturedBy: sensor.sensor
        };
        activeRef.current = active2;
        instantiateSensor(event, sensor);
      }
    };
  }, [draggableNodes, instantiateSensor]);
  const activators = useCombineActivators(sensors, bindActivatorToSensorInstantiator);
  useSensorSetup(sensors);
  useIsomorphicLayoutEffect(() => {
    if (activeNodeRect && status === Status.Initializing) {
      setStatus(Status.Initialized);
    }
  }, [activeNodeRect, status]);
  (0, import_react13.useEffect)(
    () => {
      const {
        onDragMove
      } = latestProps.current;
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        over: over2
      } = sensorContext.current;
      if (!active2 || !activatorEvent2) {
        return;
      }
      const event = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate.x,
          y: scrollAdjustedTranslate.y
        },
        over: over2
      };
      (0, import_react_dom.unstable_batchedUpdates)(() => {
        onDragMove == null ? void 0 : onDragMove(event);
        dispatchMonitorEvent({
          type: "onDragMove",
          event
        });
      });
    },
    [scrollAdjustedTranslate.x, scrollAdjustedTranslate.y]
  );
  (0, import_react13.useEffect)(
    () => {
      const {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        droppableContainers: droppableContainers2,
        scrollAdjustedTranslate: scrollAdjustedTranslate2
      } = sensorContext.current;
      if (!active2 || activeRef.current == null || !activatorEvent2 || !scrollAdjustedTranslate2) {
        return;
      }
      const {
        onDragOver
      } = latestProps.current;
      const overContainer = droppableContainers2.get(overId);
      const over2 = overContainer && overContainer.rect.current ? {
        id: overContainer.id,
        rect: overContainer.rect.current,
        data: overContainer.data,
        disabled: overContainer.disabled
      } : null;
      const event = {
        active: active2,
        activatorEvent: activatorEvent2,
        collisions: collisions2,
        delta: {
          x: scrollAdjustedTranslate2.x,
          y: scrollAdjustedTranslate2.y
        },
        over: over2
      };
      (0, import_react_dom.unstable_batchedUpdates)(() => {
        setOver(over2);
        onDragOver == null ? void 0 : onDragOver(event);
        dispatchMonitorEvent({
          type: "onDragOver",
          event
        });
      });
    },
    [overId]
  );
  useIsomorphicLayoutEffect(() => {
    sensorContext.current = {
      activatorEvent,
      active,
      activeNode,
      collisionRect,
      collisions,
      droppableRects,
      draggableNodes,
      draggingNode,
      draggingNodeRect,
      droppableContainers,
      over,
      scrollableAncestors,
      scrollAdjustedTranslate
    };
    activeRects.current = {
      initial: draggingNodeRect,
      translated: collisionRect
    };
  }, [active, activeNode, collisions, collisionRect, draggableNodes, draggingNode, draggingNodeRect, droppableRects, droppableContainers, over, scrollableAncestors, scrollAdjustedTranslate]);
  useAutoScroller({
    ...autoScrollOptions,
    delta: translate,
    draggingRect: collisionRect,
    pointerCoordinates,
    scrollableAncestors,
    scrollableAncestorRects
  });
  const publicContext = (0, import_react13.useMemo)(() => {
    const context = {
      active,
      activeNode,
      activeNodeRect,
      activatorEvent,
      collisions,
      containerNodeRect,
      dragOverlay,
      draggableNodes,
      droppableContainers,
      droppableRects,
      over,
      measureDroppableContainers,
      scrollableAncestors,
      scrollableAncestorRects,
      measuringConfiguration,
      measuringScheduled,
      windowRect
    };
    return context;
  }, [active, activeNode, activeNodeRect, activatorEvent, collisions, containerNodeRect, dragOverlay, draggableNodes, droppableContainers, droppableRects, over, measureDroppableContainers, scrollableAncestors, scrollableAncestorRects, measuringConfiguration, measuringScheduled, windowRect]);
  const internalContext = (0, import_react13.useMemo)(() => {
    const context = {
      activatorEvent,
      activators,
      active,
      activeNodeRect,
      ariaDescribedById: {
        draggable: draggableDescribedById
      },
      dispatch,
      draggableNodes,
      over,
      measureDroppableContainers
    };
    return context;
  }, [activatorEvent, activators, active, activeNodeRect, dispatch, draggableDescribedById, draggableNodes, over, measureDroppableContainers]);
  return import_react13.default.createElement(DndMonitorContext.Provider, {
    value: registerMonitorListener
  }, import_react13.default.createElement(InternalContext.Provider, {
    value: internalContext
  }, import_react13.default.createElement(PublicContext.Provider, {
    value: publicContext
  }, import_react13.default.createElement(ActiveDraggableContext.Provider, {
    value: transform
  }, children)), import_react13.default.createElement(RestoreFocus, {
    disabled: (accessibility == null ? void 0 : accessibility.restoreFocus) === false
  })), import_react13.default.createElement(Accessibility, {
    ...accessibility,
    hiddenTextDescribedById: draggableDescribedById
  }));
  function getAutoScrollerOptions() {
    const activeSensorDisablesAutoscroll = (activeSensor == null ? void 0 : activeSensor.autoScrollEnabled) === false;
    const autoScrollGloballyDisabled = typeof autoScroll === "object" ? autoScroll.enabled === false : autoScroll === false;
    const enabled = isInitialized && !activeSensorDisablesAutoscroll && !autoScrollGloballyDisabled;
    if (typeof autoScroll === "object") {
      return {
        ...autoScroll,
        enabled
      };
    }
    return {
      enabled
    };
  }
});
var NullContext = (0, import_react13.createContext)(null);
var defaultRole = "button";
var ID_PREFIX = "Droppable";
function useDraggable(_ref) {
  let {
    id,
    data,
    disabled = false,
    attributes
  } = _ref;
  const key2 = useUniqueId2(ID_PREFIX);
  const {
    activators,
    activatorEvent,
    active,
    activeNodeRect,
    ariaDescribedById,
    draggableNodes,
    over
  } = (0, import_react13.useContext)(InternalContext);
  const {
    role = defaultRole,
    roleDescription = "draggable",
    tabIndex = 0
  } = attributes != null ? attributes : {};
  const isDragging = (active == null ? void 0 : active.id) === id;
  const transform = (0, import_react13.useContext)(isDragging ? ActiveDraggableContext : NullContext);
  const [node, setNodeRef] = useNodeRef();
  const [activatorNode, setActivatorNodeRef] = useNodeRef();
  const listeners = useSyntheticListeners(activators, id);
  const dataRef = useLatestValue(data);
  useIsomorphicLayoutEffect(
    () => {
      draggableNodes.set(id, {
        id,
        key: key2,
        node,
        activatorNode,
        data: dataRef
      });
      return () => {
        const node2 = draggableNodes.get(id);
        if (node2 && node2.key === key2) {
          draggableNodes.delete(id);
        }
      };
    },
    [draggableNodes, id]
  );
  const memoizedAttributes = (0, import_react13.useMemo)(() => ({
    role,
    tabIndex,
    "aria-disabled": disabled,
    "aria-pressed": isDragging && role === defaultRole ? true : void 0,
    "aria-roledescription": roleDescription,
    "aria-describedby": ariaDescribedById.draggable
  }), [disabled, role, tabIndex, isDragging, roleDescription, ariaDescribedById.draggable]);
  return {
    active,
    activatorEvent,
    activeNodeRect,
    attributes: memoizedAttributes,
    isDragging,
    listeners: disabled ? void 0 : listeners,
    node,
    over,
    setNodeRef,
    setActivatorNodeRef,
    transform
  };
}
function useDndContext() {
  return (0, import_react13.useContext)(PublicContext);
}
var ID_PREFIX$1 = "Droppable";
var defaultResizeObserverConfig = {
  timeout: 25
};
function useDroppable(_ref) {
  let {
    data,
    disabled = false,
    id,
    resizeObserverConfig
  } = _ref;
  const key2 = useUniqueId2(ID_PREFIX$1);
  const {
    active,
    dispatch,
    over,
    measureDroppableContainers
  } = (0, import_react13.useContext)(InternalContext);
  const previous = (0, import_react13.useRef)({
    disabled
  });
  const resizeObserverConnected = (0, import_react13.useRef)(false);
  const rect = (0, import_react13.useRef)(null);
  const callbackId = (0, import_react13.useRef)(null);
  const {
    disabled: resizeObserverDisabled,
    updateMeasurementsFor,
    timeout: resizeObserverTimeout
  } = {
    ...defaultResizeObserverConfig,
    ...resizeObserverConfig
  };
  const ids2 = useLatestValue(updateMeasurementsFor != null ? updateMeasurementsFor : id);
  const handleResize = (0, import_react13.useCallback)(
    () => {
      if (!resizeObserverConnected.current) {
        resizeObserverConnected.current = true;
        return;
      }
      if (callbackId.current != null) {
        clearTimeout(callbackId.current);
      }
      callbackId.current = setTimeout(() => {
        measureDroppableContainers(Array.isArray(ids2.current) ? ids2.current : [ids2.current]);
        callbackId.current = null;
      }, resizeObserverTimeout);
    },
    [resizeObserverTimeout]
  );
  const resizeObserver = useResizeObserver({
    callback: handleResize,
    disabled: resizeObserverDisabled || !active
  });
  const handleNodeChange = (0, import_react13.useCallback)((newElement, previousElement) => {
    if (!resizeObserver) {
      return;
    }
    if (previousElement) {
      resizeObserver.unobserve(previousElement);
      resizeObserverConnected.current = false;
    }
    if (newElement) {
      resizeObserver.observe(newElement);
    }
  }, [resizeObserver]);
  const [nodeRef, setNodeRef] = useNodeRef(handleNodeChange);
  const dataRef = useLatestValue(data);
  (0, import_react13.useEffect)(() => {
    if (!resizeObserver || !nodeRef.current) {
      return;
    }
    resizeObserver.disconnect();
    resizeObserverConnected.current = false;
    resizeObserver.observe(nodeRef.current);
  }, [nodeRef, resizeObserver]);
  useIsomorphicLayoutEffect(
    () => {
      dispatch({
        type: Action.RegisterDroppable,
        element: {
          id,
          key: key2,
          disabled,
          node: nodeRef,
          rect,
          data: dataRef
        }
      });
      return () => dispatch({
        type: Action.UnregisterDroppable,
        key: key2,
        id
      });
    },
    [id]
  );
  (0, import_react13.useEffect)(() => {
    if (disabled !== previous.current.disabled) {
      dispatch({
        type: Action.SetDroppableDisabled,
        id,
        key: key2,
        disabled
      });
      previous.current.disabled = disabled;
    }
  }, [id, key2, disabled, dispatch]);
  return {
    active,
    rect,
    isOver: (over == null ? void 0 : over.id) === id,
    node: nodeRef,
    over,
    setNodeRef
  };
}
function AnimationManager(_ref) {
  let {
    animation,
    children
  } = _ref;
  const [clonedChildren, setClonedChildren] = (0, import_react13.useState)(null);
  const [element, setElement] = (0, import_react13.useState)(null);
  const previousChildren = usePrevious(children);
  if (!children && !clonedChildren && previousChildren) {
    setClonedChildren(previousChildren);
  }
  useIsomorphicLayoutEffect(() => {
    if (!element) {
      return;
    }
    const key2 = clonedChildren == null ? void 0 : clonedChildren.key;
    const id = clonedChildren == null ? void 0 : clonedChildren.props.id;
    if (key2 == null || id == null) {
      setClonedChildren(null);
      return;
    }
    Promise.resolve(animation(id, element)).then(() => {
      setClonedChildren(null);
    });
  }, [animation, clonedChildren, element]);
  return import_react13.default.createElement(import_react13.default.Fragment, null, children, clonedChildren ? (0, import_react13.cloneElement)(clonedChildren, {
    ref: setElement
  }) : null);
}
var defaultTransform = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function NullifiedContextProvider(_ref) {
  let {
    children
  } = _ref;
  return import_react13.default.createElement(InternalContext.Provider, {
    value: defaultInternalContext
  }, import_react13.default.createElement(ActiveDraggableContext.Provider, {
    value: defaultTransform
  }, children));
}
var baseStyles = {
  position: "fixed",
  touchAction: "none"
};
var defaultTransition = (activatorEvent) => {
  const isKeyboardActivator = isKeyboardEvent(activatorEvent);
  return isKeyboardActivator ? "transform 250ms ease" : void 0;
};
var PositionedOverlay = (0, import_react13.forwardRef)((_ref, ref) => {
  let {
    as,
    activatorEvent,
    adjustScale: adjustScale2,
    children,
    className: className2,
    rect,
    style,
    transform,
    transition = defaultTransition
  } = _ref;
  if (!rect) {
    return null;
  }
  const scaleAdjustedTransform = adjustScale2 ? transform : {
    ...transform,
    scaleX: 1,
    scaleY: 1
  };
  const styles = {
    ...baseStyles,
    width: rect.width,
    height: rect.height,
    top: rect.top,
    left: rect.left,
    transform: CSS.Transform.toString(scaleAdjustedTransform),
    transformOrigin: adjustScale2 && activatorEvent ? getRelativeTransformOrigin(activatorEvent, rect) : void 0,
    transition: typeof transition === "function" ? transition(activatorEvent) : transition,
    ...style
  };
  return import_react13.default.createElement(as, {
    className: className2,
    style: styles,
    ref
  }, children);
});
var defaultDropAnimationSideEffects = (options) => (_ref) => {
  let {
    active,
    dragOverlay
  } = _ref;
  const originalStyles = {};
  const {
    styles,
    className: className2
  } = options;
  if (styles != null && styles.active) {
    for (const [key2, value] of Object.entries(styles.active)) {
      if (value === void 0) {
        continue;
      }
      originalStyles[key2] = active.node.style.getPropertyValue(key2);
      active.node.style.setProperty(key2, value);
    }
  }
  if (styles != null && styles.dragOverlay) {
    for (const [key2, value] of Object.entries(styles.dragOverlay)) {
      if (value === void 0) {
        continue;
      }
      dragOverlay.node.style.setProperty(key2, value);
    }
  }
  if (className2 != null && className2.active) {
    active.node.classList.add(className2.active);
  }
  if (className2 != null && className2.dragOverlay) {
    dragOverlay.node.classList.add(className2.dragOverlay);
  }
  return function cleanup() {
    for (const [key2, value] of Object.entries(originalStyles)) {
      active.node.style.setProperty(key2, value);
    }
    if (className2 != null && className2.active) {
      active.node.classList.remove(className2.active);
    }
  };
};
var defaultKeyframeResolver = (_ref2) => {
  let {
    transform: {
      initial,
      final
    }
  } = _ref2;
  return [{
    transform: CSS.Transform.toString(initial)
  }, {
    transform: CSS.Transform.toString(final)
  }];
};
var defaultDropAnimationConfiguration = {
  duration: 250,
  easing: "ease",
  keyframes: defaultKeyframeResolver,
  sideEffects: defaultDropAnimationSideEffects({
    styles: {
      active: {
        opacity: "0"
      }
    }
  })
};
function useDropAnimation(_ref3) {
  let {
    config,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  } = _ref3;
  return useEvent((id, node) => {
    if (config === null) {
      return;
    }
    const activeDraggable = draggableNodes.get(id);
    if (!activeDraggable) {
      return;
    }
    const activeNode = activeDraggable.node.current;
    if (!activeNode) {
      return;
    }
    const measurableNode = getMeasurableNode(node);
    if (!measurableNode) {
      return;
    }
    const {
      transform
    } = getWindow(node).getComputedStyle(node);
    const parsedTransform = parseTransform(transform);
    if (!parsedTransform) {
      return;
    }
    const animation = typeof config === "function" ? config : createDefaultDropAnimation(config);
    scrollIntoViewIfNeeded(activeNode, measuringConfiguration.draggable.measure);
    return animation({
      active: {
        id,
        data: activeDraggable.data,
        node: activeNode,
        rect: measuringConfiguration.draggable.measure(activeNode)
      },
      draggableNodes,
      dragOverlay: {
        node,
        rect: measuringConfiguration.dragOverlay.measure(measurableNode)
      },
      droppableContainers,
      measuringConfiguration,
      transform: parsedTransform
    });
  });
}
function createDefaultDropAnimation(options) {
  const {
    duration,
    easing,
    sideEffects,
    keyframes
  } = {
    ...defaultDropAnimationConfiguration,
    ...options
  };
  return (_ref4) => {
    let {
      active,
      dragOverlay,
      transform,
      ...rest
    } = _ref4;
    if (!duration) {
      return;
    }
    const delta = {
      x: dragOverlay.rect.left - active.rect.left,
      y: dragOverlay.rect.top - active.rect.top
    };
    const scale = {
      scaleX: transform.scaleX !== 1 ? active.rect.width * transform.scaleX / dragOverlay.rect.width : 1,
      scaleY: transform.scaleY !== 1 ? active.rect.height * transform.scaleY / dragOverlay.rect.height : 1
    };
    const finalTransform = {
      x: transform.x - delta.x,
      y: transform.y - delta.y,
      ...scale
    };
    const animationKeyframes = keyframes({
      ...rest,
      active,
      dragOverlay,
      transform: {
        initial: transform,
        final: finalTransform
      }
    });
    const [firstKeyframe] = animationKeyframes;
    const lastKeyframe = animationKeyframes[animationKeyframes.length - 1];
    if (JSON.stringify(firstKeyframe) === JSON.stringify(lastKeyframe)) {
      return;
    }
    const cleanup = sideEffects == null ? void 0 : sideEffects({
      active,
      dragOverlay,
      ...rest
    });
    const animation = dragOverlay.node.animate(animationKeyframes, {
      duration,
      easing,
      fill: "forwards"
    });
    return new Promise((resolve) => {
      animation.onfinish = () => {
        cleanup == null ? void 0 : cleanup();
        resolve();
      };
    });
  };
}
var key = 0;
function useKey(id) {
  return (0, import_react13.useMemo)(() => {
    if (id == null) {
      return;
    }
    key++;
    return key;
  }, [id]);
}
var DragOverlay = import_react13.default.memo((_ref) => {
  let {
    adjustScale: adjustScale2 = false,
    children,
    dropAnimation: dropAnimationConfig,
    style,
    transition,
    modifiers,
    wrapperElement = "div",
    className: className2,
    zIndex = 999
  } = _ref;
  const {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggableNodes,
    droppableContainers,
    dragOverlay,
    over,
    measuringConfiguration,
    scrollableAncestors,
    scrollableAncestorRects,
    windowRect
  } = useDndContext();
  const transform = (0, import_react13.useContext)(ActiveDraggableContext);
  const key2 = useKey(active == null ? void 0 : active.id);
  const modifiedTransform = applyModifiers(modifiers, {
    activatorEvent,
    active,
    activeNodeRect,
    containerNodeRect,
    draggingNodeRect: dragOverlay.rect,
    over,
    overlayNodeRect: dragOverlay.rect,
    scrollableAncestors,
    scrollableAncestorRects,
    transform,
    windowRect
  });
  const initialRect = useInitialValue(activeNodeRect);
  const dropAnimation = useDropAnimation({
    config: dropAnimationConfig,
    draggableNodes,
    droppableContainers,
    measuringConfiguration
  });
  const ref = initialRect ? dragOverlay.setRef : void 0;
  return import_react13.default.createElement(NullifiedContextProvider, null, import_react13.default.createElement(AnimationManager, {
    animation: dropAnimation
  }, active && key2 ? import_react13.default.createElement(PositionedOverlay, {
    key: key2,
    id: active.id,
    ref,
    as: wrapperElement,
    activatorEvent,
    adjustScale: adjustScale2,
    className: className2,
    transition,
    rect: initialRect,
    style: {
      zIndex,
      ...style
    },
    transform: modifiedTransform
  }, children) : null));
});

// node_modules/@dnd-kit/sortable/dist/sortable.esm.js
var import_react14 = __toESM(require_react());
function arrayMove(array, from, to) {
  const newArray = array.slice();
  newArray.splice(to < 0 ? newArray.length + to : to, 0, newArray.splice(from, 1)[0]);
  return newArray;
}
function getSortedRects(items, rects) {
  return items.reduce((accumulator, id, index) => {
    const rect = rects.get(id);
    if (rect) {
      accumulator[index] = rect;
    }
    return accumulator;
  }, Array(items.length));
}
function isValidIndex(index) {
  return index !== null && index >= 0;
}
function itemsEqual(a, b) {
  if (a === b) {
    return true;
  }
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function normalizeDisabled(disabled) {
  if (typeof disabled === "boolean") {
    return {
      draggable: disabled,
      droppable: disabled
    };
  }
  return disabled;
}
var rectSortingStrategy = (_ref) => {
  let {
    rects,
    activeIndex,
    overIndex,
    index
  } = _ref;
  const newRects = arrayMove(rects, overIndex, activeIndex);
  const oldRect = rects[index];
  const newRect = newRects[index];
  if (!newRect || !oldRect) {
    return null;
  }
  return {
    x: newRect.left - oldRect.left,
    y: newRect.top - oldRect.top,
    scaleX: newRect.width / oldRect.width,
    scaleY: newRect.height / oldRect.height
  };
};
var defaultScale$1 = {
  scaleX: 1,
  scaleY: 1
};
var verticalListSortingStrategy = (_ref) => {
  var _rects$activeIndex;
  let {
    activeIndex,
    activeNodeRect: fallbackActiveRect,
    index,
    rects,
    overIndex
  } = _ref;
  const activeNodeRect = (_rects$activeIndex = rects[activeIndex]) != null ? _rects$activeIndex : fallbackActiveRect;
  if (!activeNodeRect) {
    return null;
  }
  if (index === activeIndex) {
    const overIndexRect = rects[overIndex];
    if (!overIndexRect) {
      return null;
    }
    return {
      x: 0,
      y: activeIndex < overIndex ? overIndexRect.top + overIndexRect.height - (activeNodeRect.top + activeNodeRect.height) : overIndexRect.top - activeNodeRect.top,
      ...defaultScale$1
    };
  }
  const itemGap = getItemGap$1(rects, index, activeIndex);
  if (index > activeIndex && index <= overIndex) {
    return {
      x: 0,
      y: -activeNodeRect.height - itemGap,
      ...defaultScale$1
    };
  }
  if (index < activeIndex && index >= overIndex) {
    return {
      x: 0,
      y: activeNodeRect.height + itemGap,
      ...defaultScale$1
    };
  }
  return {
    x: 0,
    y: 0,
    ...defaultScale$1
  };
};
function getItemGap$1(clientRects, index, activeIndex) {
  const currentRect = clientRects[index];
  const previousRect = clientRects[index - 1];
  const nextRect = clientRects[index + 1];
  if (!currentRect) {
    return 0;
  }
  if (activeIndex < index) {
    return previousRect ? currentRect.top - (previousRect.top + previousRect.height) : nextRect ? nextRect.top - (currentRect.top + currentRect.height) : 0;
  }
  return nextRect ? nextRect.top - (currentRect.top + currentRect.height) : previousRect ? currentRect.top - (previousRect.top + previousRect.height) : 0;
}
var ID_PREFIX2 = "Sortable";
var Context = import_react14.default.createContext({
  activeIndex: -1,
  containerId: ID_PREFIX2,
  disableTransforms: false,
  items: [],
  overIndex: -1,
  useDragOverlay: false,
  sortedRects: [],
  strategy: rectSortingStrategy,
  disabled: {
    draggable: false,
    droppable: false
  }
});
function SortableContext(_ref) {
  let {
    children,
    id,
    items: userDefinedItems,
    strategy = rectSortingStrategy,
    disabled: disabledProp = false
  } = _ref;
  const {
    active,
    dragOverlay,
    droppableRects,
    over,
    measureDroppableContainers
  } = useDndContext();
  const containerId = useUniqueId2(ID_PREFIX2, id);
  const useDragOverlay = Boolean(dragOverlay.rect !== null);
  const items = (0, import_react14.useMemo)(() => userDefinedItems.map((item) => typeof item === "object" && "id" in item ? item.id : item), [userDefinedItems]);
  const isDragging = active != null;
  const activeIndex = active ? items.indexOf(active.id) : -1;
  const overIndex = over ? items.indexOf(over.id) : -1;
  const previousItemsRef = (0, import_react14.useRef)(items);
  const itemsHaveChanged = !itemsEqual(items, previousItemsRef.current);
  const disableTransforms = overIndex !== -1 && activeIndex === -1 || itemsHaveChanged;
  const disabled = normalizeDisabled(disabledProp);
  useIsomorphicLayoutEffect(() => {
    if (itemsHaveChanged && isDragging) {
      measureDroppableContainers(items);
    }
  }, [itemsHaveChanged, items, isDragging, measureDroppableContainers]);
  (0, import_react14.useEffect)(() => {
    previousItemsRef.current = items;
  }, [items]);
  const contextValue = (0, import_react14.useMemo)(
    () => ({
      activeIndex,
      containerId,
      disabled,
      disableTransforms,
      items,
      overIndex,
      useDragOverlay,
      sortedRects: getSortedRects(items, droppableRects),
      strategy
    }),
    [activeIndex, containerId, disabled.draggable, disabled.droppable, disableTransforms, items, overIndex, droppableRects, useDragOverlay, strategy]
  );
  return import_react14.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
var defaultNewIndexGetter = (_ref) => {
  let {
    id,
    items,
    activeIndex,
    overIndex
  } = _ref;
  return arrayMove(items, activeIndex, overIndex).indexOf(id);
};
var defaultAnimateLayoutChanges = (_ref2) => {
  let {
    containerId,
    isSorting,
    wasDragging,
    index,
    items,
    newIndex,
    previousItems,
    previousContainerId,
    transition
  } = _ref2;
  if (!transition || !wasDragging) {
    return false;
  }
  if (previousItems !== items && index === newIndex) {
    return false;
  }
  if (isSorting) {
    return true;
  }
  return newIndex !== index && containerId === previousContainerId;
};
var defaultTransition2 = {
  duration: 200,
  easing: "ease"
};
var transitionProperty = "transform";
var disabledTransition = CSS.Transition.toString({
  property: transitionProperty,
  duration: 0,
  easing: "linear"
});
var defaultAttributes = {
  roleDescription: "sortable"
};
function useDerivedTransform(_ref) {
  let {
    disabled,
    index,
    node,
    rect
  } = _ref;
  const [derivedTransform, setDerivedtransform] = (0, import_react14.useState)(null);
  const previousIndex = (0, import_react14.useRef)(index);
  useIsomorphicLayoutEffect(() => {
    if (!disabled && index !== previousIndex.current && node.current) {
      const initial = rect.current;
      if (initial) {
        const current = getClientRect(node.current, {
          ignoreTransform: true
        });
        const delta = {
          x: initial.left - current.left,
          y: initial.top - current.top,
          scaleX: initial.width / current.width,
          scaleY: initial.height / current.height
        };
        if (delta.x || delta.y) {
          setDerivedtransform(delta);
        }
      }
    }
    if (index !== previousIndex.current) {
      previousIndex.current = index;
    }
  }, [disabled, index, node, rect]);
  (0, import_react14.useEffect)(() => {
    if (derivedTransform) {
      setDerivedtransform(null);
    }
  }, [derivedTransform]);
  return derivedTransform;
}
function useSortable(_ref) {
  let {
    animateLayoutChanges = defaultAnimateLayoutChanges,
    attributes: userDefinedAttributes,
    disabled: localDisabled,
    data: customData,
    getNewIndex = defaultNewIndexGetter,
    id,
    strategy: localStrategy,
    resizeObserverConfig,
    transition = defaultTransition2
  } = _ref;
  const {
    items,
    containerId,
    activeIndex,
    disabled: globalDisabled,
    disableTransforms,
    sortedRects,
    overIndex,
    useDragOverlay,
    strategy: globalStrategy
  } = (0, import_react14.useContext)(Context);
  const disabled = normalizeLocalDisabled(localDisabled, globalDisabled);
  const index = items.indexOf(id);
  const data = (0, import_react14.useMemo)(() => ({
    sortable: {
      containerId,
      index,
      items
    },
    ...customData
  }), [containerId, customData, index, items]);
  const itemsAfterCurrentSortable = (0, import_react14.useMemo)(() => items.slice(items.indexOf(id)), [items, id]);
  const {
    rect,
    node,
    isOver,
    setNodeRef: setDroppableNodeRef
  } = useDroppable({
    id,
    data,
    disabled: disabled.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: itemsAfterCurrentSortable,
      ...resizeObserverConfig
    }
  });
  const {
    active,
    activatorEvent,
    activeNodeRect,
    attributes,
    setNodeRef: setDraggableNodeRef,
    listeners,
    isDragging,
    over,
    setActivatorNodeRef,
    transform
  } = useDraggable({
    id,
    data,
    attributes: {
      ...defaultAttributes,
      ...userDefinedAttributes
    },
    disabled: disabled.draggable
  });
  const setNodeRef = useCombinedRefs(setDroppableNodeRef, setDraggableNodeRef);
  const isSorting = Boolean(active);
  const displaceItem = isSorting && !disableTransforms && isValidIndex(activeIndex) && isValidIndex(overIndex);
  const shouldDisplaceDragSource = !useDragOverlay && isDragging;
  const dragSourceDisplacement = shouldDisplaceDragSource && displaceItem ? transform : null;
  const strategy = localStrategy != null ? localStrategy : globalStrategy;
  const finalTransform = displaceItem ? dragSourceDisplacement != null ? dragSourceDisplacement : strategy({
    rects: sortedRects,
    activeNodeRect,
    activeIndex,
    overIndex,
    index
  }) : null;
  const newIndex = isValidIndex(activeIndex) && isValidIndex(overIndex) ? getNewIndex({
    id,
    items,
    activeIndex,
    overIndex
  }) : index;
  const activeId = active == null ? void 0 : active.id;
  const previous = (0, import_react14.useRef)({
    activeId,
    items,
    newIndex,
    containerId
  });
  const itemsHaveChanged = items !== previous.current.items;
  const shouldAnimateLayoutChanges = animateLayoutChanges({
    active,
    containerId,
    isDragging,
    isSorting,
    id,
    index,
    items,
    newIndex: previous.current.newIndex,
    previousItems: previous.current.items,
    previousContainerId: previous.current.containerId,
    transition,
    wasDragging: previous.current.activeId != null
  });
  const derivedTransform = useDerivedTransform({
    disabled: !shouldAnimateLayoutChanges,
    index,
    node,
    rect
  });
  (0, import_react14.useEffect)(() => {
    if (isSorting && previous.current.newIndex !== newIndex) {
      previous.current.newIndex = newIndex;
    }
    if (containerId !== previous.current.containerId) {
      previous.current.containerId = containerId;
    }
    if (items !== previous.current.items) {
      previous.current.items = items;
    }
  }, [isSorting, newIndex, containerId, items]);
  (0, import_react14.useEffect)(() => {
    if (activeId === previous.current.activeId) {
      return;
    }
    if (activeId && !previous.current.activeId) {
      previous.current.activeId = activeId;
      return;
    }
    const timeoutId = setTimeout(() => {
      previous.current.activeId = activeId;
    }, 50);
    return () => clearTimeout(timeoutId);
  }, [activeId]);
  return {
    active,
    activeIndex,
    attributes,
    data,
    rect,
    index,
    newIndex,
    items,
    isOver,
    isSorting,
    isDragging,
    listeners,
    node,
    overIndex,
    over,
    setNodeRef,
    setActivatorNodeRef,
    setDroppableNodeRef,
    setDraggableNodeRef,
    transform: derivedTransform != null ? derivedTransform : finalTransform,
    transition: getTransition()
  };
  function getTransition() {
    if (derivedTransform || itemsHaveChanged && previous.current.newIndex === index) {
      return disabledTransition;
    }
    if (shouldDisplaceDragSource && !isKeyboardEvent(activatorEvent) || !transition) {
      return void 0;
    }
    if (isSorting || shouldAnimateLayoutChanges) {
      return CSS.Transition.toString({
        ...transition,
        property: transitionProperty
      });
    }
    return void 0;
  }
}
function normalizeLocalDisabled(localDisabled, globalDisabled) {
  var _localDisabled$dragga, _localDisabled$droppa;
  if (typeof localDisabled === "boolean") {
    return {
      draggable: localDisabled,
      droppable: false
    };
  }
  return {
    draggable: (_localDisabled$dragga = localDisabled == null ? void 0 : localDisabled.draggable) != null ? _localDisabled$dragga : globalDisabled.draggable,
    droppable: (_localDisabled$droppa = localDisabled == null ? void 0 : localDisabled.droppable) != null ? _localDisabled$droppa : globalDisabled.droppable
  };
}
function hasSortableData(entry) {
  if (!entry) {
    return false;
  }
  const data = entry.data.current;
  if (data && "sortable" in data && typeof data.sortable === "object" && "containerId" in data.sortable && "items" in data.sortable && "index" in data.sortable) {
    return true;
  }
  return false;
}
var directions = [KeyboardCode.Down, KeyboardCode.Right, KeyboardCode.Up, KeyboardCode.Left];

// node_modules/@cloudscape-design/components/collection-preferences/content-display/draggable-option.js
var import_react18 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/drag-handle/index.js
var import_react16 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/handle/index.js
var import_react15 = __toESM(require_react());

// node_modules/@cloudscape-design/components/internal/components/handle/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/internal/components/handle/styles.scoped.css";
var styles_css_default7 = {
  "handle": "awsui_handle_iykw5_b48ke_93",
  "hide-focus": "awsui_hide-focus_iykw5_b48ke_104"
};

// node_modules/@cloudscape-design/components/internal/components/handle/index.js
function Handle(props) {
  return import_react15.default.createElement("div", Object.assign({ role: "button", tabIndex: 0 }, props, { onPointerDown: props.onPointerDown, className: clsx_m_default(styles_css_default7.handle, props.className) }));
}

// node_modules/@cloudscape-design/components/internal/components/drag-handle/styles.css.js
import "/local/home/samilafo/final_epa_project/QwizGuruPlatform/cloudscape/node_modules/@cloudscape-design/components/internal/components/drag-handle/styles.scoped.css";
var styles_css_default8 = {
  "handle": "awsui_handle_sdha6_1v8zk_5"
};

// node_modules/@cloudscape-design/components/internal/components/drag-handle/index.js
function DragHandle({ attributes, hideFocus, listeners }) {
  return import_react16.default.createElement(
    Handle,
    Object.assign({ className: clsx_m_default(styles_css_default8.handle, hideFocus && styles_css_default7["hide-focus"]) }, attributes, listeners),
    import_react16.default.createElement(internal_default, { name: "drag-indicator" })
  );
}

// node_modules/@cloudscape-design/components/collection-preferences/content-display/content-display-option.js
var import_react17 = __toESM(require_react());
var componentPrefix = "content-display-option";
var getClassName = (suffix) => styles_css_default5[[componentPrefix, suffix].filter(Boolean).join("-")];
var ContentDisplayOption = (0, import_react17.forwardRef)(({ dragHandleAriaLabel, listeners, onToggle, option }, ref) => {
  const idPrefix = useUniqueId(componentPrefix);
  const controlId = `${idPrefix}-control-${option.id}`;
  const dragHandleAttributes = {
    ["aria-label"]: [dragHandleAriaLabel, option.label].join(", ")
  };
  return import_react17.default.createElement(
    "div",
    { ref, className: getClassName("content") },
    import_react17.default.createElement(DragHandle, { attributes: dragHandleAttributes, listeners }),
    import_react17.default.createElement("label", { className: getClassName("label"), htmlFor: controlId }, option.label),
    import_react17.default.createElement(
      "div",
      { className: getClassName("toggle") },
      import_react17.default.createElement(internal_default5, { checked: !!option.visible, onChange: () => onToggle && onToggle(option), disabled: option.alwaysVisible === true, controlId })
    )
  );
});
var content_display_option_default = ContentDisplayOption;

// node_modules/@cloudscape-design/components/collection-preferences/content-display/draggable-option.js
function DraggableOption({ dragHandleAriaLabel, onKeyDown, onToggle, option }) {
  const { isDragging, isSorting, listeners, setNodeRef, transform } = useSortable({
    id: option.id
  });
  const style = {
    transform: CSS.Translate.toString(transform)
  };
  const combinedListeners = Object.assign(Object.assign({}, listeners), { onKeyDown: (event) => {
    if (onKeyDown) {
      onKeyDown(event);
    }
    if (listeners === null || listeners === void 0 ? void 0 : listeners.onKeyDown) {
      listeners.onKeyDown(event);
    }
  } });
  return import_react18.default.createElement(
    "li",
    { className: clsx_m_default(getClassName(), isDragging && styles_css_default5.placeholder, isSorting && styles_css_default5.sorting), style },
    import_react18.default.createElement(content_display_option_default, { ref: setNodeRef, listeners: combinedListeners, dragHandleAriaLabel, onToggle, option })
  );
}

// node_modules/@cloudscape-design/components/collection-preferences/content-display/use-drag-and-drop-reorder.js
var import_react19 = __toESM(require_react());

// node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/utilities/scroll.js
function isDocumentScrollingElement2(element) {
  if (!canUseDOM || !element) {
    return false;
  }
  return element === document.scrollingElement;
}
function getScrollPosition2(scrollingContainer) {
  const minScroll = {
    x: 0,
    y: 0
  };
  const dimensions = isDocumentScrollingElement2(scrollingContainer) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: scrollingContainer.clientHeight,
    width: scrollingContainer.clientWidth
  };
  const maxScroll = {
    x: scrollingContainer.scrollWidth - dimensions.width,
    y: scrollingContainer.scrollHeight - dimensions.height
  };
  const isTop = scrollingContainer.scrollTop <= minScroll.y;
  const isLeft = scrollingContainer.scrollLeft <= minScroll.x;
  const isBottom = scrollingContainer.scrollTop >= maxScroll.y;
  const isRight = scrollingContainer.scrollLeft >= maxScroll.x;
  return {
    isTop,
    isLeft,
    isBottom,
    isRight,
    maxScroll,
    minScroll
  };
}
function getScrollElementRect2(element) {
  if (element === document.scrollingElement) {
    const { innerWidth, innerHeight } = window;
    return {
      top: 0,
      left: 0,
      right: innerWidth,
      bottom: innerHeight,
      width: innerWidth,
      height: innerHeight
    };
  }
  const { top, left, right, bottom } = element.getBoundingClientRect();
  return {
    top,
    left,
    right,
    bottom,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function applyScroll({ currentCoordinates, direction, newCoordinates, scrollableAncestors }) {
  for (const scrollContainer of scrollableAncestors) {
    const coordinatesDelta = subtract(newCoordinates, currentCoordinates);
    const { isTop, isBottom, maxScroll, minScroll } = getScrollPosition2(scrollContainer);
    const scrollElementRect = getScrollElementRect2(scrollContainer);
    const clampedCoordinates = {
      y: Math.min(direction === KeyboardCode.Down ? scrollElementRect.bottom - scrollElementRect.height / 2 : scrollElementRect.bottom, Math.max(direction === KeyboardCode.Down ? scrollElementRect.top : scrollElementRect.top + scrollElementRect.height / 2, newCoordinates.y))
    };
    const canScrollY = direction === KeyboardCode.Down && !isBottom || direction === KeyboardCode.Up && !isTop;
    if (canScrollY && clampedCoordinates.y !== newCoordinates.y) {
      const newScrollCoordinates = scrollContainer.scrollTop + coordinatesDelta.y;
      const canScrollToNewCoordinates = direction === KeyboardCode.Down && newScrollCoordinates <= maxScroll.y || direction === KeyboardCode.Up && newScrollCoordinates >= minScroll.y;
      if (canScrollToNewCoordinates) {
        scrollContainer.scrollTo({
          top: newScrollCoordinates,
          behavior: "smooth"
        });
        return true;
      }
      break;
    }
  }
  return false;
}

// node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/utilities/events.js
var EventName2;
(function(EventName3) {
  EventName3["Blur"] = "blur";
  EventName3["Click"] = "click";
  EventName3["DragStart"] = "dragstart";
  EventName3["Keydown"] = "keydown";
  EventName3["ContextMenu"] = "contextmenu";
  EventName3["Resize"] = "resize";
  EventName3["SelectionChange"] = "selectionchange";
  EventName3["VisibilityChange"] = "visibilitychange";
})(EventName2 || (EventName2 = {}));

// node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/utilities/listeners.js
var Listeners2 = class {
  constructor(target) {
    this.target = target;
    this.listeners = [];
    this.removeAll = () => {
      this.listeners.forEach((listener) => {
        var _a;
        return (_a = this.target) === null || _a === void 0 ? void 0 : _a.removeEventListener(...listener);
      });
    };
  }
  add(eventName, handler, options) {
    var _a;
    (_a = this.target) === null || _a === void 0 ? void 0 : _a.addEventListener(eventName, handler, options);
    this.listeners.push([eventName, handler, options]);
  }
};

// node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/defaults.js
var defaultKeyboardCodes2 = {
  start: [KeyboardCode.Space, KeyboardCode.Enter],
  cancel: [KeyboardCode.Esc],
  end: [KeyboardCode.Space, KeyboardCode.Enter]
};

// node_modules/@cloudscape-design/components/collection-preferences/content-display/keyboard-sensor/index.js
var KeyboardSensor2 = class {
  constructor(props) {
    this.props = props;
    this.autoScrollEnabled = false;
    const { event: { target } } = props;
    this.props = props;
    this.listeners = new Listeners2(getOwnerDocument(target));
    this.windowListeners = new Listeners2(getWindow(target));
    this.handleKeyDown = this.handleKeyDown.bind(this);
    this.handleCancel = this.handleCancel.bind(this);
    this.attach();
  }
  attach() {
    var _a;
    this.handleStart();
    this.windowListeners.add(EventName2.Resize, this.handleCancel);
    this.windowListeners.add(EventName2.VisibilityChange, this.handleCancel);
    (_a = this.props.event.target) === null || _a === void 0 ? void 0 : _a.addEventListener(EventName2.Blur, this.handleCancel);
    setTimeout(() => this.listeners.add(EventName2.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const { activeNode, onStart } = this.props;
    const node = activeNode.node.current;
    if (node) {
      scrollElementIntoView(node);
    }
    onStart(defaultCoordinates);
  }
  handleKeyDown(event) {
    if (isKeyboardEvent(event)) {
      const { active, context, options } = this.props;
      const { keyboardCodes = defaultKeyboardCodes2, coordinateGetter } = options;
      const { code } = event;
      if (keyboardCodes.end.indexOf(code) !== -1) {
        this.handleEnd(event);
        return;
      }
      if (keyboardCodes.cancel.indexOf(code) !== -1) {
        this.handleCancel(event);
        return;
      }
      const { collisionRect } = context.current;
      const currentCoordinates = collisionRect ? { x: collisionRect.left, y: collisionRect.top } : defaultCoordinates;
      if (!this.referenceCoordinates) {
        this.referenceCoordinates = currentCoordinates;
      }
      if (!coordinateGetter) {
        return;
      }
      const newCoordinates = coordinateGetter(event, {
        active,
        context: context.current,
        currentCoordinates
      });
      if (newCoordinates) {
        const { scrollableAncestors } = context.current;
        const direction = event.code;
        const scrolled = applyScroll({ currentCoordinates, direction, newCoordinates, scrollableAncestors });
        if (!scrolled) {
          this.handleMove(event, subtract(newCoordinates, this.referenceCoordinates));
        }
      }
    }
  }
  handleMove(event, coordinates) {
    const { onMove } = this.props;
    event.preventDefault();
    onMove(coordinates);
  }
  handleEnd(event) {
    const { onEnd } = this.props;
    event.preventDefault();
    this.detach();
    onEnd();
  }
  handleCancel(event) {
    const { onCancel } = this.props;
    if (event.type !== EventName2.Blur) {
      event.preventDefault();
    }
    this.detach();
    onCancel();
  }
  detach() {
    var _a;
    (_a = this.props.event.target) === null || _a === void 0 ? void 0 : _a.removeEventListener(EventName2.Blur, this.handleCancel);
    this.listeners.removeAll();
    this.windowListeners.removeAll();
  }
};
KeyboardSensor2.activators = [
  {
    eventName: "onKeyDown",
    handler: (event, { keyboardCodes = defaultKeyboardCodes2, onActivation }, { active }) => {
      const { code } = event.nativeEvent;
      if (keyboardCodes.start.indexOf(code) !== -1) {
        const activator = active.activatorNode.current;
        if (activator && event.target !== activator) {
          return false;
        }
        event.preventDefault();
        onActivation === null || onActivation === void 0 ? void 0 : onActivation({ event: event.nativeEvent });
        return true;
      }
      return false;
    }
  }
];

// node_modules/@cloudscape-design/components/collection-preferences/content-display/use-drag-and-drop-reorder.js
var KeyboardCode2;
(function(KeyboardCode3) {
  KeyboardCode3["Space"] = "Space";
  KeyboardCode3["Down"] = "ArrowDown";
  KeyboardCode3["Right"] = "ArrowRight";
  KeyboardCode3["Left"] = "ArrowLeft";
  KeyboardCode3["Up"] = "ArrowUp";
  KeyboardCode3["Esc"] = "Escape";
  KeyboardCode3["Enter"] = "Enter";
})(KeyboardCode2 || (KeyboardCode2 = {}));
function useDragAndDropReorder({ sortedOptions }) {
  const isKeyboard = (0, import_react19.useRef)(false);
  const positionDelta = (0, import_react19.useRef)(0);
  const [activeItemId, setActiveItemId] = (0, import_react19.useState)(null);
  const setActiveItem = (id) => {
    setActiveItemId(id);
    if (!id) {
      isKeyboard.current = false;
      positionDelta.current = 0;
    }
  };
  const handleKeyDown = (event) => {
    if (isKeyboard.current && activeItemId) {
      const currentTargetIndex = sortedOptions.findIndex(({ id }) => id === activeItemId) + positionDelta.current;
      if (event.key === "ArrowDown" && currentTargetIndex < sortedOptions.length - 1) {
        positionDelta.current += 1;
      } else if (event.key === "ArrowUp" && currentTargetIndex > 0) {
        positionDelta.current -= 1;
      }
    }
    if (activeItemId && isEscape(event.key)) {
      event.stopPropagation();
    }
  };
  const getClosestId = (active) => {
    if (positionDelta.current === 0) {
      return active.id;
    }
    const currentIndex = sortedOptions.findIndex(({ id }) => id === active.id);
    const newIndex = Math.max(0, Math.min(sortedOptions.length - 1, currentIndex + positionDelta.current));
    return sortedOptions[newIndex].id;
  };
  const collisionDetection = ({ active, collisionRect, droppableContainers, droppableRects, pointerCoordinates }) => {
    if (isKeyboard.current) {
      const collidingContainer = getCollidingContainer({
        activeId: active.id,
        closestId: getClosestId(active),
        droppableContainers
      });
      return collidingContainer ? [collidingContainer] : [];
    } else {
      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });
    }
  };
  const coordinateGetter = (event, { context: { active, collisionRect, droppableRects, droppableContainers } }) => {
    if (event.code === KeyboardCode2.Up || event.code === KeyboardCode2.Down) {
      event.preventDefault();
      if (!active || !collisionRect) {
        return;
      }
      const closestId = getClosestId(active);
      if (closestId !== null) {
        const activeDroppable = droppableContainers.get(active.id);
        const newDroppable = droppableContainers.get(closestId);
        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;
        const newNode = newDroppable === null || newDroppable === void 0 ? void 0 : newDroppable.node.current;
        if (newNode && newRect && activeDroppable && newDroppable) {
          const isAfterActive = isAfter(activeDroppable, newDroppable);
          const offset = {
            x: isAfterActive ? collisionRect.width - newRect.width : 0,
            y: isAfterActive ? collisionRect.height - newRect.height : 0
          };
          const rectCoordinates = {
            x: newRect.left,
            y: newRect.top
          };
          return {
            x: rectCoordinates.x - offset.x,
            y: rectCoordinates.y - offset.y
          };
        }
      }
    }
  };
  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor2, {
    coordinateGetter,
    onActivation: () => {
      isKeyboard.current = true;
    }
  }));
  return {
    activeItem: activeItemId,
    collisionDetection,
    coordinateGetter,
    handleKeyDown,
    sensors,
    setActiveItem
  };
}
function isAfter(a, b) {
  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;
}
function getCollidingContainer({ activeId, closestId, droppableContainers }) {
  if (closestId === activeId) {
    return;
  }
  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);
  if (collidingContainer) {
    return {
      id: collidingContainer.id,
      data: {
        droppableContainer: collidingContainer,
        value: 0
      }
    };
  }
}
var isEscape = (key2) => key2 === "Escape" || key2 === "Esc";

// node_modules/@cloudscape-design/components/collection-preferences/content-display/use-live-announcements.js
var import_react20 = __toESM(require_react());
function useLiveAnnouncements({ isDragging, liveAnnouncementDndStarted, liveAnnouncementDndItemReordered, liveAnnouncementDndItemCommitted, liveAnnouncementDndDiscarded, sortedOptions }) {
  const isFirstAnnouncement = (0, import_react20.useRef)(true);
  if (!isDragging) {
    isFirstAnnouncement.current = true;
  }
  return {
    onDragStart({ active }) {
      if (active && liveAnnouncementDndStarted) {
        const index = sortedOptions.findIndex((option) => option.id === active.id);
        return liveAnnouncementDndStarted(index + 1, sortedOptions.length);
      }
    },
    onDragOver({ active, over }) {
      if (liveAnnouncementDndItemReordered) {
        if (isFirstAnnouncement.current) {
          isFirstAnnouncement.current = false;
          if (!over || over.id === active.id) {
            return;
          }
        }
        const initialIndex = sortedOptions.findIndex((option) => option.id === active.id);
        const currentIdex = over ? sortedOptions.findIndex((option) => option.id === over.id) : initialIndex;
        return liveAnnouncementDndItemReordered(initialIndex + 1, currentIdex + 1, sortedOptions.length);
      }
    },
    onDragEnd({ active, over }) {
      if (liveAnnouncementDndItemCommitted) {
        const initialIndex = sortedOptions.findIndex((option) => option.id === active.id);
        const finalIndex = over ? sortedOptions.findIndex((option) => option.id === over.id) : initialIndex;
        return liveAnnouncementDndItemCommitted(initialIndex + 1, finalIndex + 1, sortedOptions.length);
      }
    },
    onDragCancel() {
      return liveAnnouncementDndDiscarded;
    }
  };
}

// node_modules/@cloudscape-design/components/collection-preferences/content-display/index.js
var componentPrefix2 = "content-display";
var getClassName2 = (suffix) => styles_css_default5[`${componentPrefix2}-${suffix}`];
function ContentDisplayPreference({ title, description, options, value = options.map(({ id }) => ({
  id,
  visible: true
})), onChange, liveAnnouncementDndStarted, liveAnnouncementDndItemReordered, liveAnnouncementDndItemCommitted, liveAnnouncementDndDiscarded, dragHandleAriaDescription, dragHandleAriaLabel }) {
  const idPrefix = useUniqueId(componentPrefix2);
  const i18n = useInternalI18n("collection-preferences");
  const onToggle = (option) => {
    onChange(value.map((item) => item.id === option.id ? Object.assign(Object.assign({}, item), { visible: !option.visible }) : item));
  };
  const titleId = `${idPrefix}-title`;
  const descriptionId = `${idPrefix}-description`;
  const sortedOptions = getSortedOptions({ options, contentDisplay: value });
  const { activeItem, collisionDetection, handleKeyDown, sensors, setActiveItem } = useDragAndDropReorder({
    sortedOptions
  });
  const activeOption = activeItem ? sortedOptions.find(({ id }) => id === activeItem) : null;
  const announcements = useLiveAnnouncements({
    isDragging: activeItem !== null,
    liveAnnouncementDndStarted: i18n("contentDisplayPreference.liveAnnouncementDndStarted", liveAnnouncementDndStarted, (format) => (position, total) => format({ position, total })),
    liveAnnouncementDndItemReordered: i18n("contentDisplayPreference.liveAnnouncementDndItemReordered", liveAnnouncementDndItemReordered, (format) => (initialPosition, currentPosition, total) => format({ currentPosition, total, isInitialPosition: `${initialPosition === currentPosition}` })),
    liveAnnouncementDndItemCommitted: i18n("contentDisplayPreference.liveAnnouncementDndItemCommitted", liveAnnouncementDndItemCommitted, (format) => (initialPosition, finalPosition, total) => format({ initialPosition, finalPosition, total, isInitialPosition: `${initialPosition === finalPosition}` })),
    liveAnnouncementDndDiscarded: i18n("contentDisplayPreference.liveAnnouncementDndDiscarded", liveAnnouncementDndDiscarded),
    sortedOptions: value
  });
  const renderedDragHandleAriaDescription = i18n("contentDisplayPreference.dragHandleAriaDescription", dragHandleAriaDescription);
  return import_react21.default.createElement(
    "div",
    { className: styles_css_default5[componentPrefix2] },
    import_react21.default.createElement("h3", { className: getClassName2("title"), id: titleId }, i18n("contentDisplayPreference.title", title)),
    import_react21.default.createElement("p", { className: getClassName2("description"), id: descriptionId }, i18n("contentDisplayPreference.description", description)),
    import_react21.default.createElement(
      DndContext,
      { sensors, collisionDetection, accessibility: {
        announcements,
        restoreFocus: false,
        screenReaderInstructions: renderedDragHandleAriaDescription ? { draggable: renderedDragHandleAriaDescription } : void 0
      }, onDragStart: ({ active }) => setActiveItem(active.id), onDragEnd: (event) => {
        setActiveItem(null);
        const { active, over } = event;
        if (over && active.id !== over.id) {
          const oldIndex = value.findIndex(({ id }) => id === active.id);
          const newIndex = value.findIndex(({ id }) => id === over.id);
          onChange(arrayMove([...value], oldIndex, newIndex));
        }
      }, onDragCancel: () => setActiveItem(null) },
      import_react21.default.createElement(
        "ul",
        { className: getClassName2("option-list"), "aria-describedby": descriptionId, "aria-labelledby": titleId, role: "list" },
        import_react21.default.createElement(SortableContext, { items: sortedOptions.map(({ id }) => id), strategy: verticalListSortingStrategy }, sortedOptions.map((option) => {
          return import_react21.default.createElement(DraggableOption, { dragHandleAriaLabel: i18n("contentDisplayPreference.dragHandleAriaLabel", dragHandleAriaLabel), key: option.id, onKeyDown: handleKeyDown, onToggle, option });
        }))
      ),
      import_react21.default.createElement(
        Portal,
        null,
        import_react21.default.createElement(DragOverlay, { className: styles_css_default5["drag-overlay"], dropAnimation: null, style: { zIndex: 5e3 } }, activeOption && import_react21.default.createElement(content_display_option_default, { listeners: { onKeyDown: handleKeyDown }, dragHandleAriaLabel: i18n("contentDisplayPreference.dragHandleAriaLabel", dragHandleAriaLabel), onToggle, option: activeOption }))
      )
    )
  );
}

// node_modules/@cloudscape-design/components/collection-preferences/index.js
var componentName = "CollectionPreferences";
function CollectionPreferences(_a) {
  var { title, confirmLabel, cancelLabel, disabled = false, onConfirm, onCancel, visibleContentPreference, contentDisplayPreference, pageSizePreference, wrapLinesPreference, stripedRowsPreference, contentDensityPreference, stickyColumnsPreference, preferences, customPreference } = _a, rest = __rest(_a, ["title", "confirmLabel", "cancelLabel", "disabled", "onConfirm", "onCancel", "visibleContentPreference", "contentDisplayPreference", "pageSizePreference", "wrapLinesPreference", "stripedRowsPreference", "contentDensityPreference", "stickyColumnsPreference", "preferences", "customPreference"]);
  const { __internalRootRef } = useBaseComponent("CollectionPreferences");
  checkControlled("CollectionPreferences", "preferences", preferences, "onConfirm", onConfirm);
  const i18n = useInternalI18n("collection-preferences");
  const baseProps = getBaseProps(rest);
  const [modalVisible, setModalVisible] = (0, import_react22.useState)(false);
  const [temporaryPreferences, setTemporaryPreferences] = (0, import_react22.useState)(copyPreferences(preferences || {}));
  const triggerRef = (0, import_react22.useRef)(null);
  const dialogPreviouslyOpen = (0, import_react22.useRef)(false);
  (0, import_react22.useEffect)(() => {
    if (!modalVisible) {
      dialogPreviouslyOpen.current && triggerRef.current && triggerRef.current.focus();
    } else {
      dialogPreviouslyOpen.current = true;
    }
  }, [modalVisible]);
  const onConfirmListener = () => {
    setModalVisible(false);
    fireNonCancelableEvent(onConfirm, temporaryPreferences);
  };
  const onCancelListener = () => {
    fireNonCancelableEvent(onCancel, {});
    setModalVisible(false);
    setTemporaryPreferences(copyPreferences(preferences || {}));
  };
  const hasContentOnTheLeft = !!(pageSizePreference || wrapLinesPreference || stripedRowsPreference || contentDensityPreference || stickyColumnsPreference || customPreference);
  const hasContentOnTheRight = !!(visibleContentPreference || contentDisplayPreference);
  const onChange = (changedPreferences) => setTemporaryPreferences(mergePreferences(changedPreferences, temporaryPreferences));
  if (visibleContentPreference && contentDisplayPreference) {
    warnOnce(componentName, "You provided both `visibleContentPreference` and `contentDisplayPreference` props. `visibleContentPreference` will be ignored and only `contentDisplayPreference` will be rendered.");
  }
  return import_react22.default.createElement(
    "div",
    Object.assign({}, baseProps, { className: clsx_m_default(baseProps.className, styles_css_default5.root), ref: __internalRootRef }),
    import_react22.default.createElement(InternalButton, { ref: triggerRef, className: styles_css_default5["trigger-button"], disabled, ariaLabel: i18n("title", title), onClick: () => {
      setTemporaryPreferences(copyPreferences(preferences || {}));
      setModalVisible(true);
    }, variant: "icon", iconName: "settings", formAction: "none" }),
    !disabled && modalVisible && import_react22.default.createElement(
      InternalModal,
      { className: styles_css_default5["modal-root"], visible: true, header: i18n("title", title), footer: import_react22.default.createElement(
        InternalBox,
        { float: "right" },
        import_react22.default.createElement(
          InternalSpaceBetween,
          { direction: "horizontal", size: "xs" },
          import_react22.default.createElement(InternalButton, { className: styles_css_default5["cancel-button"], variant: "link", formAction: "none", onClick: onCancelListener }, i18n("cancelLabel", cancelLabel)),
          import_react22.default.createElement(InternalButton, { className: styles_css_default5["confirm-button"], variant: "primary", formAction: "none", onClick: onConfirmListener }, i18n("confirmLabel", confirmLabel))
        )
      ), closeAriaLabel: cancelLabel, size: hasContentOnTheLeft && hasContentOnTheRight ? "large" : "medium", onDismiss: onCancelListener },
      import_react22.default.createElement(ModalContentLayout, { left: hasContentOnTheLeft && import_react22.default.createElement(
        InternalSpaceBetween,
        { size: "l" },
        pageSizePreference && import_react22.default.createElement(PageSizePreference, Object.assign({ value: temporaryPreferences.pageSize }, pageSizePreference, { onChange: (pageSize) => onChange({ pageSize }) })),
        wrapLinesPreference && import_react22.default.createElement(WrapLinesPreference, Object.assign({ value: temporaryPreferences.wrapLines }, wrapLinesPreference, { onChange: (wrapLines) => onChange({ wrapLines }) })),
        stripedRowsPreference && import_react22.default.createElement(StripedRowsPreference, Object.assign({ value: temporaryPreferences.stripedRows }, stripedRowsPreference, { onChange: (stripedRows) => onChange({ stripedRows }) })),
        contentDensityPreference && import_react22.default.createElement(ContentDensityPreference, Object.assign({ value: temporaryPreferences.contentDensity }, contentDensityPreference, { onChange: (contentDensity) => onChange({ contentDensity }) })),
        stickyColumnsPreference && import_react22.default.createElement(StickyColumnsPreference, Object.assign({ value: temporaryPreferences.stickyColumns }, stickyColumnsPreference, { onChange: (stickyColumns) => onChange({ stickyColumns }) })),
        customPreference && import_react22.default.createElement(CustomPreference, { value: temporaryPreferences.custom, customPreference, onChange: (custom) => onChange({ custom }) })
      ), right: contentDisplayPreference ? import_react22.default.createElement(ContentDisplayPreference, Object.assign({}, contentDisplayPreference, { value: temporaryPreferences.contentDisplay, onChange: (contentDisplay) => onChange({ contentDisplay }) })) : visibleContentPreference && import_react22.default.createElement(VisibleContentPreference, Object.assign({ value: temporaryPreferences.visibleContent }, visibleContentPreference, { onChange: (visibleItems) => onChange({ visibleContent: visibleItems }) })) })
    )
  );
}
applyDisplayName(CollectionPreferences, componentName);

export {
  InternalModal,
  ColumnLayout,
  useRadioGroupForwardFocus,
  internal_default4 as internal_default,
  internal_default5 as internal_default2,
  checkControlled,
  CollectionPreferences
};
//# sourceMappingURL=chunk-C7WOBM2X.js.map
