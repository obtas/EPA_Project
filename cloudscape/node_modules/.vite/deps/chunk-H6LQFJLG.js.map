{
  "version": 3,
  "sources": ["../../@cloudscape-design/components/internal/components/live-region/internal/components/live-region/index.tsx", "../../@cloudscape-design/components/internal/components/screenreader-only/internal/components/screenreader-only/index.tsx", "../../@cloudscape-design/components/internal/components/screenreader-only/styles.css.js", "../../@cloudscape-design/components/internal/components/live-region/styles.css.js"],
  "sourcesContent": ["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\n/* eslint-disable @cloudscape-design/prefer-live-region */\n\nimport clsx from 'clsx';\nimport React, { memo, useEffect, useRef } from 'react';\nimport ScreenreaderOnly, { ScreenreaderOnlyProps } from '../screenreader-only';\nimport styles from './styles.css.js';\n\nexport interface LiveRegionProps extends ScreenreaderOnlyProps {\n  assertive?: boolean;\n  delay?: number;\n  visible?: boolean;\n  tagName?: 'span' | 'div';\n  children: React.ReactNode;\n  id?: string;\n}\n\n/**\n * The live region is hidden in the layout, but visible for screen readers.\n * It's purpose it to announce changes e.g. when custom navigation logic is used.\n *\n * The way live region works differently in different browsers and screen readers and\n * it is recommended to manually test every new implementation.\n *\n * If you notice there are different words being merged together,\n * check if there are text nodes not being wrapped in elements, like:\n * <LiveRegion>\n *   {title}\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * To fix, wrap \"title\" in an element:\n * <LiveRegion>\n *   <span>{title}</span>\n *   <span><Details /></span>\n * </LiveRegion>\n *\n * Or create a single text node if possible:\n * <LiveRegion>\n *   {`${title} ${details}`}\n * </LiveRegion>\n *\n * The live region is always atomic, because non-atomic regions can be treated by screen readers\n * differently and produce unexpected results. To imitate non-atomic announcements simply use\n * multiple live regions:\n * <>\n *   <LiveRegion>{title}</LiveRegion>\n *   <LiveRegion><Details /></LiveRegion>\n * </>\n */\nexport default memo(LiveRegion);\n\nfunction LiveRegion({\n  assertive = false,\n  delay = 10,\n  visible = false,\n  tagName: TagName = 'span',\n  children,\n  id,\n  ...restProps\n}: LiveRegionProps) {\n  const sourceRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n  const targetRef = useRef<HTMLSpanElement & HTMLDivElement>(null);\n\n  /*\n    When React state changes, React often produces too many DOM updates, causing NVDA to\n    issue many announcements for the same logical event (See https://github.com/nvaccess/nvda/issues/7996).\n\n    The code below imitates a debouncing, scheduling a callback every time new React state\n    update is detected. When a callback resolves, it copies content from a muted element\n    to the live region, which is recognized by screen readers as an update.\n\n    If the use case requires no announcement to be ignored, use delay = 0, but ensure it\n    does not impact the performance. If it does, prefer using a string as children prop.\n  */\n  useEffect(() => {\n    function updateLiveRegion() {\n      if (targetRef.current && sourceRef.current) {\n        const sourceContent = extractInnerText(sourceRef.current);\n        const targetContent = extractInnerText(targetRef.current);\n        if (targetContent !== sourceContent) {\n          // The aria-atomic does not work properly in Voice Over, causing\n          // certain parts of the content to be ignored. To fix that,\n          // we assign the source text content as a single node.\n          targetRef.current.innerText = sourceContent;\n        }\n      }\n    }\n\n    let timeoutId: null | number;\n    if (delay) {\n      timeoutId = setTimeout(updateLiveRegion, delay);\n    } else {\n      updateLiveRegion();\n    }\n\n    return () => {\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n      }\n    };\n  });\n\n  return (\n    <>\n      {visible && (\n        <TagName ref={sourceRef} id={id}>\n          {children}\n        </TagName>\n      )}\n\n      <ScreenreaderOnly {...restProps} className={clsx(styles.root, restProps.className)}>\n        {!visible && (\n          <TagName ref={sourceRef} aria-hidden=\"true\">\n            {children}\n          </TagName>\n        )}\n\n        <span ref={targetRef} aria-atomic=\"true\" aria-live={assertive ? 'assertive' : 'polite'}></span>\n      </ScreenreaderOnly>\n    </>\n  );\n}\n\n// This only extracts text content from the node including all its children which is enough for now.\n// To make it more powerful, it is possible to create a more sophisticated extractor with respect to\n// ARIA properties to ignore aria-hidden nodes and read ARIA labels from the live content.\nfunction extractInnerText(node: HTMLElement) {\n  return (node.innerText || '').replace(/\\s+/g, ' ').trim();\n}\n", "// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport clsx from 'clsx';\nimport React from 'react';\nimport styles from './styles.css.js';\n\nexport interface ScreenreaderOnlyProps {\n  id?: string;\n  className?: string;\n  children: React.ReactNode;\n}\n\n/**\n * Makes content now shown on a screen but still announced by screen-reader users.\n * The component is suitable when the aria-label cannot be used, e.g. to avoid elemnts being announced as \"blank\".\n *\n * To exclude screenreader-only content use `:not(.${screenreaderOnlyStyles.root})` selector, for example:\n *\n * ```\n * import screenreaderOnlyStyles from '~internal/components/screenreader-only/styles.css.js'\n *\n * let visibleContent = wrapper.find(`${styles.label}`).find(`:not(.${screenreaderOnlyStyles.root})`).getElement().textContent\n *\n * let screenreaderContent = wrapper.find(`${styles.label}`).find(`.${screenreaderOnlyStyles.root}`).getElement().textContent\n * ```\n */\nexport default function ScreenreaderOnly(props: ScreenreaderOnlyProps) {\n  return <span {...props} className={clsx(styles.root, props.className)} />;\n}\n", "\n    import './styles.scoped.css';\n    export default {\n  \"root\": \"awsui_root_xttbq_1i4dh_93\"\n};\n  ", "\n    import './styles.scoped.css';\n    export default {\n  \"root\": \"awsui_root_3bgfn_im8v7_5\"\n};\n  "],
  "mappings": ";;;;;;;;;;AAMA,IAAAA,gBAA+C;;;ACF/C,mBAAkB;;;ACHd,OAAO;AACP,IAAO,qBAAQ;AAAA,EACjB,QAAQ;AACV;;;ADuBc,SAAP,iBAAkC,OAA4B;AACnE,SAAO,aAAAC,QAAA,cAAA,QAAA,OAAA,OAAA,CAAA,GAAU,OAAK,EAAE,WAAW,eAAK,mBAAO,MAAM,MAAM,SAAS,EAAC,CAAA,CAAA;AACvE;;;AE5BI,OAAO;AACP,IAAOC,sBAAQ;AAAA,EACjB,QAAQ;AACV;;;AHgDA,IAAA,0BAAe,oBAAK,UAAU;AAE9B,SAAS,WAAW,IAQF;MARE,EAClB,YAAY,OACZ,QAAQ,IACR,UAAU,OACV,SAAS,UAAU,QACnB,UACA,GAAE,IAAA,IACC,YAAS,OAAA,IAPM,CAAA,aAAA,SAAA,WAAA,WAAA,YAAA,IAAA,CAQnB;AACC,QAAM,gBAAY,sBAAyC,IAAI;AAC/D,QAAM,gBAAY,sBAAyC,IAAI;AAa/D,+BAAU,MAAK;AACb,aAAS,mBAAgB;AACvB,UAAI,UAAU,WAAW,UAAU,SAAS;AAC1C,cAAM,gBAAgB,iBAAiB,UAAU,OAAO;AACxD,cAAM,gBAAgB,iBAAiB,UAAU,OAAO;AACxD,YAAI,kBAAkB,eAAe;AAInC,oBAAU,QAAQ,YAAY;;;IAGpC;AAEA,QAAI;AACJ,QAAI,OAAO;AACT,kBAAY,WAAW,kBAAkB,KAAK;WACzC;AACL,uBAAgB;;AAGlB,WAAO,MAAK;AACV,UAAI,WAAW;AACb,qBAAa,SAAS;;IAE1B;EACF,CAAC;AAED,SACE,cAAAC,QAAA;IAAA,cAAAA,QAAA;IAAA;IACG,WACC,cAAAA,QAAA,cAAC,SAAO,EAAC,KAAK,WAAW,GAAM,GAC5B,QAAQ;IAIb,cAAAA,QAAA;MAAC;MAAgB,OAAA,OAAA,CAAA,GAAK,WAAS,EAAE,WAAW,eAAKC,oBAAO,MAAM,UAAU,SAAS,EAAC,CAAA;MAC/E,CAAC,WACA,cAAAD,QAAA,cAAC,SAAO,EAAC,KAAK,WAAS,eAAc,OAAM,GACxC,QAAQ;MAIb,cAAAA,QAAA,cAAA,QAAA,EAAM,KAAK,WAAS,eAAc,QAAM,aAAY,YAAY,cAAc,SAAQ,CAAA;IAAS;EAC9E;AAGzB;AAKA,SAAS,iBAAiB,MAAiB;AACzC,UAAQ,KAAK,aAAa,IAAI,QAAQ,QAAQ,GAAG,EAAE,KAAI;AACzD;",
  "names": ["import_react", "React", "styles_css_default", "React", "styles_css_default"]
}
