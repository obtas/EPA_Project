import {
  focus_lock_default
} from "./chunk-NUB4MB4Q.js";
import {
  InternalButton
} from "./chunk-WKOYGYGF.js";
import {
  useInternalI18n
} from "./chunk-VOJM65QS.js";
import {
  useUniqueId
} from "./chunk-ZOQJCCJI.js";
import {
  useResizeObserver
} from "./chunk-6QG3XHFW.js";
import {
  KeyCode,
  clsx_m_default,
  getContainingBlock,
  nodeContains,
  useVisualRefresh
} from "./chunk-BATVD76T.js";
import {
  __toESM,
  require_react
} from "./chunk-C3URVCCN.js";

// node_modules/@cloudscape-design/components/popover/styles.css.js
import "/local/home/samilafo/final_epa_project/cloudscape_wrkshp/cloudscape-design-system-workshop/node_modules/@cloudscape-design/components/popover/styles.scoped.css";
var styles_css_default = {
  "arrow": "awsui_arrow_xjuzf_4e9fa_185",
  "arrow-outer": "awsui_arrow-outer_xjuzf_4e9fa_189",
  "arrow-inner": "awsui_arrow-inner_xjuzf_4e9fa_189",
  "arrow-position-right-top": "awsui_arrow-position-right-top_xjuzf_4e9fa_220",
  "arrow-position-right-bottom": "awsui_arrow-position-right-bottom_xjuzf_4e9fa_220",
  "arrow-position-left-top": "awsui_arrow-position-left-top_xjuzf_4e9fa_223",
  "arrow-position-left-bottom": "awsui_arrow-position-left-bottom_xjuzf_4e9fa_223",
  "arrow-position-top-center": "awsui_arrow-position-top-center_xjuzf_4e9fa_226",
  "arrow-position-top-right": "awsui_arrow-position-top-right_xjuzf_4e9fa_226",
  "arrow-position-top-left": "awsui_arrow-position-top-left_xjuzf_4e9fa_226",
  "arrow-position-top-responsive": "awsui_arrow-position-top-responsive_xjuzf_4e9fa_226",
  "arrow-position-bottom-center": "awsui_arrow-position-bottom-center_xjuzf_4e9fa_229",
  "arrow-position-bottom-right": "awsui_arrow-position-bottom-right_xjuzf_4e9fa_229",
  "arrow-position-bottom-left": "awsui_arrow-position-bottom-left_xjuzf_4e9fa_229",
  "arrow-position-bottom-responsive": "awsui_arrow-position-bottom-responsive_xjuzf_4e9fa_229",
  "body": "awsui_body_xjuzf_4e9fa_325",
  "body-overflow-visible": "awsui_body-overflow-visible_xjuzf_4e9fa_341",
  "has-dismiss": "awsui_has-dismiss_xjuzf_4e9fa_345",
  "dismiss": "awsui_dismiss_xjuzf_4e9fa_350",
  "dismiss-control": "awsui_dismiss-control_xjuzf_4e9fa_357",
  "header-row": "awsui_header-row_xjuzf_4e9fa_361",
  "header": "awsui_header_xjuzf_4e9fa_361",
  "content": "awsui_content_xjuzf_4e9fa_387",
  "content-overflow-visible": "awsui_content-overflow-visible_xjuzf_4e9fa_395",
  "container": "awsui_container_xjuzf_4e9fa_491",
  "container-body": "awsui_container-body_xjuzf_4e9fa_499",
  "container-body-variant-annotation": "awsui_container-body-variant-annotation_xjuzf_4e9fa_516",
  "container-body-size-small": "awsui_container-body-size-small_xjuzf_4e9fa_521",
  "fixed-width": "awsui_fixed-width_xjuzf_4e9fa_524",
  "container-body-size-medium": "awsui_container-body-size-medium_xjuzf_4e9fa_528",
  "container-body-size-large": "awsui_container-body-size-large_xjuzf_4e9fa_535",
  "container-arrow": "awsui_container-arrow_xjuzf_4e9fa_547",
  "container-arrow-position-right-top": "awsui_container-arrow-position-right-top_xjuzf_4e9fa_551",
  "container-arrow-position-right-bottom": "awsui_container-arrow-position-right-bottom_xjuzf_4e9fa_551",
  "container-arrow-position-left-top": "awsui_container-arrow-position-left-top_xjuzf_4e9fa_563",
  "container-arrow-position-left-bottom": "awsui_container-arrow-position-left-bottom_xjuzf_4e9fa_563",
  "container-arrow-position-top-center": "awsui_container-arrow-position-top-center_xjuzf_4e9fa_575",
  "container-arrow-position-top-right": "awsui_container-arrow-position-top-right_xjuzf_4e9fa_575",
  "container-arrow-position-top-left": "awsui_container-arrow-position-top-left_xjuzf_4e9fa_575",
  "container-arrow-position-top-responsive": "awsui_container-arrow-position-top-responsive_xjuzf_4e9fa_575",
  "container-arrow-position-bottom-center": "awsui_container-arrow-position-bottom-center_xjuzf_4e9fa_591",
  "container-arrow-position-bottom-right": "awsui_container-arrow-position-bottom-right_xjuzf_4e9fa_595",
  "container-arrow-position-bottom-left": "awsui_container-arrow-position-bottom-left_xjuzf_4e9fa_599",
  "awsui-motion-fade-in": "awsui_awsui-motion-fade-in_xjuzf_4e9fa_1",
  "refresh": "awsui_refresh_xjuzf_4e9fa_717",
  "root": "awsui_root_xjuzf_4e9fa_739",
  "trigger": "awsui_trigger_xjuzf_4e9fa_753",
  "trigger-type-text": "awsui_trigger-type-text_xjuzf_4e9fa_760",
  "trigger-inner-text": "awsui_trigger-inner-text_xjuzf_4e9fa_789",
  "popover-content": "awsui_popover-content_xjuzf_4e9fa_793"
};

// node_modules/@cloudscape-design/components/popover/container.js
var import_react = __toESM(require_react());

// node_modules/@cloudscape-design/components/popover/utils/positions.js
var ARROW_OFFSET = 12;
var PRIORITY_MAPPING = {
  top: [
    "top-center",
    "top-right",
    "top-left",
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  bottom: [
    "bottom-center",
    "bottom-right",
    "bottom-left",
    "top-center",
    "top-right",
    "top-left",
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom"
  ],
  left: [
    "left-top",
    "left-bottom",
    "right-top",
    "right-bottom",
    "bottom-center",
    "top-center",
    "bottom-left",
    "top-left",
    "bottom-right",
    "top-right"
  ],
  right: [
    "right-top",
    "right-bottom",
    "left-top",
    "left-bottom",
    "bottom-center",
    "top-center",
    "bottom-right",
    "top-right",
    "bottom-left",
    "top-left"
  ]
};
var RECTANGLE_CALCULATIONS = {
  "top-center": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left + trigger.width / 2 - body.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "top-right": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left,
      width: body.width,
      height: body.height
    };
  },
  "top-left": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top - body.height - arrow.height,
      left: trigger.left + trigger.width - body.width,
      width: body.width,
      height: body.height
    };
  },
  "bottom-center": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left + trigger.width / 2 - body.width / 2,
      width: body.width,
      height: body.height
    };
  },
  "bottom-right": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left,
      width: body.width,
      height: body.height
    };
  },
  "bottom-left": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height + arrow.height,
      left: trigger.left + trigger.width - body.width,
      width: body.width,
      height: body.height
    };
  },
  "right-top": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,
      left: trigger.left + trigger.width + arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "right-bottom": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,
      left: trigger.left + trigger.width + arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "left-top": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - ARROW_OFFSET - arrow.height,
      left: trigger.left - body.width - arrow.height,
      width: body.width,
      height: body.height
    };
  },
  "left-bottom": ({ body, trigger, arrow }) => {
    return {
      top: trigger.top + trigger.height / 2 - body.height + ARROW_OFFSET + arrow.height,
      left: trigger.left - body.width - arrow.height,
      width: body.width,
      height: body.height
    };
  }
};
function canRectFit(inner, outer) {
  return inner.left >= outer.left && inner.top >= outer.top && inner.left + inner.width <= outer.left + outer.width && inner.top + inner.height <= outer.top + outer.height;
}
function fitIntoContainer(inner, outer) {
  let { left, width, top, height } = inner;
  if (left < outer.left) {
    width = left + width - outer.left;
    left = outer.left;
  } else if (left + width > outer.left + outer.width) {
    width = outer.left + outer.width - left;
  }
  if (top < outer.top) {
    height = top + height - outer.top;
    top = outer.top;
  } else if (top + height > outer.top + outer.height) {
    height = outer.top + outer.height - top;
  }
  return { left, width, top, height };
}
function getLargestRect(rect1, rect2) {
  const area1 = rect1.height * rect1.width;
  const area2 = rect2.height * rect2.width;
  return area1 >= area2 ? rect1 : rect2;
}
function intersectRectangles(rectangles) {
  let boundingOffset = null;
  for (const currentRect of rectangles) {
    if (!boundingOffset) {
      boundingOffset = currentRect;
      continue;
    }
    const left = Math.max(boundingOffset.left, currentRect.left);
    const top = Math.max(boundingOffset.top, currentRect.top);
    const right = Math.min(boundingOffset.left + boundingOffset.width, currentRect.left + currentRect.width);
    const bottom = Math.min(boundingOffset.top + boundingOffset.height, currentRect.top + currentRect.height);
    if (right < left || bottom < top) {
      return null;
    }
    boundingOffset = {
      left,
      top,
      width: right - left,
      height: bottom - top
    };
  }
  return boundingOffset && boundingOffset.height * boundingOffset.width;
}
function calculatePosition(preferred, trigger, arrow, body, container, viewport, renderWithPortal) {
  let bestPositionOutsideViewport = null;
  let largestArea = 0;
  for (const internalPosition2 of PRIORITY_MAPPING[preferred]) {
    const boundingOffset = RECTANGLE_CALCULATIONS[internalPosition2]({ body, trigger, arrow });
    const fitsInContainer = renderWithPortal || canRectFit(boundingOffset, container);
    const fitsInViewport = canRectFit(boundingOffset, viewport);
    if (fitsInContainer && fitsInViewport) {
      return { internalPosition: internalPosition2, boundingOffset };
    }
    const boundingRectangles = [boundingOffset, viewport];
    if (!renderWithPortal) {
      boundingRectangles.push(container);
    }
    const availableArea = intersectRectangles(boundingRectangles);
    if (availableArea && availableArea > largestArea) {
      bestPositionOutsideViewport = { internalPosition: internalPosition2, boundingOffset };
      largestArea = availableArea;
    }
  }
  const internalPosition = (bestPositionOutsideViewport === null || bestPositionOutsideViewport === void 0 ? void 0 : bestPositionOutsideViewport.internalPosition) || "right-top";
  const defaultOffset = RECTANGLE_CALCULATIONS[internalPosition]({ body, trigger, arrow });
  const optimisedOffset = fitIntoContainer(defaultOffset, renderWithPortal ? viewport : getLargestRect(container, viewport));
  const scrollable = optimisedOffset.height < defaultOffset.height;
  return { internalPosition, boundingOffset: optimisedOffset, scrollable };
}

// node_modules/@cloudscape-design/components/popover/container.js
var INITIAL_STYLES = { position: "absolute", top: -9999, left: -9999 };
function PopoverContainer({ position, trackRef, trackKey, arrow, children, zIndex, renderWithPortal, size, fixedWidth, variant }) {
  const bodyRef = (0, import_react.useRef)(null);
  const contentRef = (0, import_react.useRef)(null);
  const popoverRef = (0, import_react.useRef)(null);
  const arrowRef = (0, import_react.useRef)(null);
  const [popoverStyle, setPopoverStyle] = (0, import_react.useState)(INITIAL_STYLES);
  const [internalPosition, setInternalPosition] = (0, import_react.useState)(null);
  const isRefresh = useVisualRefresh();
  const positionHandlerRef = (0, import_react.useRef)(() => {
  });
  const updatePositionHandler = (0, import_react.useCallback)(() => {
    if (!trackRef.current || !popoverRef.current || !bodyRef.current || !contentRef.current || !arrowRef.current) {
      return;
    }
    const popover = popoverRef.current;
    const body = bodyRef.current;
    const arrow2 = arrowRef.current;
    const document = popover.ownerDocument;
    const track = trackRef.current;
    if (popover.offsetWidth === 0 || popover.offsetHeight === 0 || !nodeContains(document.body, track)) {
      return;
    }
    const prevTop = popover.style.top;
    const prevLeft = popover.style.left;
    popover.style.top = "0";
    popover.style.left = "0";
    body.style.maxHeight = "";
    body.style.overflowX = "";
    body.style.overflowY = "";
    const viewportRect = getViewportRect(document.defaultView);
    const trackRect = track.getBoundingClientRect();
    const arrowRect = {
      width: parseFloat(getComputedStyle(arrow2).width),
      height: parseFloat(getComputedStyle(arrow2).height)
    };
    const containingBlock = getContainingBlock(popover);
    const containingBlockRect = containingBlock ? containingBlock.getBoundingClientRect() : viewportRect;
    const bodyBorderWidth = getBorderWidth(body);
    const contentRect = contentRef.current.getBoundingClientRect();
    const contentBoundingBox = {
      width: contentRect.width + 2 * bodyBorderWidth,
      height: contentRect.height + 2 * bodyBorderWidth
    };
    const { scrollable, internalPosition: newInternalPosition, boundingOffset } = calculatePosition(position, trackRect, arrowRect, contentBoundingBox, containingBlock ? containingBlockRect : getDocumentRect(document), viewportRect, renderWithPortal);
    const popoverOffset = toRelativePosition(boundingOffset, containingBlockRect);
    const trackRelativeOffset = toRelativePosition(popoverOffset, toRelativePosition(trackRect, containingBlockRect));
    popover.style.top = prevTop;
    popover.style.left = prevLeft;
    if (scrollable) {
      body.style.maxHeight = boundingOffset.height + "px";
      body.style.overflowX = "hidden";
      body.style.overflowY = "auto";
    }
    setInternalPosition(newInternalPosition);
    setPopoverStyle({ top: popoverOffset.top, left: popoverOffset.left });
    positionHandlerRef.current = () => {
      const newTrackOffset = toRelativePosition(track.getBoundingClientRect(), containingBlock ? containingBlock.getBoundingClientRect() : viewportRect);
      setPopoverStyle({
        top: newTrackOffset.top + trackRelativeOffset.top,
        left: newTrackOffset.left + trackRelativeOffset.left
      });
    };
  }, [position, trackRef, renderWithPortal]);
  (0, import_react.useLayoutEffect)(() => {
    updatePositionHandler();
  }, [updatePositionHandler, trackKey]);
  useResizeObserver(contentRef, () => updatePositionHandler());
  (0, import_react.useLayoutEffect)(() => {
    const updatePosition = () => requestAnimationFrame(() => updatePositionHandler());
    const refreshPosition = () => requestAnimationFrame(() => positionHandlerRef.current());
    window.addEventListener("click", updatePosition);
    window.addEventListener("resize", updatePosition);
    window.addEventListener("scroll", refreshPosition, true);
    return () => {
      window.removeEventListener("click", updatePosition);
      window.removeEventListener("resize", updatePosition);
      window.removeEventListener("scroll", refreshPosition, true);
    };
  }, [updatePositionHandler]);
  return import_react.default.createElement(
    "div",
    { ref: popoverRef, style: Object.assign(Object.assign({}, popoverStyle), { zIndex }), className: clsx_m_default(styles_css_default.container, isRefresh && styles_css_default.refresh) },
    import_react.default.createElement("div", { ref: arrowRef, className: clsx_m_default(styles_css_default[`container-arrow`], styles_css_default[`container-arrow-position-${internalPosition}`]), "aria-hidden": true }, arrow(internalPosition)),
    import_react.default.createElement(
      "div",
      { ref: bodyRef, className: clsx_m_default(styles_css_default["container-body"], styles_css_default[`container-body-size-${size}`], {
        [styles_css_default["fixed-width"]]: fixedWidth,
        [styles_css_default[`container-body-variant-${variant}`]]: variant
      }) },
      import_react.default.createElement("div", { ref: contentRef }, children)
    )
  );
}
function getBorderWidth(element) {
  return parseInt(getComputedStyle(element).borderWidth) || 0;
}
function toRelativePosition(element, parent) {
  return {
    top: element.top - parent.top,
    left: element.left - parent.left
  };
}
function getViewportRect(window2) {
  return {
    top: 0,
    left: 0,
    width: window2.innerWidth,
    height: window2.innerHeight
  };
}
function getDocumentRect(document) {
  const { top, left } = document.documentElement.getBoundingClientRect();
  return {
    top,
    left,
    width: document.documentElement.scrollWidth,
    height: document.documentElement.scrollHeight
  };
}

// node_modules/@cloudscape-design/components/popover/body.js
var import_react2 = __toESM(require_react());
function PopoverBody({ dismissButton: showDismissButton, dismissAriaLabel, header, children, onDismiss, variant, overflowVisible, className, ariaLabelledby }) {
  const i18n = useInternalI18n("popover");
  const labelledById = useUniqueId("awsui-popover-");
  const dismissButtonFocused = (0, import_react2.useRef)(false);
  const dismissButtonRef = (0, import_react2.useRef)(null);
  const onKeyDown = (0, import_react2.useCallback)((event) => {
    if (event.keyCode === KeyCode.escape) {
      onDismiss();
    }
  }, [onDismiss]);
  (0, import_react2.useEffect)(() => {
    var _a;
    if (showDismissButton && !dismissButtonFocused.current) {
      (_a = dismissButtonRef.current) === null || _a === void 0 ? void 0 : _a.focus({ preventScroll: true });
    }
    dismissButtonFocused.current = showDismissButton;
  }, [showDismissButton]);
  const dismissButton = (showDismissButton !== null && showDismissButton !== void 0 ? showDismissButton : null) && import_react2.default.createElement(
    "div",
    { className: styles_css_default.dismiss },
    import_react2.default.createElement(InternalButton, { variant: "icon", formAction: "none", iconName: "close", className: styles_css_default["dismiss-control"], ariaLabel: i18n("dismissAriaLabel", dismissAriaLabel), onClick: () => onDismiss(), ref: dismissButtonRef })
  );
  const isDialog = showDismissButton;
  const shouldTrapFocus = showDismissButton && variant !== "annotation";
  const dialogProps = isDialog ? {
    role: "dialog",
    "aria-modal": shouldTrapFocus ? true : void 0,
    "aria-labelledby": ariaLabelledby !== null && ariaLabelledby !== void 0 ? ariaLabelledby : header ? labelledById : void 0
  } : {};
  return import_react2.default.createElement(
    "div",
    Object.assign({ className: clsx_m_default(styles_css_default.body, className, {
      [styles_css_default["body-overflow-visible"]]: overflowVisible === "both"
    }), onKeyDown }, dialogProps),
    import_react2.default.createElement(
      focus_lock_default,
      { disabled: !shouldTrapFocus, autoFocus: false },
      header && import_react2.default.createElement(
        "div",
        { className: clsx_m_default(styles_css_default["header-row"], showDismissButton && styles_css_default["has-dismiss"]) },
        dismissButton,
        import_react2.default.createElement(
          "div",
          { className: styles_css_default.header, id: labelledById },
          import_react2.default.createElement("h2", null, header)
        )
      ),
      import_react2.default.createElement(
        "div",
        { className: !header && showDismissButton ? styles_css_default["has-dismiss"] : void 0 },
        !header && dismissButton,
        import_react2.default.createElement("div", { className: clsx_m_default(styles_css_default.content, { [styles_css_default["content-overflow-visible"]]: !!overflowVisible }) }, children)
      )
    )
  );
}

export {
  styles_css_default,
  PopoverContainer,
  PopoverBody
};
//# sourceMappingURL=chunk-5MQZRYSX.js.map
