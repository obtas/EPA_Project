// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useEffect, useState } from 'react';
import { addMonths, endOfDay, isBefore, startOfDay, startOfMonth, isAfter, isSameMonth } from 'date-fns';
import styles from '../styles.css.js';
import CalendarHeader from './header';
import { Grids, selectFocusedDate } from './grids';
import clsx from 'clsx';
import { useUniqueId } from '../../internal/hooks/use-unique-id';
import { getDateLabel, renderTimeLabel } from '../../calendar/utils/intl';
import LiveRegion from '../../internal/components/live-region';
import { normalizeLocale, normalizeStartOfWeek } from '../../internal/utils/locale';
import { joinDateTime, parseDate } from '../../internal/utils/date-time';
import { getBaseDate } from '../../calendar/utils/navigation';
import { useMobile } from '../../internal/hooks/use-mobile/index.js';
import RangeInputs from './range-inputs.js';
import { useDateTime } from './use-date-time.js';
export default function DateRangePickerCalendar(_a) {
    var _b, _c;
    var _d, _e;
    var value = _a.value, onChange = _a.onChange, _f = _a.locale, locale = _f === void 0 ? '' : _f, startOfWeek = _a.startOfWeek, _g = _a.isDateEnabled, isDateEnabled = _g === void 0 ? function () { return true; } : _g, i18nStrings = _a.i18nStrings, _h = _a.dateOnly, dateOnly = _h === void 0 ? false : _h, _j = _a.timeInputFormat, timeInputFormat = _j === void 0 ? 'hh:mm:ss' : _j;
    var isSingleGrid = useMobile();
    var normalizedLocale = normalizeLocale('DateRangePicker', locale);
    var normalizedStartOfWeek = normalizeStartOfWeek(startOfWeek, normalizedLocale);
    var initialStartDate = (_d = value === null || value === void 0 ? void 0 : value.startDate) !== null && _d !== void 0 ? _d : '';
    var rangeStart = useDateTime(initialStartDate);
    var initialEndDate = (_e = value === null || value === void 0 ? void 0 : value.endDate) !== null && _e !== void 0 ? _e : '';
    var rangeEnd = useDateTime(initialEndDate);
    var _k = useState(''), announcement = _k[0], setAnnouncement = _k[1];
    var _l = useState(function () {
        if (rangeStart.dateString) {
            var startDate = parseDate(rangeStart.dateString);
            if (isSingleGrid) {
                return startOfMonth(startDate);
            }
            return startOfMonth(addMonths(startDate, 1));
        }
        if (rangeEnd.dateString) {
            return startOfMonth(parseDate(rangeEnd.dateString));
        }
        return startOfMonth(Date.now());
    }), currentMonth = _l[0], setCurrentMonth = _l[1];
    var _m = useState(function () {
        if (rangeStart.date) {
            if (isSameMonth(rangeStart.date, currentMonth)) {
                return rangeStart.date;
            }
            if (!isSingleGrid && isSameMonth(rangeStart.date, addMonths(currentMonth, -1))) {
                return rangeStart.date;
            }
        }
        return selectFocusedDate(rangeStart.date, currentMonth, isDateEnabled);
    }), focusedDate = _m[0], setFocusedDate = _m[1];
    // This effect "synchronizes" the local state update back up to the parent component.
    useEffect(function () {
        var startDate = joinDateTime(rangeStart.dateString, rangeStart.timeString);
        var endDate = joinDateTime(rangeEnd.dateString, rangeEnd.timeString);
        if (startDate !== initialStartDate || endDate !== initialEndDate) {
            onChange({ startDate: startDate, endDate: endDate });
        }
    }, [
        rangeStart.dateString,
        rangeStart.timeString,
        rangeEnd.dateString,
        rangeEnd.timeString,
        initialStartDate,
        initialEndDate,
        onChange,
    ]);
    var onSelectDateHandler = function (selectedDate) {
        // recommended to include the start/end time announced with the selection
        // because the user is not aware of the fact that a start/end time is also set as soon as they select a date
        var announceStart = function (startDate) {
            return (i18nStrings.startDateLabel +
                ', ' +
                getDateLabel(normalizedLocale, startDate) +
                ', ' +
                i18nStrings.startTimeLabel +
                ', ' +
                renderTimeLabel(normalizedLocale, startDate, timeInputFormat) +
                '. ');
        };
        var announceEnd = function (endDate) {
            return (i18nStrings.endDateLabel +
                ', ' +
                getDateLabel(normalizedLocale, endDate) +
                ', ' +
                i18nStrings.endTimeLabel +
                ', ' +
                renderTimeLabel(normalizedLocale, endDate, timeInputFormat) +
                '. ');
        };
        var announceRange = function (startDate, endDate) {
            if (!i18nStrings.renderSelectedAbsoluteRangeAriaLive) {
                return "".concat(getDateLabel(normalizedLocale, startDate), " \u2013 ").concat(getDateLabel(normalizedLocale, endDate));
            }
            return i18nStrings.renderSelectedAbsoluteRangeAriaLive(getDateLabel(normalizedLocale, startDate), getDateLabel(normalizedLocale, endDate));
        };
        // If both fields are empty, we set the start date
        if (!rangeStart.dateString && !rangeEnd.dateString) {
            var startDate = startOfDay(selectedDate);
            rangeStart.setDate(startDate);
            setAnnouncement(announceStart(startDate));
            return;
        }
        // If both fields are set, we start new
        if (rangeStart.dateString && rangeEnd.dateString) {
            var startDate = startOfDay(selectedDate);
            rangeStart.setDate(startDate);
            rangeEnd.setDate(null);
            setAnnouncement(announceStart(startDate));
            return;
        }
        // If only the END date is empty, we fill it (and swap dates if needed)
        if (rangeStart.dateString && !rangeEnd.dateString) {
            var parsedStartDate = parseDate(rangeStart.dateString);
            if (isBefore(selectedDate, parsedStartDate)) {
                // The user has selected the range backwards, so we swap start and end
                var startDate = startOfDay(selectedDate);
                var endDate = endOfDay(parsedStartDate);
                rangeStart.setDate(startDate);
                rangeEnd.setDate(endDate);
                setAnnouncement(announceStart(startDate) + announceRange(startDate, endDate));
            }
            else {
                var endDate = endOfDay(selectedDate);
                rangeEnd.setDate(endDate);
                setAnnouncement(announceEnd(endDate) + announceRange(parsedStartDate, endDate));
            }
            return;
        }
        // If only the START date is empty, we fill it (and swap dates if needed)
        if (!rangeStart.dateString && rangeEnd.dateString) {
            var existingEndDate = parseDate(rangeEnd.dateString);
            if (isAfter(selectedDate, existingEndDate)) {
                // The user has selected the range backwards, so we swap start and end
                var startDate = startOfDay(existingEndDate);
                var endDate = endOfDay(selectedDate);
                rangeStart.setDate(startDate);
                rangeEnd.setDate(endDate);
                setAnnouncement(announceEnd(endDate) + announceRange(startDate, endDate));
            }
            else {
                var startDate = startOfDay(selectedDate);
                rangeStart.setDate(startDate);
                setAnnouncement(announceStart(startDate) + announceRange(startDate, existingEndDate));
            }
            return;
        }
        // All possible conditions are covered above
    };
    var onHeaderChangeMonthHandler = function (newCurrentMonth) {
        setCurrentMonth(newCurrentMonth);
        var newBaseDateMonth = isSingleGrid ? newCurrentMonth : addMonths(newCurrentMonth, -1);
        var newBaseDate = getBaseDate(newBaseDateMonth, isDateEnabled);
        setFocusedDate(newBaseDate);
    };
    var onChangeStartDate = function (value) {
        rangeStart.setDateString(value);
        if (value.length >= 8) {
            var newCurrentMonth = startOfMonth(parseDate(value));
            setCurrentMonth(isSingleGrid ? newCurrentMonth : addMonths(newCurrentMonth, 1));
        }
    };
    var onChangeEndDate = function (value) {
        rangeEnd.setDateString(value);
    };
    var headingIdPrefix = useUniqueId('date-range-picker-calendar-heading');
    return (React.createElement(React.Fragment, null,
        React.createElement("div", { className: clsx(styles['calendar-container'], (_b = {},
                _b[styles['one-grid']] = isSingleGrid,
                _b)) },
            React.createElement("div", { className: clsx(styles.calendar, (_c = {},
                    _c[styles['one-grid']] = isSingleGrid,
                    _c)) },
                React.createElement(CalendarHeader, { baseDate: currentMonth, locale: normalizedLocale, onChangeMonth: onHeaderChangeMonthHandler, previousMonthLabel: i18nStrings.previousMonthAriaLabel, nextMonthLabel: i18nStrings.nextMonthAriaLabel, isSingleGrid: isSingleGrid, headingIdPrefix: headingIdPrefix }),
                React.createElement(Grids, { isSingleGrid: isSingleGrid, locale: normalizedLocale, baseDate: currentMonth, focusedDate: focusedDate, onFocusedDateChange: setFocusedDate, isDateEnabled: isDateEnabled, onSelectDate: onSelectDateHandler, onChangeMonth: setCurrentMonth, startOfWeek: normalizedStartOfWeek, todayAriaLabel: i18nStrings.todayAriaLabel, selectedStartDate: rangeStart.date, selectedEndDate: rangeEnd.date, headingIdPrefix: headingIdPrefix })),
            React.createElement(RangeInputs, { startDate: rangeStart.dateString, onChangeStartDate: onChangeStartDate, startTime: rangeStart.timeString, onChangeStartTime: rangeStart.setTimeString, endDate: rangeEnd.dateString, onChangeEndDate: onChangeEndDate, endTime: rangeEnd.timeString, onChangeEndTime: rangeEnd.setTimeString, i18nStrings: i18nStrings, dateOnly: dateOnly, timeInputFormat: timeInputFormat })),
        React.createElement(LiveRegion, { className: styles['calendar-aria-live'] }, announcement)));
}
//# sourceMappingURL=index.js.map