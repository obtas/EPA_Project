// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
import React, { useState, useEffect, useMemo, useCallback } from 'react';
import { fireNonCancelableEvent } from '../../internal/events';
import clsx from 'clsx';
import ResizeHandler from '../../split-panel/icons/resize-handler';
import { getLimitedValue } from '../../split-panel/utils/size-utils';
import { usePointerEvents } from './use-pointer-events';
import { useKeyboardEvents } from './use-keyboard-events';
import splitPanelStyles from '../../split-panel/styles.css.js';
import testutilStyles from '../test-classes/styles.css.js';
import styles from '../visual-refresh/styles.css.js';
function useResize(drawerRefObject, drawerResizeProps) {
    var _a, _b;
    const { activeDrawerId, drawers, drawersRefs, isToolsOpen, drawersMaxWidth } = drawerResizeProps;
    const activeDrawer = (_a = drawers === null || drawers === void 0 ? void 0 : drawers.items.find(item => item.id === activeDrawerId)) !== null && _a !== void 0 ? _a : null;
    const drawerItems = useMemo(() => (drawers === null || drawers === void 0 ? void 0 : drawers.items) || [], [drawers === null || drawers === void 0 ? void 0 : drawers.items]);
    const toolsWidth = 290;
    const MIN_WIDTH = (activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) && activeDrawer.defaultSize < 290 ? activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize : 290;
    const [relativeSize, setRelativeSize] = useState(0);
    const getDrawerItemSizes = useCallback(() => {
        const sizes = {};
        if (!drawerItems) {
            return {};
        }
        for (const item of drawerItems) {
            if (item.defaultSize) {
                sizes[item.id] = item.defaultSize;
            }
        }
        return sizes;
    }, [drawerItems]);
    const [drawerItemSizes, setDrawerItemSizes] = useState(() => getDrawerItemSizes());
    const drawerSize = !activeDrawerId && !isToolsOpen
        ? 0
        : activeDrawerId && drawerItemSizes[activeDrawerId]
            ? drawerItemSizes[activeDrawerId]
            : toolsWidth;
    useEffect(() => {
        // Ensure we only set new drawer items by performing a shallow merge
        // of the latest drawer item sizes, and previous drawer item sizes.
        setDrawerItemSizes(prev => (Object.assign(Object.assign({}, getDrawerItemSizes()), prev)));
    }, [getDrawerItemSizes]);
    useEffect(() => {
        // effects are called inside out in the components tree
        // wait one frame to allow app-layout to complete its calculations
        const handle = requestAnimationFrame(() => {
            const maxSize = drawersMaxWidth;
            setRelativeSize(((drawerSize - MIN_WIDTH) / (maxSize - MIN_WIDTH)) * 100);
        });
        return () => cancelAnimationFrame(handle);
    }, [drawerSize, drawersMaxWidth, MIN_WIDTH]);
    const drawerResize = (resizeDetail) => {
        const drawerItem = drawers === null || drawers === void 0 ? void 0 : drawers.items.find(item => item.id === resizeDetail.id);
        fireNonCancelableEvent(drawerItem === null || drawerItem === void 0 ? void 0 : drawerItem.onResize, resizeDetail);
        fireNonCancelableEvent(drawers === null || drawers === void 0 ? void 0 : drawers.onResize, resizeDetail);
        setDrawerItemSizes(Object.assign(Object.assign({}, drawerItemSizes), { [resizeDetail.id]: resizeDetail.size }));
    };
    const setSidePanelWidth = (width) => {
        const maxWidth = drawersMaxWidth;
        const size = getLimitedValue(MIN_WIDTH, width, maxWidth);
        const id = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id;
        if (id && maxWidth >= MIN_WIDTH) {
            drawerResize({ size, id });
        }
    };
    const position = 'side';
    const setBottomPanelHeight = () => { };
    const sizeControlProps = {
        position,
        panelRef: drawerRefObject,
        handleRef: drawersRefs.slider,
        setSidePanelWidth,
        setBottomPanelHeight,
        hasTransitions: true,
    };
    const onSliderPointerDown = usePointerEvents(sizeControlProps);
    const onKeyDown = useKeyboardEvents(sizeControlProps);
    const resizeHandle = (React.createElement("div", { ref: drawersRefs.slider, role: "slider", tabIndex: 0, "aria-label": (_b = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.ariaLabels) === null || _b === void 0 ? void 0 : _b.resizeHandle, "aria-valuemax": 100, "aria-valuemin": 0, "aria-valuenow": relativeSize, className: clsx(splitPanelStyles.slider, splitPanelStyles[`slider-side`], testutilStyles['drawers-slider']), onKeyDown: onKeyDown, onPointerDown: onSliderPointerDown },
        React.createElement(ResizeHandler, { className: clsx(splitPanelStyles['slider-icon'], splitPanelStyles[`slider-icon-side`]) })));
    return { resizeHandle: React.createElement("div", { className: styles['drawer-slider'] }, resizeHandle), drawerSize };
}
export default useResize;
//# sourceMappingURL=use-resize.js.map